;; Sema Stdlib: Map Functions
;; Tests all map/hashmap functions

(define (assert-eq actual expected label)
  (if (equal? actual expected)
    (println "  âœ“ " label)
    (error (format "  âœ— ~a: expected ~a, got ~a" label expected actual))))

(println "=== Map Functions ===")
(println)

;; hash-map
(define m (hash-map :name "Alice" :age 30))
(assert-eq (get m :name) "Alice" "hash-map / get")

;; get with default
(assert-eq (get m :missing "default") "default" "get with default")
(assert-eq (get m :missing) nil "get without default")

;; assoc (map-style)
(define m2 (assoc m :city "Oslo"))
(assert-eq (get m2 :city) "Oslo" "assoc add key")
(assert-eq (get m2 :name) "Alice" "assoc preserves existing")

;; dissoc
(define m3 (dissoc m2 :age))
(assert-eq (contains? m3 :age) #f "dissoc removes key")
(assert-eq (get m3 :name) "Alice" "dissoc preserves other keys")

;; keys
(define k (keys (hash-map :a 1 :b 2)))
(assert-eq (length k) 2 "keys count")

;; vals
(define v (vals (hash-map :x 10 :y 20)))
(assert-eq (length v) 2 "vals count")

;; merge
(define merged (merge (hash-map :a 1 :b 2) (hash-map :b 3 :c 4)))
(assert-eq (get merged :a) 1 "merge keeps first")
(assert-eq (get merged :b) 3 "merge overwrites")
(assert-eq (get merged :c) 4 "merge adds new")

;; contains?
(assert-eq (contains? m :name) #t "contains? true")
(assert-eq (contains? m :missing) #f "contains? false")

;; count
(assert-eq (count m) 2 "count map")
(assert-eq (count (list 1 2 3)) 3 "count list")
(assert-eq (count nil) 0 "count nil")

;; empty?
(assert-eq (empty? (hash-map)) #t "empty? true")
(assert-eq (empty? m) #f "empty? false")
(assert-eq (empty? (list)) #t "empty? list")
(assert-eq (empty? nil) #t "empty? nil")

;; map/entries
(define entries (map/entries (hash-map :a 1 :b 2)))
(assert-eq (length entries) 2 "map/entries count")
(assert-eq (first (first entries)) :a "map/entries first key")

;; map/map-vals
(define doubled (map/map-vals (fn (v) (* v 2)) (hash-map :x 1 :y 2 :z 3)))
(assert-eq (get doubled :x) 2 "map/map-vals x")
(assert-eq (get doubled :y) 4 "map/map-vals y")
(assert-eq (get doubled :z) 6 "map/map-vals z")

;; map/filter
(define filtered (map/filter (fn (k v) (> v 1)) (hash-map :a 1 :b 2 :c 3)))
(assert-eq (contains? filtered :a) #f "map/filter removes")
(assert-eq (get filtered :b) 2 "map/filter keeps b")
(assert-eq (get filtered :c) 3 "map/filter keeps c")

;; map/select-keys
(define selected (map/select-keys (hash-map :a 1 :b 2 :c 3) (list :a :c)))
(assert-eq (get selected :a) 1 "map/select-keys a")
(assert-eq (get selected :c) 3 "map/select-keys c")
(assert-eq (contains? selected :b) #f "map/select-keys excludes b")

;; map/map-keys
(define upper-keys (map/map-keys (fn (k) (string->keyword (string/upper (keyword->string k)))) (hash-map :a 1 :b 2)))
(assert-eq (get upper-keys :A) 1 "map/map-keys A")
(assert-eq (get upper-keys :B) 2 "map/map-keys B")

;; map/from-entries
(define from-e (map/from-entries (list (list :x 10) (list :y 20))))
(assert-eq (get from-e :x) 10 "map/from-entries x")
(assert-eq (get from-e :y) 20 "map/from-entries y")

;; map/update
(define updated (map/update (hash-map :count 5) :count (fn (v) (+ v 1))))
(assert-eq (get updated :count) 6 "map/update increment")

;; map/update on missing key (nil default)
(define updated2 (map/update (hash-map :a 1) :b (fn (v) 42)))
(assert-eq (get updated2 :b) 42 "map/update missing key")

(println)
(println "=== HashMap Functions ===")
(println)

;; hashmap/new
(define hm (hashmap/new :x 100 :y 200))

;; hashmap/get
(assert-eq (hashmap/get hm :x) 100 "hashmap/get")
(assert-eq (hashmap/get hm :missing "nope") "nope" "hashmap/get default")

;; hashmap/assoc
(define hm2 (hashmap/assoc hm :z 300))
(assert-eq (hashmap/get hm2 :z) 300 "hashmap/assoc")

;; hashmap/contains?
(assert-eq (hashmap/contains? hm :x) #t "hashmap/contains? true")
(assert-eq (hashmap/contains? hm :missing) #f "hashmap/contains? false")

;; hashmap/keys
(assert-eq (length (hashmap/keys hm)) 2 "hashmap/keys count")

;; hashmap/to-map
(define converted (hashmap/to-map hm))
(assert-eq (get converted :x) 100 "hashmap/to-map x")

;; keyword in function position: (:key map)
(assert-eq (:name m) "Alice" "keyword as function")

;; assoc (Scheme alist lookup)
(define alist (list (list :a 1) (list :b 2) (list :c 3)))
(assert-eq (assoc :b alist) (list :b 2) "assoc alist lookup")
(assert-eq (assoc :z alist) #f "assoc alist not found")

(println)
(println "All map tests passed!")
