;; record-types.sema â€” Showcase define-record-type (SRFI-9 style records)

(println "=== Record Types: Points, Shapes & Linked Lists ===\n")

;; --- Point ---
(define-record-type Point
  (make-point x y)
  point?
  (x point-x)
  (y point-y))

(define p1 (make-point 3 4))
(define p2 (make-point 7 1))

(println (format "p1 = (~a, ~a)" (point-x p1) (point-y p1)))
(println (format "p2 = (~a, ~a)" (point-x p2) (point-y p2)))
(println (format "p1 is a Point? ~a" (point? p1)))
(println (format "42 is a Point? ~a" (point? 42)))

(defun distance (a b)
  (let ((dx (- (point-x b) (point-x a)))
        (dy (- (point-y b) (point-y a))))
    (sqrt (+ (* dx dx) (* dy dy)))))

(println (format "Distance p1->p2: ~a" (distance p1 p2)))

;; --- Shapes ---
(println "\n=== Shapes: Circle & Rect ===\n")

(define-record-type Circle
  (make-circle center radius)
  circle?
  (center circle-center)
  (radius circle-radius))

(define-record-type Rect
  (make-rect origin width height)
  rect?
  (origin rect-origin)
  (width rect-width)
  (height rect-height))

(defun area (shape)
  (cond
    ((circle? shape) (* pi (expt (circle-radius shape) 2)))
    ((rect? shape)   (* (rect-width shape) (rect-height shape)))
    (else            (throw "Unknown shape"))))

(defun perimeter (shape)
  (cond
    ((circle? shape) (* 2 pi (circle-radius shape)))
    ((rect? shape)   (* 2 (+ (rect-width shape) (rect-height shape))))
    (else            (throw "Unknown shape"))))

(defun describe-shape (shape)
  (cond
    ((circle? shape)
     (let ((c (circle-center shape)))
       (format "Circle at (~a,~a) r=~a" (point-x c) (point-y c) (circle-radius shape))))
    ((rect? shape)
     (let ((o (rect-origin shape)))
       (format "Rect at (~a,~a) ~ax~a" (point-x o) (point-y o) (rect-width shape) (rect-height shape))))
    (else "Unknown")))

(define c1 (make-circle (make-point 0 0) 5))
(define r1 (make-rect (make-point 1 2) 10 6))

(for-each (fn (s)
  (println (format "~a  area=~a  perimeter=~a"
                   (describe-shape s)
                   (round (* (area s) 100) )
                   (round (* (perimeter s) 100)))))
  (list c1 r1))

;; --- Linked List using records ---
(println "\n=== Linked List via Records ===\n")

(define-record-type Cell
  (make-cell head tail)
  cell?
  (head cell-head)
  (tail cell-tail))

(define empty-list nil)

(defun cell-empty? (lst) (null? lst))

(defun cell-from-list (items)
  (foldr make-cell empty-list items))

(defun cell-to-list (lst)
  (if (cell-empty? lst)
    '()
    (cons (cell-head lst) (cell-to-list (cell-tail lst)))))

(defun cell-length (lst)
  (if (cell-empty? lst)
    0
    (+ 1 (cell-length (cell-tail lst)))))

(defun cell-map (f lst)
  (if (cell-empty? lst)
    empty-list
    (make-cell (f (cell-head lst)) (cell-map f (cell-tail lst)))))

(define my-list (cell-from-list '(10 20 30 40 50)))

(println (format "Linked list length: ~a" (cell-length my-list)))
(println (format "Head: ~a" (cell-head my-list)))
(println (format "As list: ~a" (cell-to-list my-list)))

(define doubled (cell-map (fn (x) (* x 2)) my-list))
(println (format "Doubled:  ~a" (cell-to-list doubled)))

(println "\n=== Done ===")
