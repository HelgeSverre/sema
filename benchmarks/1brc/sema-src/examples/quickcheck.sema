;;; quickcheck.sema — Property-based testing framework
;;;
;;; Generate random inputs, test properties, report failures
;;; with shrinking to find minimal counterexamples.
;;;
;;; Demonstrates: closures as generators, higher-order functions,
;;;               math/random-int, error handling, recursive shrinking

(define qc-num-tests 100)

;;; --- Random generators ---

;; A generator is a zero-argument function that returns a random value

(define (gen/int lo hi)
  (fn () (math/random-int lo hi)))

(define (gen/nat)
  (gen/int 0 1000))

(define (gen/bool)
  (fn () (= 0 (math/random-int 0 1))))

(define (gen/char)
  (fn () (char->string (integer->char (math/random-int 32 126)))))

(define (gen/string-of max-len)
  (fn ()
    (let ((len (math/random-int 0 max-len)))
      (string/join
        (map (fn (_) ((gen/char))) (range len))
        ""))))

(define (gen/list-of elem-gen max-len)
  (fn ()
    (let ((len (math/random-int 0 max-len)))
      (map (fn (_) (elem-gen)) (range len)))))

(define (gen/one-of . items)
  (fn () (nth items (math/random-int 0 (- (length items) 1)))))

(define (gen/pair gen-a gen-b)
  (fn () (list (gen-a) (gen-b))))

;; Generate a value, then apply a function to it
(define (gen/map f gen)
  (fn () (f (gen))))

;;; --- Shrinking ---

;; Shrink an integer toward zero
(define (shrink-int n)
  (if (= n 0) '()
    (let ((half (if (> n 0) (floor (/ n 2)) (ceil (/ n 2)))))
      (list 0 half))))

;; Shrink a list by removing elements
(define (shrink-list lst)
  (if (null? lst) '()
    (cons '()
      (map (fn (i)
             (append (take i lst) (drop (+ i 1) lst)))
           (range (length lst))))))

;; Shrink a string by removing characters
(define (shrink-string s)
  (if (= (string-length s) 0) '()
    (cons ""
      (map (fn (i)
             (string-append (substring s 0 i)
                            (substring s (+ i 1) (string-length s))))
           (range (string-length s))))))

;; Try shrinking a failing value to find a minimal counterexample
(define (find-minimal prop val shrinker)
  (let loop ((current val) (fuel 50))
    (if (= fuel 0) current
      (let ((candidates (shrinker current)))
        (let check ((cs candidates))
          (if (null? cs) current
            (if (not (prop (car cs)))
              ;; Found a smaller failing case — keep shrinking
              (loop (car cs) (- fuel 1))
              ;; This candidate passes — check next
              (check (cdr cs)))))))))

;;; --- Test runner ---

;; Check a property with a generator.
;; Returns {:status :pass} or {:status :fail :counterexample val :shrunk val}
(define (check-property prop gen shrinker)
  (let loop ((i 0))
    (if (= i qc-num-tests)
      {:status :pass :tests qc-num-tests}
      (let ((val (gen)))
        (if (prop val)
          (loop (+ i 1))
          ;; Found a failure — try to shrink
          (let ((shrunk (if shrinker (find-minimal prop val shrinker) val)))
            {:status :fail
             :counterexample val
             :shrunk shrunk
             :after-tests (+ i 1)}))))))

;; Multi-argument property checking
(define (check-property-2 prop gen-a gen-b shrinker-a shrinker-b)
  (let loop ((i 0))
    (if (= i qc-num-tests)
      {:status :pass :tests qc-num-tests}
      (let ((a (gen-a)) (b (gen-b)))
        (if (prop a b)
          (loop (+ i 1))
          {:status :fail
           :counterexample (list a b)
           :after-tests (+ i 1)})))))

;; Nice formatting for test results
(define (report name result)
  (if (= (get result :status) :pass)
    (println (format "  PASS  ~a (~a tests)" name (get result :tests)))
    (begin
      (println (format "  FAIL  ~a (after ~a tests)" name (get result :after-tests)))
      (println (format "        counterexample: ~a" (get result :counterexample)))
      (when (not (= (get result :counterexample) (get result :shrunk)))
        (println (format "        shrunk to:      ~a" (get result :shrunk)))))))

;;; --- Demos ---

(println "=== Property-Based Testing (QuickCheck) ===\n")
(println (format "Running ~a tests per property...\n" qc-num-tests))

;; --- Properties that should PASS ---

(println "--- Properties that should pass ---")

;; Addition is commutative
(report "add-commutative"
  (check-property-2
    (fn (a b) (= (+ a b) (+ b a)))
    (gen/int -1000 1000) (gen/int -1000 1000)
    nil nil))

;; Reversing a list twice gives the original
(report "reverse-involution"
  (check-property
    (fn (lst) (equal? lst (reverse (reverse lst))))
    (gen/list-of (gen/int 0 100) 20)
    shrink-list))

;; Length of append = sum of lengths
(report "append-length"
  (check-property-2
    (fn (a b) (= (+ (length a) (length b)) (length (append a b))))
    (gen/list-of (gen/int 0 50) 15)
    (gen/list-of (gen/int 0 50) 15)
    nil nil))

;; string-length after string-append
(report "string-append-length"
  (check-property-2
    (fn (a b) (= (+ (string-length a) (string-length b))
                 (string-length (string-append a b))))
    (gen/string-of 20) (gen/string-of 20)
    nil nil))

;; Sort is idempotent
(report "sort-idempotent"
  (check-property
    (fn (lst) (equal? (sort lst) (sort (sort lst))))
    (gen/list-of (gen/int -100 100) 20)
    shrink-list))

;; map preserves length
(report "map-preserves-length"
  (check-property
    (fn (lst) (= (length lst) (length (map (fn (x) (* x 2)) lst))))
    (gen/list-of (gen/int 0 100) 20)
    shrink-list))

;; filter result is subset (length <= original)
(report "filter-subset"
  (check-property
    (fn (lst) (<= (length (filter even? lst)) (length lst)))
    (gen/list-of (gen/int 0 100) 20)
    shrink-list))

;; abs is always non-negative
(report "abs-non-negative"
  (check-property
    (fn (n) (>= (abs n) 0))
    (gen/int -10000 10000)
    shrink-int))

;; --- Properties that should FAIL (demonstrating shrinking) ---

(println "\n--- Properties that should fail (testing shrinking) ---")

;; "All numbers are less than 50" — will find counterexample ≥ 50
(report "all-less-than-50"
  (check-property
    (fn (n) (< n 50))
    (gen/int 0 100)
    shrink-int))

;; "All lists have length < 5" — will find a list of length ≥ 5
(report "all-lists-short"
  (check-property
    (fn (lst) (< (length lst) 5))
    (gen/list-of (gen/int 0 10) 10)
    shrink-list))

;; "Sorting never changes a list" — fails for any unsorted list
(report "sort-is-identity"
  (check-property
    (fn (lst) (equal? lst (sort lst)))
    (gen/list-of (gen/int 0 100) 10)
    shrink-list))

;; --- Custom generator example ---

(println "\n--- Custom generators ---")

;; Generate points and check triangle inequality
(define (gen/point)
  (gen/pair (gen/int -100 100) (gen/int -100 100)))

(define (distance p1 p2)
  (let ((dx (- (car p1) (car p2)))
        (dy (- (cadr p1) (cadr p2))))
    (sqrt (+ (* dx dx) (* dy dy)))))

(report "triangle-inequality"
  (let ((gen-p (gen/point)))
    (check-property
      (fn (points)
        (let ((p1 (nth points 0))
              (p2 (nth points 1))
              (p3 (nth points 2)))
          (<= (distance p1 p3)
              (+ (distance p1 p2) (distance p2 p3)))))
      (fn () (list ((gen/point)) ((gen/point)) ((gen/point))))
      nil)))

(println "\nDone!")
