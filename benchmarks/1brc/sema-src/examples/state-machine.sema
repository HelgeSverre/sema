;; state-machine.sema â€” Finite state machines using maps

(println "=== Finite State Machines ===\n")

;; --- Traffic Light FSM ---
(println "--- Traffic Light ---\n")

(define traffic-fsm
  (hash-map
    "red"    (hash-map "next" "green"  "duration" 5)
    "green"  (hash-map "next" "yellow" "duration" 4)
    "yellow" (hash-map "next" "red"    "duration" 1)))

(define traffic-labels
  (hash-map "red" "ðŸ”´ RED" "green" "ðŸŸ¢ GREEN" "yellow" "ðŸŸ¡ YELLOW"))

(defun traffic-step (state)
  (let ((info (get traffic-fsm state)))
    (get info "next")))

(defun run-traffic (state steps)
  (when (> steps 0)
    (let ((info (get traffic-fsm state))
          (label (get traffic-labels state)))
      (println (format "  ~a  (duration: ~as)" label (get info "duration")))
      (run-traffic (traffic-step state) (- steps 1)))))

(println "Traffic light running for 9 transitions:")
(run-traffic "red" 9)

;; --- Vending Machine FSM ---
(println "\n--- Vending Machine ---\n")

(define vending-fsm
  (hash-map
    "idle"       (hash-map "coin"     "selecting"
                           "on-enter" "Waiting for coins...")
    "selecting"  (hash-map "select"   "dispensing"
                           "cancel"   "idle"
                           "on-enter" "Choose your item!")
    "dispensing" (hash-map "done"     "idle"
                           "on-enter" "Dispensing your item...")))

(defun vending-transition (state event)
  (let ((state-map (get vending-fsm state)))
    (let ((next (get state-map event)))
      (if (null? next)
        (begin
          (println (format "  âš  No transition for '~a' in state '~a'" event state))
          state)
        (begin
          (let ((enter-msg (get (get vending-fsm next) "on-enter")))
            (println (format "  ~a --[~a]--> ~a: ~a" state event next enter-msg)))
          next)))))

(defun run-vending (state events)
  (if (null? events)
    (println (format "  Final state: ~a" state))
    (let ((next (vending-transition state (car events))))
      (run-vending next (cdr events)))))

(println "Scenario 1: Buy an item")
(let ((enter-msg (get (get vending-fsm "idle") "on-enter")))
  (println (format "  [start] idle: ~a" enter-msg)))
(run-vending "idle" '("coin" "select" "done"))

(println "\nScenario 2: Cancel after inserting coin")
(println "  [start] idle")
(run-vending "idle" '("coin" "cancel"))

(println "\nScenario 3: Invalid event")
(println "  [start] idle")
(run-vending "idle" '("select"))

;; --- Generic FSM runner ---
(println "\n--- Generic FSM: Door ---\n")

(define door-fsm
  (hash-map
    "locked"   (hash-map "unlock" "closed")
    "closed"   (hash-map "open"   "open"
                         "lock"   "locked")
    "open"     (hash-map "close"  "closed")))

(defun fsm-run (fsm state events)
  (if (null? events)
    state
    (let* ((event (car events))
           (transitions (get fsm state))
           (next (get transitions event)))
      (if (null? next)
        (begin
          (println (format "  âœ— Invalid: ~a --[~a]--> ???" state event))
          state)
        (begin
          (println (format "  ~a --[~a]--> ~a" state event next))
          (fsm-run fsm next (cdr events)))))))

(define door-events '("unlock" "open" "close" "lock" "unlock" "open"))
(println (format "Events: ~a" door-events))
(define final (fsm-run door-fsm "locked" door-events))
(println (format "Final state: ~a" final))

(println "\n=== Done ===")
