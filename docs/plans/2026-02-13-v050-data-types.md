# v0.5.0 — Data Types Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add character comparison predicates, `define-record-type`, and bytevectors to complete Sema's data type story.

**Status:** Implemented

**Architecture:** Three independent features: (1) char comparison builtins in stdlib, (2) a new `Value::Record` variant + `define-record-type` special form, (3) a new `Value::Bytevector` variant with reader syntax `#u8(...)` and stdlib module. Features 2 and 3 both touch `value.rs` so should be done sequentially.

**Tech Stack:** Rust 2021, sema-core/sema-reader/sema-eval/sema-stdlib crates. No new dependencies.

---

## Task 1: Character Comparison Predicates

Adds R7RS `char=?`, `char<?`, `char>?`, `char<=?`, `char>=?` and case-insensitive variants `char-ci=?`, `char-ci<?`, `char-ci>?`, `char-ci<=?`, `char-ci>=?`.

**Files:**
- Modify: `crates/sema-stdlib/src/string.rs` (add after existing char functions, before closing `}`)
- Test: `crates/sema/tests/integration_test.rs`

**Step 1: Write failing tests**

Add to `crates/sema/tests/integration_test.rs`:

```rust
#[test]
fn test_char_comparison_predicates() {
    assert_eq!(eval("(char=? #\\a #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char=? #\\a #\\b)"), Value::Bool(false));
    assert_eq!(eval("(char<? #\\a #\\b)"), Value::Bool(true));
    assert_eq!(eval("(char<? #\\b #\\a)"), Value::Bool(false));
    assert_eq!(eval("(char>? #\\b #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char>? #\\a #\\b)"), Value::Bool(false));
    assert_eq!(eval("(char<=? #\\a #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char<=? #\\a #\\b)"), Value::Bool(true));
    assert_eq!(eval("(char<=? #\\b #\\a)"), Value::Bool(false));
    assert_eq!(eval("(char>=? #\\b #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char>=? #\\a #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char>=? #\\a #\\b)"), Value::Bool(false));
}

#[test]
fn test_char_ci_comparison_predicates() {
    assert_eq!(eval("(char-ci=? #\\A #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char-ci=? #\\a #\\A)"), Value::Bool(true));
    assert_eq!(eval("(char-ci=? #\\a #\\b)"), Value::Bool(false));
    assert_eq!(eval("(char-ci<? #\\A #\\b)"), Value::Bool(true));
    assert_eq!(eval("(char-ci<? #\\a #\\B)"), Value::Bool(true));
    assert_eq!(eval("(char-ci>? #\\b #\\A)"), Value::Bool(true));
    assert_eq!(eval("(char-ci<=? #\\A #\\a)"), Value::Bool(true));
    assert_eq!(eval("(char-ci>=? #\\a #\\A)"), Value::Bool(true));
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p sema --test integration_test -- test_char_comparison`
Expected: FAIL — functions not defined

**Step 3: Implement char comparison builtins**

Add to `crates/sema-stdlib/src/string.rs`, just before the closing `}` of `register()`:

```rust
    // Character comparison predicates (R7RS)

    fn two_chars(op: &str, args: &[Value]) -> Result<(char, char), SemaError> {
        if args.len() != 2 {
            return Err(SemaError::arity(op, "2", args.len()));
        }
        let a = args[0]
            .as_char()
            .ok_or_else(|| SemaError::type_error("char", args[0].type_name()))?;
        let b = args[1]
            .as_char()
            .ok_or_else(|| SemaError::type_error("char", args[1].type_name()))?;
        Ok((a, b))
    }

    register_fn(env, "char=?", |args| {
        let (a, b) = two_chars("char=?", args)?;
        Ok(Value::Bool(a == b))
    });

    register_fn(env, "char<?", |args| {
        let (a, b) = two_chars("char<?", args)?;
        Ok(Value::Bool(a < b))
    });

    register_fn(env, "char>?", |args| {
        let (a, b) = two_chars("char>?", args)?;
        Ok(Value::Bool(a > b))
    });

    register_fn(env, "char<=?", |args| {
        let (a, b) = two_chars("char<=?", args)?;
        Ok(Value::Bool(a <= b))
    });

    register_fn(env, "char>=?", |args| {
        let (a, b) = two_chars("char>=?", args)?;
        Ok(Value::Bool(a >= b))
    });

    // Case-insensitive character comparison (R7RS)

    fn two_chars_ci(op: &str, args: &[Value]) -> Result<(char, char), SemaError> {
        let (a, b) = two_chars(op, args)?;
        Ok((
            a.to_lowercase().next().unwrap_or(a),
            b.to_lowercase().next().unwrap_or(b),
        ))
    }

    register_fn(env, "char-ci=?", |args| {
        let (a, b) = two_chars_ci("char-ci=?", args)?;
        Ok(Value::Bool(a == b))
    });

    register_fn(env, "char-ci<?", |args| {
        let (a, b) = two_chars_ci("char-ci<?", args)?;
        Ok(Value::Bool(a < b))
    });

    register_fn(env, "char-ci>?", |args| {
        let (a, b) = two_chars_ci("char-ci>?", args)?;
        Ok(Value::Bool(a > b))
    });

    register_fn(env, "char-ci<=?", |args| {
        let (a, b) = two_chars_ci("char-ci<=?", args)?;
        Ok(Value::Bool(a <= b))
    });

    register_fn(env, "char-ci>=?", |args| {
        let (a, b) = two_chars_ci("char-ci>=?", args)?;
        Ok(Value::Bool(a >= b))
    });
```

Note: `two_chars` and `two_chars_ci` are defined as inner functions inside `register()`, which is valid Rust and matches the existing pattern (functions defined inside the registration scope).

**Step 4: Run tests to verify they pass**

Run: `cargo test -p sema --test integration_test -- test_char_comparison`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/sema-stdlib/src/string.rs crates/sema/tests/integration_test.rs
git commit -m "feat: add R7RS char comparison predicates (char=?, char<?, char-ci=?, etc.)"
```

---

## Task 2: `Value::Record` in sema-core

Adds the `Record` struct and `Value::Record` variant, with all trait implementations.

**Files:**
- Modify: `crates/sema-core/src/value.rs`
- Test: `crates/sema/tests/integration_test.rs` (deferred to Task 4)

**Step 1: Add Record struct and Value variant**

In `crates/sema-core/src/value.rs`, add the Record struct after the Thunk definition (before the `Value` enum):

```rust
/// A record: tagged product type created by define-record-type.
#[derive(Debug, Clone)]
pub struct Record {
    pub type_tag: Spur,
    pub fields: Vec<Value>,
}
```

Add to the `Value` enum, after `Thunk`:

```rust
    Record(Rc<Record>),
```

**Step 2: Update type_name()**

Add match arm in `type_name()`:

```rust
Value::Record(_) => "record",
```

**Step 3: Update PartialEq**

Add match arm:

```rust
(Value::Record(a), Value::Record(b)) => a.type_tag == b.type_tag && a.fields == b.fields,
```

**Step 4: Update Ord**

In `type_order()`, add `Value::Record(_) => 13` (after the existing `_ => 12` bucket — bump the catch-all to 14 or use the slot between HashMap and the catch-all).

Actually, looking at the existing code, `Record` should go at position 12 and the catch-all `_ => 12` becomes `_ => 13`:

```rust
Value::Record(_) => 12,
// _ => 12 becomes:
_ => 13,
```

Add match arm in the `Ord` implementation body:

```rust
(Value::Record(a), Value::Record(b)) => {
    compare_spurs(a.type_tag, b.type_tag)
        .then_with(|| a.fields.cmp(&b.fields))
}
```

**Step 5: Update Hash**

Add match arm in `Hash`:

```rust
Value::Record(r) => {
    r.type_tag.hash(state);
    r.fields.hash(state);
}
```

**Step 6: Update Display**

Add match arm in `Display`:

```rust
Value::Record(r) => {
    let tag = resolve(r.type_tag);
    write!(f, "#<record {tag}")?;
    for field in &r.fields {
        write!(f, " {field}")?;
    }
    write!(f, ">")
}
```

**Step 7: Add helper method**

Add to the `impl Value` block:

```rust
pub fn as_record(&self) -> Option<&Rc<Record>> {
    match self {
        Value::Record(r) => Some(r),
        _ => None,
    }
}
```

**Step 8: Verify it compiles**

Run: `cargo build`
Expected: compiles (no tests yet)

**Step 9: Commit**

```bash
git add crates/sema-core/src/value.rs
git commit -m "feat(core): add Value::Record variant for define-record-type"
```

---

## Task 3: `record?` predicate and `type` update

**Files:**
- Modify: `crates/sema-stdlib/src/predicates.rs`

**Step 1: Add `record?` predicate**

Add before the closing `}` of `register()`:

```rust
    register_fn(env, "record?", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("record?", "1", args.len()));
        }
        Ok(Value::Bool(matches!(&args[0], Value::Record(_))))
    });
```

**Step 2: Update `type` builtin to return record type name**

Change the existing `type` registration from:

```rust
    register_fn(env, "type", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("type", "1", args.len()));
        }
        Ok(Value::keyword(args[0].type_name()))
    });
```

To:

```rust
    register_fn(env, "type", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("type", "1", args.len()));
        }
        match &args[0] {
            Value::Record(r) => Ok(Value::Keyword(r.type_tag)),
            other => Ok(Value::keyword(other.type_name())),
        }
    });
```

This requires adding `use sema_core::Record;` — but actually `Value::Record(r)` pattern matching already gives access to `r` which is `Rc<Record>`. The existing import of `Value` suffices since Record is accessed via the enum variant.

**Step 3: Verify it compiles**

Run: `cargo build`
Expected: compiles

**Step 4: Commit**

```bash
git add crates/sema-stdlib/src/predicates.rs
git commit -m "feat(stdlib): add record? predicate, type returns record tag"
```

---

## Task 4: `define-record-type` special form

**Files:**
- Modify: `crates/sema-eval/src/special_forms.rs`
- Test: `crates/sema/tests/integration_test.rs`

**Step 1: Write failing tests**

Add to `crates/sema/tests/integration_test.rs`:

```rust
#[test]
fn test_define_record_type_basic() {
    let interp = Interpreter::new();
    // Define and use a record type
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x)
            (y point-y))
        (define p (make-point 3 4))
        (list (point? p) (point-x p) (point-y p))
    ").unwrap();
    assert_eq!(
        result,
        Value::list(vec![Value::Bool(true), Value::Int(3), Value::Int(4)])
    );
}

#[test]
fn test_define_record_type_predicate_false() {
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x)
            (y point-y))
        (point? 42)
    ").unwrap();
    assert_eq!(result, Value::Bool(false));
}

#[test]
fn test_define_record_type_equality() {
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x)
            (y point-y))
        (equal? (make-point 1 2) (make-point 1 2))
    ").unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_define_record_type_type_function() {
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x)
            (y point-y))
        (type (make-point 1 2))
    ").unwrap();
    assert_eq!(result, Value::keyword("point"));
}

#[test]
fn test_define_record_type_record_predicate() {
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x)
            (y point-y))
        (list (record? (make-point 1 2)) (record? 42))
    ").unwrap();
    assert_eq!(
        result,
        Value::list(vec![Value::Bool(true), Value::Bool(false)])
    );
}

#[test]
fn test_define_record_type_mutator_ignored() {
    // Mutator in field spec is accepted but not registered
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point
            (make-point x y)
            point?
            (x point-x set-point-x!)
            (y point-y set-point-y!))
        (point-x (make-point 7 8))
    ").unwrap();
    assert_eq!(result, Value::Int(7));
}

#[test]
fn test_define_record_type_multiple_types() {
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define-record-type point (make-point x y) point? (x point-x) (y point-y))
        (define-record-type color (make-color r g b) color? (r color-r) (g color-g) (b color-b))
        (list (point? (make-point 1 2)) (color? (make-point 1 2))
              (color? (make-color 255 0 0)) (point? (make-color 255 0 0)))
    ").unwrap();
    assert_eq!(
        result,
        Value::list(vec![
            Value::Bool(true), Value::Bool(false),
            Value::Bool(true), Value::Bool(false),
        ])
    );
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p sema --test integration_test -- test_define_record_type`
Expected: FAIL

**Step 3: Implement `define-record-type` special form**

In `crates/sema-eval/src/special_forms.rs`:

Add to imports at top:

```rust
use sema_core::Record;
```

Add match arm in `try_eval_special()`:

```rust
"define-record-type" => Some(eval_define_record_type(args, env)),
```

Add the implementation function:

```rust
fn eval_define_record_type(args: &[Value], env: &Env) -> Result<Trampoline, SemaError> {
    // (define-record-type <name> (<ctor> <field> ...) <pred> (<field> <accessor> [<mutator>]) ...)
    if args.len() < 3 {
        return Err(SemaError::eval(
            "define-record-type: requires at least type name, constructor, and predicate",
        ));
    }

    // Parse type name
    let type_name = args[0]
        .as_symbol()
        .ok_or_else(|| SemaError::eval("define-record-type: type name must be a symbol"))?;
    let type_tag = intern(&type_name);

    // Parse constructor spec: (<ctor-name> <field-name> ...)
    let ctor_spec = args[1]
        .as_list()
        .ok_or_else(|| SemaError::eval("define-record-type: constructor spec must be a list"))?;
    if ctor_spec.is_empty() {
        return Err(SemaError::eval(
            "define-record-type: constructor spec must have a name",
        ));
    }
    let ctor_name = ctor_spec[0]
        .as_symbol()
        .ok_or_else(|| SemaError::eval("define-record-type: constructor name must be a symbol"))?;
    let field_names: Vec<String> = ctor_spec[1..]
        .iter()
        .map(|v| {
            v.as_symbol()
                .ok_or_else(|| SemaError::eval("define-record-type: field name must be a symbol"))
        })
        .collect::<Result<_, _>>()?;
    let field_count = field_names.len();

    // Parse predicate name
    let pred_name = args[2]
        .as_symbol()
        .ok_or_else(|| SemaError::eval("define-record-type: predicate must be a symbol"))?;

    // Register constructor
    let ctor_name_clone = ctor_name.clone();
    env.set_str(
        &ctor_name,
        Value::NativeFn(Rc::new(sema_core::NativeFn {
            name: ctor_name.clone(),
            func: Box::new(move |args: &[Value]| {
                if args.len() != field_count {
                    return Err(SemaError::arity(
                        &ctor_name_clone,
                        &field_count.to_string(),
                        args.len(),
                    ));
                }
                Ok(Value::Record(Rc::new(Record {
                    type_tag,
                    fields: args.to_vec(),
                })))
            }),
        })),
    );

    // Register predicate
    let pred_name_for_err = pred_name.clone();
    env.set_str(
        &pred_name,
        Value::NativeFn(Rc::new(sema_core::NativeFn {
            name: pred_name,
            func: Box::new(move |args: &[Value]| {
                if args.len() != 1 {
                    return Err(SemaError::arity(&pred_name_for_err, "1", args.len()));
                }
                Ok(Value::Bool(matches!(&args[0], Value::Record(r) if r.type_tag == type_tag)))
            }),
        })),
    );

    // Parse field specs and register accessors
    for field_spec_val in &args[3..] {
        let field_spec = field_spec_val
            .as_list()
            .ok_or_else(|| SemaError::eval("define-record-type: field spec must be a list"))?;
        if field_spec.len() < 2 {
            return Err(SemaError::eval(
                "define-record-type: field spec must have at least (field-name accessor)",
            ));
        }

        let field_name = field_spec[0]
            .as_symbol()
            .ok_or_else(|| SemaError::eval("define-record-type: field name must be a symbol"))?;

        // Find field index
        let field_idx = field_names
            .iter()
            .position(|n| n == &field_name)
            .ok_or_else(|| {
                SemaError::eval(format!(
                    "define-record-type: field '{field_name}' not in constructor"
                ))
            })?;

        let accessor_name = field_spec[1]
            .as_symbol()
            .ok_or_else(|| SemaError::eval("define-record-type: accessor must be a symbol"))?;

        // Register accessor
        let accessor_name_clone = accessor_name.clone();
        let type_name_for_err = type_name.clone();
        env.set_str(
            &accessor_name,
            Value::NativeFn(Rc::new(sema_core::NativeFn {
                name: accessor_name,
                func: Box::new(move |args: &[Value]| {
                    if args.len() != 1 {
                        return Err(SemaError::arity(&accessor_name_clone, "1", args.len()));
                    }
                    match &args[0] {
                        Value::Record(r) if r.type_tag == type_tag => {
                            Ok(r.fields[field_idx].clone())
                        }
                        _ => Err(SemaError::type_error(
                            &type_name_for_err,
                            args[0].type_name(),
                        )),
                    }
                }),
            })),
        );

        // Mutator (field_spec[2]) is intentionally ignored — Sema values are immutable
    }

    Ok(Trampoline::Value(Value::Nil))
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p sema --test integration_test -- test_define_record_type`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/sema-eval/src/special_forms.rs crates/sema/tests/integration_test.rs
git commit -m "feat: add define-record-type special form (R7RS)"
```

---

## Task 5: `Value::Bytevector` in sema-core

Adds the `Value::Bytevector` variant with all trait implementations.

**Files:**
- Modify: `crates/sema-core/src/value.rs`

**Step 1: Add Value variant**

Add to the `Value` enum, after `Record`:

```rust
    Bytevector(Rc<Vec<u8>>),
```

**Step 2: Update type_name()**

Add match arm:

```rust
Value::Bytevector(_) => "bytevector",
```

**Step 3: Update PartialEq**

Add match arm:

```rust
(Value::Bytevector(a), Value::Bytevector(b)) => a == b,
```

**Step 4: Update Ord**

In `type_order()`, add `Value::Bytevector(_) => 13` (after Record at 12). Bump the catch-all `_ =>` to 14.

Add match arm:

```rust
(Value::Bytevector(a), Value::Bytevector(b)) => a.cmp(b),
```

**Step 5: Update Hash**

Add match arm:

```rust
Value::Bytevector(bv) => bv.hash(state),
```

**Step 6: Update Display**

Add match arm:

```rust
Value::Bytevector(bv) => {
    write!(f, "#u8(")?;
    for (i, byte) in bv.iter().enumerate() {
        if i > 0 {
            write!(f, " ")?;
        }
        write!(f, "{byte}")?;
    }
    write!(f, ")")
}
```

**Step 7: Add helper methods**

Add to `impl Value`:

```rust
pub fn as_bytevector(&self) -> Option<&Rc<Vec<u8>>> {
    match self {
        Value::Bytevector(bv) => Some(bv),
        _ => None,
    }
}

pub fn bytevector(bytes: Vec<u8>) -> Value {
    Value::Bytevector(Rc::new(bytes))
}
```

**Step 8: Verify it compiles**

Run: `cargo build`
Expected: compiles

**Step 9: Commit**

```bash
git add crates/sema-core/src/value.rs
git commit -m "feat(core): add Value::Bytevector variant"
```

---

## Task 6: Bytevector reader syntax `#u8(...)`

**Files:**
- Modify: `crates/sema-reader/src/lexer.rs` (add `BytevectorStart` token)
- Modify: `crates/sema-reader/src/reader.rs` (parse bytevector)
- Test: reader unit tests in `crates/sema-reader/src/reader.rs`

**Step 1: Write failing reader tests**

Add to the `#[cfg(test)] mod tests` block in `crates/sema-reader/src/reader.rs`:

```rust
    #[test]
    fn test_read_bytevector_literal() {
        assert_eq!(
            read("#u8(1 2 3)").unwrap(),
            Value::bytevector(vec![1, 2, 3])
        );
    }

    #[test]
    fn test_read_bytevector_empty() {
        assert_eq!(read("#u8()").unwrap(), Value::bytevector(vec![]));
    }

    #[test]
    fn test_read_bytevector_single() {
        assert_eq!(read("#u8(255)").unwrap(), Value::bytevector(vec![255]));
    }

    #[test]
    fn test_read_bytevector_out_of_range() {
        assert!(read("#u8(256)").is_err());
    }

    #[test]
    fn test_read_bytevector_negative() {
        assert!(read("#u8(-1)").is_err());
    }

    #[test]
    fn test_read_bytevector_non_integer() {
        assert!(read("#u8(1.5)").is_err());
    }

    #[test]
    fn test_read_bytevector_unterminated() {
        assert!(read("#u8(1 2").is_err());
    }

    #[test]
    fn test_read_bytevector_in_list() {
        let result = read("(#u8(1 2) #u8(3))").unwrap();
        assert_eq!(
            result,
            Value::list(vec![
                Value::bytevector(vec![1, 2]),
                Value::bytevector(vec![3]),
            ])
        );
    }
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p sema-reader -- test_read_bytevector`
Expected: FAIL

**Step 3: Add BytevectorStart token**

In `crates/sema-reader/src/lexer.rs`, add to the `Token` enum:

```rust
    BytevectorStart,  // #u8(
```

**Step 4: Add lexer handling for `#u8(`**

In the `'#'` match arm in `tokenize()`, add a new case **before** the `_ =>` fallthrough (i.e., after the `'\\' =>` case):

```rust
                        'u' if i + 3 < chars.len() && chars[i + 2] == '8' && chars[i + 3] == '(' => {
                            tokens.push(SpannedToken {
                                token: Token::BytevectorStart,
                                span,
                            });
                            i += 4; // skip #u8(
                            col += 4;
                        }
```

**Step 5: Add parser handling for BytevectorStart**

In `crates/sema-reader/src/reader.rs`, add a match arm in `parse_expr()` before the `Some(_) => self.parse_atom()` fallthrough:

```rust
            Some(Token::BytevectorStart) => self.parse_bytevector(),
```

Add the `parse_bytevector` method to `Parser`:

```rust
    fn parse_bytevector(&mut self) -> Result<Value, SemaError> {
        let open_span = self.span();
        self.advance(); // consume BytevectorStart token
        let mut bytes = Vec::new();
        while self.peek() != Some(&Token::RParen) {
            if self.peek().is_none() {
                return Err(SemaError::Reader {
                    message: "unterminated bytevector".to_string(),
                    span: open_span,
                });
            }
            let span = self.span();
            match self.peek() {
                Some(Token::Int(n)) => {
                    let n = *n;
                    self.advance();
                    if n < 0 || n > 255 {
                        return Err(SemaError::Reader {
                            message: format!("#u8(...): byte value {n} out of range 0..255"),
                            span,
                        });
                    }
                    bytes.push(n as u8);
                }
                _ => {
                    return Err(SemaError::Reader {
                        message: "#u8(...): expected integer byte value".to_string(),
                        span,
                    });
                }
            }
        }
        self.expect(&Token::RParen)?;
        Ok(Value::bytevector(bytes))
    }
```

**Step 6: Run tests to verify they pass**

Run: `cargo test -p sema-reader -- test_read_bytevector`
Expected: PASS

**Step 7: Commit**

```bash
git add crates/sema-reader/src/lexer.rs crates/sema-reader/src/reader.rs
git commit -m "feat(reader): add #u8(...) bytevector literal syntax"
```

---

## Task 7: Bytevector stdlib module

**Files:**
- Create: `crates/sema-stdlib/src/bytevector.rs`
- Modify: `crates/sema-stdlib/src/lib.rs` (register module)
- Modify: `crates/sema-stdlib/src/predicates.rs` (add `bytevector?`)
- Test: `crates/sema/tests/integration_test.rs`

**Step 1: Write failing tests**

Add to `crates/sema/tests/integration_test.rs`:

```rust
#[test]
fn test_bytevector_constructors() {
    assert_eq!(
        eval("(bytevector 1 2 3)"),
        Value::bytevector(vec![1, 2, 3])
    );
    assert_eq!(
        eval("(make-bytevector 3 7)"),
        Value::bytevector(vec![7, 7, 7])
    );
    assert_eq!(
        eval("(make-bytevector 4)"),
        Value::bytevector(vec![0, 0, 0, 0])
    );
}

#[test]
fn test_bytevector_length() {
    assert_eq!(eval("(bytevector-length #u8(1 2 3))"), Value::Int(3));
    assert_eq!(eval("(bytevector-length #u8())"), Value::Int(0));
}

#[test]
fn test_bytevector_u8_ref() {
    assert_eq!(eval("(bytevector-u8-ref #u8(10 20 30) 0)"), Value::Int(10));
    assert_eq!(eval("(bytevector-u8-ref #u8(10 20 30) 2)"), Value::Int(30));
}

#[test]
fn test_bytevector_u8_set() {
    // COW: original unchanged, returns new bytevector
    let interp = Interpreter::new();
    let result = interp.eval_str("
        (define a #u8(1 2 3))
        (define b (bytevector-u8-set! a 0 9))
        (list a b)
    ").unwrap();
    assert_eq!(
        result,
        Value::list(vec![
            Value::bytevector(vec![1, 2, 3]),
            Value::bytevector(vec![9, 2, 3]),
        ])
    );
}

#[test]
fn test_bytevector_copy() {
    assert_eq!(
        eval("(bytevector-copy #u8(1 2 3 4 5) 1 3)"),
        Value::bytevector(vec![2, 3])
    );
    assert_eq!(
        eval("(bytevector-copy #u8(1 2 3))"),
        Value::bytevector(vec![1, 2, 3])
    );
}

#[test]
fn test_bytevector_append() {
    assert_eq!(
        eval("(bytevector-append #u8(1 2) #u8(3 4))"),
        Value::bytevector(vec![1, 2, 3, 4])
    );
    assert_eq!(
        eval("(bytevector-append #u8(1) #u8(2) #u8(3))"),
        Value::bytevector(vec![1, 2, 3])
    );
}

#[test]
fn test_bytevector_list_conversion() {
    assert_eq!(
        eval("(bytevector->list #u8(65 66 67))"),
        Value::list(vec![Value::Int(65), Value::Int(66), Value::Int(67)])
    );
    assert_eq!(
        eval("(list->bytevector (list 1 2 3))"),
        Value::bytevector(vec![1, 2, 3])
    );
}

#[test]
fn test_bytevector_utf8_conversion() {
    assert_eq!(
        eval_to_string("(utf8->string #u8(104 105))"),
        "\"hi\""
    );
    assert_eq!(
        eval("(string->utf8 \"hi\")"),
        Value::bytevector(vec![104, 105])
    );
}

#[test]
fn test_bytevector_predicate() {
    assert_eq!(eval("(bytevector? #u8(1 2))"), Value::Bool(true));
    assert_eq!(eval("(bytevector? 42)"), Value::Bool(false));
    assert_eq!(eval("(bytevector? (list 1 2))"), Value::Bool(false));
}

#[test]
fn test_bytevector_display() {
    assert_eq!(eval_to_string("#u8(1 2 3)"), "#u8(1 2 3)");
    assert_eq!(eval_to_string("#u8()"), "#u8()");
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p sema --test integration_test -- test_bytevector`
Expected: FAIL

**Step 3: Add `bytevector?` predicate**

In `crates/sema-stdlib/src/predicates.rs`, add before the closing `}`:

```rust
    register_fn(env, "bytevector?", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("bytevector?", "1", args.len()));
        }
        Ok(Value::Bool(matches!(&args[0], Value::Bytevector(_))))
    });
```

**Step 4: Create bytevector.rs module**

Create `crates/sema-stdlib/src/bytevector.rs`:

```rust
use std::rc::Rc;

use sema_core::{SemaError, Value};

use crate::register_fn;

pub fn register(env: &sema_core::Env) {
    register_fn(env, "make-bytevector", |args| {
        if args.is_empty() || args.len() > 2 {
            return Err(SemaError::arity("make-bytevector", "1-2", args.len()));
        }
        let size = args[0]
            .as_int()
            .ok_or_else(|| SemaError::type_error("int", args[0].type_name()))?;
        if size < 0 {
            return Err(SemaError::eval("make-bytevector: size must be non-negative"));
        }
        let fill = if args.len() == 2 {
            let n = args[1]
                .as_int()
                .ok_or_else(|| SemaError::type_error("int", args[1].type_name()))?;
            if n < 0 || n > 255 {
                return Err(SemaError::eval("make-bytevector: fill must be 0..255"));
            }
            n as u8
        } else {
            0
        };
        Ok(Value::bytevector(vec![fill; size as usize]))
    });

    register_fn(env, "bytevector", |args| {
        let mut bytes = Vec::with_capacity(args.len());
        for (i, arg) in args.iter().enumerate() {
            let n = arg
                .as_int()
                .ok_or_else(|| SemaError::type_error("int", args[i].type_name()))?;
            if n < 0 || n > 255 {
                return Err(SemaError::eval(format!(
                    "bytevector: byte value {n} out of range 0..255"
                )));
            }
            bytes.push(n as u8);
        }
        Ok(Value::bytevector(bytes))
    });

    register_fn(env, "bytevector-length", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("bytevector-length", "1", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        Ok(Value::Int(bv.len() as i64))
    });

    register_fn(env, "bytevector-u8-ref", |args| {
        if args.len() != 2 {
            return Err(SemaError::arity("bytevector-u8-ref", "2", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        let idx = args[1]
            .as_int()
            .ok_or_else(|| SemaError::type_error("int", args[1].type_name()))? as usize;
        bv.get(idx)
            .map(|&b| Value::Int(b as i64))
            .ok_or_else(|| {
                SemaError::eval(format!("bytevector-u8-ref: index {idx} out of bounds"))
            })
    });

    register_fn(env, "bytevector-u8-set!", |args| {
        if args.len() != 3 {
            return Err(SemaError::arity("bytevector-u8-set!", "3", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        let idx = args[1]
            .as_int()
            .ok_or_else(|| SemaError::type_error("int", args[1].type_name()))? as usize;
        let byte = args[2]
            .as_int()
            .ok_or_else(|| SemaError::type_error("int", args[2].type_name()))?;
        if byte < 0 || byte > 255 {
            return Err(SemaError::eval("bytevector-u8-set!: byte must be 0..255"));
        }
        if idx >= bv.len() {
            return Err(SemaError::eval(format!(
                "bytevector-u8-set!: index {idx} out of bounds"
            )));
        }
        // COW: clone the vec, mutate, return new bytevector
        let mut new_bv = (**bv).clone();
        new_bv[idx] = byte as u8;
        Ok(Value::bytevector(new_bv))
    });

    register_fn(env, "bytevector-copy", |args| {
        if args.is_empty() || args.len() > 3 {
            return Err(SemaError::arity("bytevector-copy", "1-3", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        let start = if args.len() >= 2 {
            args[1]
                .as_int()
                .ok_or_else(|| SemaError::type_error("int", args[1].type_name()))?
                as usize
        } else {
            0
        };
        let end = if args.len() == 3 {
            args[2]
                .as_int()
                .ok_or_else(|| SemaError::type_error("int", args[2].type_name()))?
                as usize
        } else {
            bv.len()
        };
        if start > end || end > bv.len() {
            return Err(SemaError::eval(format!(
                "bytevector-copy: invalid range {start}..{end} for length {}",
                bv.len()
            )));
        }
        Ok(Value::bytevector(bv[start..end].to_vec()))
    });

    register_fn(env, "bytevector-append", |args| {
        let mut result = Vec::new();
        for arg in args {
            let bv = arg
                .as_bytevector()
                .ok_or_else(|| SemaError::type_error("bytevector", arg.type_name()))?;
            result.extend_from_slice(bv);
        }
        Ok(Value::bytevector(result))
    });

    register_fn(env, "bytevector->list", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("bytevector->list", "1", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        let items: Vec<Value> = bv.iter().map(|&b| Value::Int(b as i64)).collect();
        Ok(Value::list(items))
    });

    register_fn(env, "list->bytevector", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("list->bytevector", "1", args.len()));
        }
        let items = args[0]
            .as_list()
            .ok_or_else(|| SemaError::type_error("list", args[0].type_name()))?;
        let mut bytes = Vec::with_capacity(items.len());
        for item in items {
            let n = item
                .as_int()
                .ok_or_else(|| SemaError::type_error("int", item.type_name()))?;
            if n < 0 || n > 255 {
                return Err(SemaError::eval(format!(
                    "list->bytevector: value {n} out of range 0..255"
                )));
            }
            bytes.push(n as u8);
        }
        Ok(Value::bytevector(bytes))
    });

    register_fn(env, "utf8->string", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("utf8->string", "1", args.len()));
        }
        let bv = args[0]
            .as_bytevector()
            .ok_or_else(|| SemaError::type_error("bytevector", args[0].type_name()))?;
        let s = String::from_utf8((**bv).clone())
            .map_err(|e| SemaError::eval(format!("utf8->string: invalid UTF-8: {e}")))?;
        Ok(Value::String(Rc::new(s)))
    });

    register_fn(env, "string->utf8", |args| {
        if args.len() != 1 {
            return Err(SemaError::arity("string->utf8", "1", args.len()));
        }
        let s = args[0]
            .as_str()
            .ok_or_else(|| SemaError::type_error("string", args[0].type_name()))?;
        Ok(Value::bytevector(s.as_bytes().to_vec()))
    });
}
```

**Step 5: Register module in lib.rs**

In `crates/sema-stdlib/src/lib.rs`, add `mod bytevector;` to the module declarations and `bytevector::register(env);` to `register_stdlib()`.

**Step 6: Run tests to verify they pass**

Run: `cargo test -p sema --test integration_test -- test_bytevector`
Expected: PASS

**Step 7: Run full test suite**

Run: `cargo test`
Expected: all tests pass

**Step 8: Commit**

```bash
git add crates/sema-stdlib/src/bytevector.rs crates/sema-stdlib/src/lib.rs \
    crates/sema-stdlib/src/predicates.rs crates/sema/tests/integration_test.rs
git commit -m "feat: add bytevector type with #u8() syntax and stdlib"
```

---

## Task 8: Update documentation and LIMITATIONS.md

**Files:**
- Modify: `agents/LIMITATIONS.md`
- Modify: `CHANGELOG.md`

**Step 1: Update LIMITATIONS.md**

Mark resolved:
- Item #12: ~~No Struct/Record Types~~ → RESOLVED
- Item #25: ~~No `char=?`/`char<?` Comparison Predicates~~ → RESOLVED
- Item #28: ~~No Bytevectors~~ → RESOLVED

Update the status line to say `v0.5.0`.

Remove items 12, 25, 28 from the gap analysis table.

**Step 2: Update CHANGELOG.md**

Add `## 0.5.0` section at the top with:

### Added
- **Character comparison predicates** — R7RS `char=?`, `char<?`, `char>?`, `char<=?`, `char>=?` and case-insensitive `char-ci=?`, `char-ci<?`, `char-ci>?`, `char-ci<=?`, `char-ci>=?`
- **`define-record-type`** — R7RS record types with constructors, predicates, and field accessors. `record?` predicate. `type` returns record type name as keyword.
- **Bytevectors** — `Value::Bytevector` with `#u8(1 2 3)` reader syntax. `make-bytevector`, `bytevector`, `bytevector-length`, `bytevector-u8-ref`, `bytevector-u8-set!` (COW), `bytevector-copy`, `bytevector-append`, `bytevector->list`, `list->bytevector`, `utf8->string`, `string->utf8`, `bytevector?`

**Step 3: Commit**

```bash
git add agents/LIMITATIONS.md CHANGELOG.md
git commit -m "docs: update changelog and limitations for v0.5.0"
```

---

## Task Dependency Graph

```
Task 1 (char predicates)     — independent
Task 2 (Value::Record)       — independent
Task 3 (record? + type)      — depends on Task 2
Task 4 (define-record-type)  — depends on Task 2, 3
Task 5 (Value::Bytevector)   — depends on Task 2 (both touch value.rs)
Task 6 (reader #u8)          — depends on Task 5
Task 7 (bytevector stdlib)   — depends on Task 5, 6
Task 8 (docs)                — depends on all
```

Tasks 1 and 2 can run in parallel. Tasks 3+4 follow Task 2. Tasks 5+6+7 follow Task 4. Task 8 is last.
