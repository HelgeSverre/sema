# Sema â€” Full Documentation

> A Scheme-like Lisp with first-class LLM primitives, implemented in Rust.

---


# Getting Started

Sema is a Scheme-like Lisp where prompts are s-expressions, conversations are persistent data structures, and LLM calls are just another form of evaluation. It combines a Scheme core with Clojure-style keywords (`:foo`), map literals (`{:key val}`), and vector literals (`[1 2 3]`).

## Why Sema?

- **LLMs as language primitives** â€” prompts, messages, conversations, tools, and agents are first-class data types, not string templates bolted on
- **Multi-provider** â€” Anthropic, OpenAI, Gemini, Groq, xAI, Mistral, Ollama, and more, all auto-configured from environment variables
- **Practical Lisp** â€” closures, tail-call optimization, macros, modules, error handling, HTTP, file I/O, regex, JSON â€” everything you need to build real programs
- **Embeddable** â€” clean Rust crate structure, builder API, sync interface ([learn more](./embedding.md))

## Installation

Install from [crates.io](https://crates.io/crates/sema-lang):

```bash
cargo install sema-lang
```

Or install from git (latest unreleased):

```bash
cargo install --git https://github.com/HelgeSverre/sema sema-lang
```

Or build from source:

```bash
git clone https://github.com/HelgeSverre/sema
cd sema
cargo build --release
# Binary is at target/release/sema
```

## Quick Start

```bash
sema                          # Start the REPL
sema script.sema              # Run a file
sema -e '(+ 1 2)'             # Evaluate an expression
sema -p '(map sqr (range 5))' # Evaluate and always print
```

```scheme
;; In the REPL:
sema> (define (greet name) (format "Hello, ~a!" name))
sema> (greet "world")
"Hello, world!"

sema> (map (lambda (x) (* x x)) (range 1 6))
(1 4 9 16 25)

sema> (define person {:name "Ada" :age 36})
sema> (:name person)
"Ada"
```

## Examples

### Working with Data

```scheme
;; Keywords as accessor functions
(define people [{:name "Ada" :age 36}
                {:name "Bob" :age 28}
                {:name "Cat" :age 42}])

(map (fn (p) (:name p)) people)
; => ("Ada" "Bob" "Cat")

(filter (fn (p) (> (:age p) 30)) people)
; => ({:name "Ada" :age 36} {:name "Cat" :age 42})
```

### LLM Completion

```scheme
;; Simple completion (requires an API key env var)
(llm/complete "Explain recursion in one sentence" {:max-tokens 50})

;; Structured chat with message history
(llm/chat
  [(message :system "You are a helpful assistant.")
   (message :user "What is Lisp? One sentence.")]
  {:max-tokens 100})
```

### Persistent Conversations

```scheme
(define conv (conversation/new {:model "claude-haiku-4-5-20251001"}))
(define conv (conversation/say conv "Remember: the secret number is 7"))
(define conv (conversation/say conv "What is the secret number?"))
(conversation/last-reply conv)
; => "The secret number is 7."
```

## What's Next?

- [CLI Reference](./cli.md) â€” all flags, subcommands, and environment variables
- [Shell Completions](./shell-completions.md) â€” tab completions for bash, zsh, fish, and more
- [Editor Support](./editors.md) â€” plugins for VS Code, Vim/Neovim, Emacs, and Helix
- [Embedding in Rust](./embedding.md) â€” use Sema as a scripting engine in your app
- [Data Types](./language/data-types.md) â€” the 20 built-in types
- [Special Forms](./language/special-forms.md) â€” control flow, bindings, and iteration
- [Macros & Modules](./language/macros-modules.md) â€” metaprogramming and code organization
- [LLM Primitives](./llm/) â€” completions, chat, tools, agents, embeddings, and more

---


# CLI Reference

```
sema [OPTIONS] [FILE] [-- SCRIPT_ARGS...]
```

## Flags & Options

| Flag                 | Description                                  |
| -------------------- | -------------------------------------------- |
| `-e, --eval <EXPR>`  | Evaluate expression, print result if non-nil |
| `-p, --print <EXPR>` | Evaluate expression, always print result     |
| `-l, --load <FILE>`  | Load file(s) before executing (repeatable)   |
| `-q, --quiet`        | Suppress REPL banner                         |
| `-i, --interactive`  | Enter REPL after running file or eval        |
| `--no-init`          | Skip LLM auto-configuration                  |
| `--no-llm`           | Disable LLM features (same as `--no-init`)   |
| `--model <NAME>`     | Set default LLM model                        |
| `--provider <NAME>`  | Set LLM provider                             |
| `--sandbox <MODE>`   | Restrict dangerous operations (see below)    |
| `-V, --version`      | Print version                                |
| `-h, --help`         | Print help                                   |

## Subcommands

### `sema ast`

Parse source into an AST tree.

```
sema ast [OPTIONS] [FILE]
```

| Flag                | Description                      |
| ------------------- | -------------------------------- |
| `-e, --eval <EXPR>` | Parse expression instead of file |
| `--json`            | Output AST as JSON               |

### `sema completions`

Generate shell completion scripts. See [Shell Completions](./shell-completions.md) for installation instructions.

```
sema completions <SHELL>
```

Supported shells: `bash`, `zsh`, `fish`, `elvish`, `powershell`.

## Examples

```bash
# Parse a file into an AST tree
sema ast script.sema

# Parse an expression into JSON AST
sema ast -e '(+ 1 2)' --json

# Load a prelude before starting the REPL
sema -l prelude.sema

# Load helpers, then run a script
sema -l helpers.sema script.sema

# Run a script and drop into REPL to inspect state
sema -i script.sema

# Quick one-liner for shell pipelines
sema -p '(string/join (map str (range 10)) ",")'

# Run without LLM features (faster startup)
sema --no-llm script.sema

# Use a specific model
sema --model claude-haiku-4-5-20251001 -e '(llm/complete "Hello!")'

# Shebang support in scripts
#!/usr/bin/env sema

# Run with shell commands disabled
sema --sandbox=no-shell script.sema

# Deny multiple capabilities
sema --sandbox=no-shell,no-network,no-fs-write script.sema

# Strict mode (no shell, fs-write, network, env-write, process, llm)
sema --sandbox=strict script.sema

# Maximum restriction (deny all dangerous operations)
sema --sandbox=all script.sema
```

## Sandbox

The `--sandbox` flag restricts access to dangerous operations. Functions remain callable but return a `PermissionDenied` error when invoked.

### Modes

| Mode            | Description                                                            |
| --------------- | ---------------------------------------------------------------------- |
| `strict`        | Deny shell, fs-write, network, env-write, process, llm (reads allowed) |
| `all`           | Deny all capabilities                                                  |
| Comma-separated | e.g. `no-shell,no-network` â€” deny specific capabilities                |

### Capabilities

| Capability  | Functions affected                                                         |
| ----------- | -------------------------------------------------------------------------- |
| `shell`     | `shell`                                                                    |
| `fs-read`   | `file/read`, `file/exists?`, `file/list`, `file/info`, `load`, ...         |
| `fs-write`  | `file/write`, `file/append`, `file/delete`, `file/mkdir`, `file/copy`, ... |
| `network`   | `http/get`, `http/post`, `http/put`, `http/delete`, `http/request`         |
| `env-read`  | `env`, `sys/env-all`                                                       |
| `env-write` | `sys/set-env`                                                              |
| `process`   | `exit`, `sys/pid`, `sys/args`, `sys/which`                                 |
| `llm`       | `llm/complete`, `llm/chat`, `llm/send`                                     |

Functions not listed (arithmetic, strings, lists, maps, `println`, `path/join`, etc.) are never restricted.

## Environment Variables

| Variable             | Description                                           |
| -------------------- | ----------------------------------------------------- |
| `ANTHROPIC_API_KEY`  | Anthropic API key (auto-detected)                     |
| `OPENAI_API_KEY`     | OpenAI API key (auto-detected)                        |
| `GROQ_API_KEY`       | Groq API key (auto-detected)                          |
| `XAI_API_KEY`        | xAI/Grok API key (auto-detected)                      |
| `MISTRAL_API_KEY`    | Mistral API key (auto-detected)                       |
| `MOONSHOT_API_KEY`   | Moonshot API key (auto-detected)                      |
| `GOOGLE_API_KEY`     | Google Gemini API key (auto-detected)                 |
| `OLLAMA_HOST`        | Ollama server URL (default: `http://localhost:11434`) |
| `JINA_API_KEY`       | Jina embeddings API key (auto-detected)               |
| `VOYAGE_API_KEY`     | Voyage embeddings API key (auto-detected)             |
| `COHERE_API_KEY`     | Cohere embeddings API key (auto-detected)             |
| `SEMA_DEFAULT_MODEL` | Default model name                                    |
| `SEMA_LLM_PROVIDER`  | Preferred provider                                    |

## REPL Commands

| Command        | Description                 |
| -------------- | --------------------------- |
| `,quit` / `,q` | Exit the REPL               |
| `,help` / `,h` | Show help                   |
| `,env`         | Show user-defined bindings  |
| `,builtins`    | List all built-in functions |

## REPL Features

### Tab Completion

The REPL supports tab completion for:

- All 350+ built-in function names (e.g., `string/tr` â†’ `string/trim`)
- Special forms (`def` â†’ `define`, `defun`, `defmacro`, ...)
- User-defined bindings
- REPL commands (`,` â†’ `,quit`, `,help`, `,env`, `,builtins`)

### Multiline Input

The REPL automatically detects incomplete expressions (unbalanced parentheses) and continues on the next line:

```
sema> (define (factorial n)
  ...   (if (= n 0)
  ...     1
  ...     (* n (factorial (- n 1)))))
sema> (factorial 10)
3628800
```

### History

Command history is saved to `~/.sema/history.txt` and persists across sessions.

---


# Shell Completions

Sema can generate tab-completion scripts for your shell, giving you completions for all CLI flags, options, and subcommands.

```
sema completions <SHELL>
```

Supported shells: `bash`, `zsh`, `fish`, `elvish`, `powershell`.

## Zsh

### macOS (with oh-my-zsh or custom fpath)

```bash
mkdir -p ~/.zsh/completions
sema completions zsh > ~/.zsh/completions/_sema
```

Make sure your `~/.zshrc` includes the directory in `fpath` **before** `compinit` is called:

```bash
fpath=(~/.zsh/completions $fpath)
autoload -Uz compinit && compinit
```

If you use oh-my-zsh, add the `fpath` line before `source $ZSH/oh-my-zsh.sh` (oh-my-zsh calls `compinit` for you).

### Linux

```bash
# User-local (no sudo required)
mkdir -p ~/.zsh/completions
sema completions zsh > ~/.zsh/completions/_sema
```

Add to `~/.zshrc` (before `compinit`):

```bash
fpath=(~/.zsh/completions $fpath)
autoload -Uz compinit && compinit
```

Or install system-wide:

```bash
sudo sema completions zsh > /usr/local/share/zsh/site-functions/_sema
```

Then restart your shell or run `exec zsh`.

## Bash

### macOS

macOS ships with an older Bash. Install `bash-completion` via Homebrew:

```bash
brew install bash-completion@2
```

Then generate and install the completion script:

```bash
mkdir -p ~/.local/share/bash-completion/completions
sema completions bash > ~/.local/share/bash-completion/completions/sema
```

### Linux

```bash
# User-local
mkdir -p ~/.local/share/bash-completion/completions
sema completions bash > ~/.local/share/bash-completion/completions/sema

# Or system-wide
sudo sema completions bash > /etc/bash_completion.d/sema
```

Then restart your shell or run `source ~/.bashrc`.

## Fish

```bash
sema completions fish > ~/.config/fish/completions/sema.fish
```

This works on both macOS and Linux. Completions are picked up automatically on the next shell session.

## PowerShell

```powershell
# Create the completions directory if it doesn't exist
New-Item -ItemType Directory -Force -Path (Split-Path -Parent $PROFILE)

# Append the completion script to your profile
sema completions powershell >> $PROFILE
```

Restart PowerShell to activate.

## Elvish

```bash
sema completions elvish > ~/.config/elvish/lib/sema.elv
```

Then add `use sema` to `~/.config/elvish/rc.elv`.

## Verifying

After installing, restart your shell and type `sema ` then press <kbd>Tab</kbd>. You should see completions for flags and subcommands.

---


# Editor Support

Sema has editor plugins for VS Code, Vim/Neovim, Emacs, Helix, and Zed. All plugins provide syntax highlighting for the full standard library (350+ functions), special forms, keyword literals, character literals, strings, numbers, comments, and LLM primitives.

Source code for all editor plugins is in the [`editors/`](https://github.com/HelgeSverre/sema/tree/main/editors) directory.

## VS Code

TextMate grammar-based extension with full syntax highlighting, bracket matching, auto-closing pairs, comment toggling, and indentation support.

### Install

```bash
EXT_DIR=~/.vscode/extensions/helgesverre.sema-0.1.0
mkdir -p "$EXT_DIR/syntaxes"
BASE=https://raw.githubusercontent.com/HelgeSverre/sema/main/editors/vscode/sema
curl -fsSL "$BASE/package.json" -o "$EXT_DIR/package.json"
curl -fsSL "$BASE/language-configuration.json" -o "$EXT_DIR/language-configuration.json"
curl -fsSL "$BASE/syntaxes/sema.tmLanguage.json" -o "$EXT_DIR/syntaxes/sema.tmLanguage.json"
curl -fsSL "$BASE/icon.png" -o "$EXT_DIR/icon.png"
```

Restart VS Code after installing.

### Features

- Syntax highlighting (special forms, builtins, LLM primitives, keywords, strings, numbers, booleans, character literals, comments)
- Bracket matching and auto-closing for `()`, `[]`, `{}`, `""`
- Comment toggling (<kbd>Ctrl</kbd>+<kbd>/</kbd> / <kbd>Cmd</kbd>+<kbd>/</kbd>)
- Indentation rules for all bracket types
- Arithmetic/comparison operator highlighting

## Vim / Neovim

Pure Vimscript plugin with syntax highlighting, filetype detection, and Lisp-aware indentation.

### vim-plug

```vim
Plug 'helgesverre/sema', { 'rtp': 'editors/vim' }
```

### lazy.nvim

```lua
{
  "helgesverre/sema",
  config = function(plugin)
    vim.opt.rtp:append(plugin.dir .. "/editors/vim")
  end,
}
```

### Manual (Vim)

```bash
mkdir -p ~/.vim/syntax ~/.vim/ftdetect ~/.vim/ftplugin
BASE=https://raw.githubusercontent.com/HelgeSverre/sema/main/editors/vim
curl -fsSL "$BASE/syntax/sema.vim" -o ~/.vim/syntax/sema.vim
curl -fsSL "$BASE/ftdetect/sema.vim" -o ~/.vim/ftdetect/sema.vim
curl -fsSL "$BASE/ftplugin/sema.vim" -o ~/.vim/ftplugin/sema.vim
```

### Manual (Neovim)

```bash
mkdir -p ~/.config/nvim/syntax ~/.config/nvim/ftdetect ~/.config/nvim/ftplugin
BASE=https://raw.githubusercontent.com/HelgeSverre/sema/main/editors/vim
curl -fsSL "$BASE/syntax/sema.vim" -o ~/.config/nvim/syntax/sema.vim
curl -fsSL "$BASE/ftdetect/sema.vim" -o ~/.config/nvim/ftdetect/sema.vim
curl -fsSL "$BASE/ftplugin/sema.vim" -o ~/.config/nvim/ftplugin/sema.vim
```

### Features

- Full syntax highlighting (special forms, 350+ builtins, LLM primitives, keywords, character literals, comments)
- Automatic filetype detection for `.sema` files
- Lisp-aware indentation with correct `lispwords` for all Sema special forms
- Comment string configured for `;`

## Emacs

Major mode derived from `prog-mode` with Lisp-aware indentation, REPL integration, and imenu support.

### Manual

```bash
mkdir -p ~/.emacs.d/site-lisp
curl -fsSL https://raw.githubusercontent.com/HelgeSverre/sema/main/editors/emacs/sema-mode.el \
  -o ~/.emacs.d/site-lisp/sema-mode.el
```

```elisp
(add-to-list 'load-path "~/.emacs.d/site-lisp")
(require 'sema-mode)
```

### use-package

```elisp
(use-package sema-mode
  :load-path "~/.emacs.d/site-lisp"
  :mode "\\.sema\\'")
```

### Doom Emacs

In `packages.el`:

```elisp
(package! sema-mode :recipe (:local-repo "~/.emacs.d/site-lisp"))
```

In `config.el`:

```elisp
(use-package! sema-mode :mode "\\.sema\\'")
```

### Features

- Syntax highlighting (special forms, builtins, keyword literals, booleans, character literals, numbers, strings, comments)
- Buffer-local Lisp indentation with Sema-specific form rules
- REPL integration â€” start a Sema REPL and send code interactively
- imenu support for navigating `defun`, `define`, `defmacro`, `defagent`, `deftool`, and `define-record-type` definitions
- Electric pairs for `()`, `[]`, `{}`, `""`
- Proper sexp navigation with quote (`'`), quasiquote (`` ` ``), and unquote (`,`) prefix handling

### Key Bindings

| Key       | Command               | Description                      |
| --------- | --------------------- | -------------------------------- |
| `C-c C-z` | `sema-repl`           | Start or switch to the Sema REPL |
| `C-c C-e` | `sema-send-last-sexp` | Send sexp before point to REPL   |
| `C-c C-r` | `sema-send-region`    | Send selected region to REPL     |
| `C-c C-b` | `sema-send-buffer`    | Send entire buffer to REPL       |
| `C-c C-l` | `sema-run-file`       | Run current file with `sema`     |

### Configuration

```elisp
;; Path to the sema binary (default: "sema")
(setq sema-program "/path/to/sema")
```

## Helix

Syntax highlighting using the dedicated [tree-sitter-sema](https://github.com/helgesverre/tree-sitter-sema) grammar, with Sema-specific highlight queries, text objects, and indentation.

### Install

1. Download and append the language config to your Helix configuration:

   ```bash
   BASE=https://raw.githubusercontent.com/HelgeSverre/sema/main/editors/helix
   curl -fsSL "$BASE/languages.toml" >> ~/.config/helix/languages.toml
   ```

   > If you already have a `languages.toml`, manually merge the `[[language]]` and `[[grammar]]` sections.

2. Download the query files:

   ```bash
   mkdir -p ~/.config/helix/runtime/queries/sema
   for f in highlights indents textobjects injections; do
     curl -fsSL "$BASE/queries/sema/$f.scm" \
       -o ~/.config/helix/runtime/queries/sema/$f.scm
   done
   ```

3. Fetch and build the Sema grammar:

   ```bash
   hx --grammar fetch
   hx --grammar build
   ```

4. Verify:

   ```bash
   hx --health sema
   ```

### Features

- Syntax highlighting via tree-sitter queries (special forms, builtins, LLM primitives, keywords, booleans, character literals, strings, comments)
- Text objects â€” `maf`/`mif` for function definitions, `mac`/`mic` for agent/tool definitions
- Smart auto-pairs for `()`, `[]`, `{}`, `""`
- Indentation support
- `;` line comments

### How It Works

The `grammar = "sema"` setting tells Helix to parse `.sema` files using the [tree-sitter-sema](https://github.com/helgesverre/tree-sitter-sema) grammar, which provides native support for Sema-specific syntax like keyword literals (`:name`), hash maps, and vectors. Custom query files in `queries/sema/` provide Sema-specific captures for LLM primitives, slash-namespaced builtins (`string/trim`, `llm/chat`), and special forms like `defagent` and `deftool`.

## Zed

Extension using the dedicated [tree-sitter-sema](https://github.com/helgesverre/tree-sitter-sema) grammar with full syntax highlighting, bracket matching, code outline, and auto-pairs.

### Install

1. Open Zed
2. Go to **Zed â†’ Extensions** (or <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>X</kbd>)
3. Click **Install Dev Extension**
4. Select the `editors/zed` directory from the Sema repository

### Features

- Syntax highlighting (special forms, 350+ builtins, LLM primitives, keyword literals, booleans, `nil`, strings, comments)
- Smart auto-pairs for `()`, `[]`, `{}`, `""`
- Code outline for `define`, `defun`, `defmacro`, `defagent`, `deftool`
- Bracket matching
- `;` line comments
- 2-space indentation

---


# Embedding Sema

## Overview

Sema can be embedded as a Rust library, letting you use it as a scripting or configuration language inside your own applications. The crate exposes a builder API for creating interpreters, registering native functions, and evaluating Sema code from Rust.

## Quick Start

Add Sema to your project:

```toml
[dependencies]
sema-lang = "1.6"
```

Or use the latest unreleased version from git:

```toml
[dependencies]
sema-lang = { git = "https://github.com/HelgeSverre/sema" }
```

Evaluate an expression in three lines:

```rust
use sema::{Interpreter, Value};

fn main() -> sema::Result<()> {
    let interp = Interpreter::new();

    let result = interp.eval_str("(+ 1 2 3)")?;
    println!("{result}"); // 6
    Ok(())
}
```

## The Builder

`Interpreter::builder()` returns an `InterpreterBuilder` with these options:

| Method              | Default       | Description                          |
| ------------------- | ------------- | ------------------------------------ |
| `.with_stdlib(b)`   | `true`        | Register the full standard library   |
| `.with_llm(b)`      | `true`        | Enable LLM functions and auto-config |
| `.without_stdlib()` | â€”             | Shorthand for `.with_stdlib(false)`  |
| `.without_llm()`    | â€”             | Shorthand for `.with_llm(false)`     |
| `.with_sandbox(sb)` | `allow_all()` | Set sandbox to restrict capabilities |

### Default Interpreter

`Interpreter::new()` gives you everything â€” stdlib and LLM builtins enabled:

```rust
let interp = Interpreter::new();
interp.eval_str("(+ 1 2)")?; // => 3
```

### Minimal Interpreter

No stdlib, no LLM â€” only special forms and core evaluation:

```rust
let interp = Interpreter::builder()
    .without_stdlib()
    .without_llm()
    .build();
```

### Stdlib Only (No LLM)

Disable LLM builtins for faster startup when you don't need them:

```rust
let interp = Interpreter::builder()
    .without_llm()
    .build();
```

### Sandboxed Interpreter

Restrict specific capabilities while keeping the full stdlib available:

```rust
use sema::{Interpreter, Sandbox, Caps};

// Allow computation but deny shell and network access
let interp = Interpreter::builder()
    .with_sandbox(Sandbox::deny(
        Caps::SHELL.union(Caps::NETWORK)
    ))
    .build();

interp.eval_str("(+ 1 2)")?;             // => 3 (always works)
interp.eval_str(r#"(shell "ls")"#)?;      // => PermissionDenied error
interp.eval_str(r#"(http/get "...")"#)?;  // => PermissionDenied error
```

### Multiple Interpreters

Each `Interpreter` has its own `EvalContext` with fully isolated state â€” module cache, call stack, span table, and depth counters are not shared:

```rust
let interp_a = Interpreter::new();
let interp_b = Interpreter::new();

interp_a.eval_str("(define x 1)")?;
interp_b.eval_str("(define x 2)")?;

// Each interpreter has its own bindings
assert_eq!(interp_a.eval_str("x")?, Value::Int(1));
assert_eq!(interp_b.eval_str("x")?, Value::Int(2));
```

## Registering Native Functions

Use `register_fn` to expose Rust functions to Sema scripts. The closure receives `&[Value]` and returns `Result<Value, SemaError>`.

### Basic Example

```rust
interp.register_fn("add1", |args| {
    let n = args[0]
        .as_int()
        .ok_or_else(|| sema::SemaError::type_error("int", args[0].type_name()))?;
    Ok(Value::Int(n + 1))
});
```

```scheme
(add1 41) ; => 42
```

### Capturing State

Use `Rc<RefCell<T>>` to share mutable state between Rust and Sema:

```rust
use std::rc::Rc;
use std::cell::RefCell;

let counter = Rc::new(RefCell::new(0_i64));
let c = counter.clone();
interp.register_fn("inc!", move |_| {
    *c.borrow_mut() += 1;
    Ok(Value::Int(*c.borrow()))
});
```

```scheme
(inc!) ; => 1
(inc!) ; => 2
(inc!) ; => 3
```

## Real-World Example: Data Pipeline

A Rust CLI tool that uses Sema as a scripting language for user-defined data transformations. The host app provides utility functions and loads a user-written `.sema` script that defines the transform logic.

### Rust Host

```rust
use sema::{Interpreter, Value, SemaError};
use std::rc::Rc;
use std::collections::BTreeMap;

fn main() -> sema::Result<()> {
    let interp = Interpreter::builder()
        .without_llm()
        .build();

    // Provide a logging function
    interp.register_fn("log", |args| {
        for a in args {
            eprintln!("[script] {a}");
        }
        Ok(Value::Nil)
    });

    // Load user transform script
    let script = std::fs::read_to_string("transform.sema")
        .map_err(|e| SemaError::eval(format!("failed to read script: {e}")))?;
    interp.eval_str(&script)?;

    // Process records through the user's transform function
    let records = vec![
        make_record("Alice", 34, "engineering"),
        make_record("Bob", 28, "marketing"),
        make_record("Carol", 45, "engineering"),
    ];

    for record in records {
        interp.env().set_str("__record", record);
        let result = interp.eval_str("(transform __record)")?;
        println!("{result}");
    }

    Ok(())
}

fn make_record(name: &str, age: i64, dept: &str) -> Value {
    let mut map = BTreeMap::new();
    map.insert(
        Value::Keyword(sema::intern("name")),
        Value::String(Rc::new(name.to_string())),
    );
    map.insert(
        Value::Keyword(sema::intern("age")),
        Value::Int(age),
    );
    map.insert(
        Value::Keyword(sema::intern("dept")),
        Value::String(Rc::new(dept.to_string())),
    );
    Value::Map(Rc::new(map))
}
```

### User Script (`transform.sema`)

```scheme
(define (transform record)
  (log (format "Processing: ~a" (:name record)))
  (if (> (:age record) 30)
      (assoc record :senior #t)
      record))
```

### Output

```
[script] Processing: Alice
{:age 34 :dept "engineering" :name "Alice" :senior #t}
[script] Processing: Bob
{:age 28 :dept "marketing" :name "Bob"}
[script] Processing: Carol
{:age 45 :dept "engineering" :name "Carol" :senior #t}
```

## Threading Model

Sema is **single-threaded by design**. It uses `Rc` (not `Arc`) for reference counting and a thread-local string interner for keywords and symbols.

- Multiple `Interpreter` instances can coexist on the same thread with **fully isolated evaluator state** â€” each has its own module cache, call stack, span table, and depth counters.
- Do **not** send `Value` instances across thread boundaries â€” they are not `Send` or `Sync`.
- The string interner is per-thread, so interned keys from one thread are not valid in another.
- LLM state (provider registry, usage tracking, budgets) is per-thread and shared across all interpreters on the same thread.

## Security Considerations

By default, Sema scripts have full access to the filesystem, shell, network, and environment. For untrusted code, you have two options:

**Option 1: Sandbox (recommended)** â€” Keep the full stdlib but deny dangerous capabilities:

```rust
use sema::{Interpreter, Sandbox, Caps};

let interp = Interpreter::builder()
    .with_sandbox(Sandbox::deny(Caps::STRICT))  // deny shell, fs-write, network, env-write, process, llm
    .build();
```

Sandboxed functions remain callable (tab-completable, discoverable) but return a `PermissionDenied` error when invoked.

**Option 2: Minimal** â€” No stdlib at all, register only what you need:

```rust
let interp = Interpreter::builder()
    .without_stdlib()
    .without_llm()
    .build();
// Register only safe functions manually
```

See [CLI Sandbox docs](./cli.md#sandbox) for the full list of capabilities and affected functions.

## API Reference

| Type                 | Description                                                      |
| -------------------- | ---------------------------------------------------------------- |
| `Interpreter`        | Holds the global environment; evaluates code                     |
| `InterpreterBuilder` | Configures and builds an `Interpreter`                           |
| `Value`              | Core value enum â€” Int, Float, String, List, Map, etc.            |
| `SemaError`          | Error type with `eval()`, `type_error()`, `arity()` constructors |
| `Sandbox`            | Configures which capabilities are denied                         |
| `Caps`               | Capability bitflags (FS_READ, SHELL, NETWORK, etc.)              |
| `Env`                | Environment (scope chain backed by `Rc<RefCell<BTreeMap>>`)      |
| `intern(s)`          | Intern a string, returning a `Spur` handle                       |
| `resolve(spur)`      | Resolve a `Spur` back to a `&str`                                |

---


# Data Types

Sema has 20 built-in data types covering numbers, text, collections, and LLM primitives.

## Type Table

| Type         | Syntax               | Examples                                                           |
| ------------ | -------------------- | ------------------------------------------------------------------ |
| Integer      | digits               | `42`, `-7`, `0`                                                    |
| Float        | digits with `.`      | `3.14`, `-0.5`, `1e10`                                             |
| String       | double-quoted        | `"hello"`, `"line\nbreak"`, `"\x1B;"`                              |
| Boolean      | `#t` / `#f`          | `#t`, `#f`                                                         |
| Nil          | `nil`                | `nil`                                                              |
| Symbol       | bare identifier      | `foo`, `my-var`, `+`                                               |
| Keyword      | colon-prefixed       | `:name`, `:type`, `:ok`                                            |
| Character    | `#\` prefix          | `#\a`, `#\space`, `#\newline`                                      |
| List         | parenthesized        | `(1 2 3)`, `(+ a b)`                                               |
| Vector       | bracketed            | `[1 2 3]`, `["a" "b"]`                                             |
| Map          | curly-braced         | `{:name "Ada" :age 36}`                                            |
| HashMap      | `(hashmap/new ...)`  | `(hashmap/new :a 1 :b 2)`                                          |
| Prompt       | `(prompt ...)`       | LLM prompt (see [Prompts](../llm/prompts.md))                      |
| Message      | `(message ...)`      | LLM message (see [Prompts](../llm/prompts.md))                     |
| Conversation | `(conversation/new)` | LLM conversation (see [Conversations](../llm/conversations.md))    |
| Tool         | `(deftool ...)`      | LLM tool definition (see [Tools & Agents](../llm/tools-agents.md)) |
| Agent        | `(defagent ...)`     | LLM agent (see [Tools & Agents](../llm/tools-agents.md))           |
| Promise      | `(delay expr)`       | Lazy evaluation                                                    |
| Record       | `define-record-type` | `(define-record-type point ...)`                                   |
| Bytevector   | `#u8(...)` literal   | `#u8(1 2 3)`, `#u8()`                                              |

## Scalars

### Integer

Whole numbers. Standard arithmetic applies.

```scheme
42
-7
0
```

### Float

Floating-point numbers with a decimal point.

```scheme
3.14
-0.5
0.001
```

### String

Double-quoted text with escape sequences.

```scheme
"hello"
"line\nbreak"
"\x1B;"
```

### Boolean

`#t` for true, `#f` for false.

```scheme
#t
#f
```

### Nil

The empty/null value.

```scheme
nil
```

### Symbol

Bare identifiers used as variable names and in quoted data.

```scheme
foo
my-var
+
```

### Keyword

Colon-prefixed identifiers. Keywords are self-evaluating and can be used as accessor functions on maps.

```scheme
:name
:type
:ok

;; Keywords as functions
(:name {:name "Ada" :age 36})  ; => "Ada"
```

### Character

Character literals with `#\` prefix. Named characters are supported.

```scheme
#\a
#\space
#\newline
#\tab
```

## Collections

### List

Parenthesized sequences. Lists are the fundamental data structure in Sema.

```scheme
(1 2 3)
(+ a b)
'(hello world)
```

### Vector

Bracketed sequences with O(1) indexed access.

```scheme
[1 2 3]
["a" "b"]
```

### Map

Curly-braced key-value pairs with deterministic (sorted) ordering.

```scheme
{:name "Ada" :age 36}
{:a 1 :b 2 :c 3}
```

### HashMap

Hash-based maps for O(1) lookup performance with many keys.

```scheme
(hashmap/new :a 1 :b 2 :c 3)
```

### Bytevector

Byte arrays with `#u8(...)` literal syntax.

```scheme
#u8(1 2 3)
#u8()
(bytevector 1 2 3)
(make-bytevector 4)
```

## Special Types

### Promise

Lazy evaluation via `delay`/`force`. The expression is not evaluated until forced, and the result is memoized.

```scheme
(define p (delay (+ 1 2)))
(force p)       ; => 3
(promise? p)    ; => #t
```

### Record

User-defined record types with constructors, predicates, and field accessors.

```scheme
(define-record-type point
  (make-point x y)
  point?
  (x point-x)
  (y point-y))

(define p (make-point 3 4))
(point-x p)    ; => 3
```

## String Escape Sequences

| Escape       | Description                          | Example               |
| ------------ | ------------------------------------ | --------------------- |
| `\n`         | Newline                              | `"line\nbreak"`       |
| `\t`         | Tab                                  | `"col1\tcol2"`        |
| `\r`         | Carriage return                      | `"text\r"`            |
| `\\`         | Backslash                            | `"path\\file"`        |
| `\"`         | Double quote                         | `"say \"hi\""`        |
| `\0`         | Null character                       | `"\0"`                |
| `\x<hex>;`   | Unicode scalar (R7RS, 1+ hex digits) | `"\x1B;"`, `"\x3BB;"` |
| `\uNNNN`     | Unicode code point (4 hex digits)    | `"\u03BB"` (Î»)        |
| `\UNNNNNNNN` | Unicode code point (8 hex digits)    | `"\U0001F600"` (ðŸ˜€)   |

## Type Predicates

```scheme
(null? '())        (nil? nil)         (empty? "")
(list? '(1))       (vector? [1])      (map? {:a 1})
(pair? '(1 2))     ; #t (non-empty list, Scheme compat)
(number? 42)       (integer? 42)      (float? 3.14)
(string? "hi")     (symbol? 'x)       (keyword? :k)
(char? #\a)        (record? r)        (bytevector? #u8())
(promise? (delay 1))  (promise-forced? p)
(bool? #t)         (fn? car)
(zero? 0)          (even? 4)          (odd? 3)
(positive? 1)      (negative? -1)
(eq? 'a 'a)        (= 1 1)

;; Scheme aliases: boolean? = bool?, procedure? = fn?, equal? = eq?

;; LLM type predicates
(prompt? p)        (message? m)       (conversation? c)
(tool? t)          (agent? a)
```

## Type Conversions

```scheme
(str 42)                    ; => "42" (any value to string)
(string->number "42")       ; => 42
(number->string 42)         ; => "42"
(string->symbol "foo")      ; => foo
(symbol->string 'foo)       ; => "foo"
(string->keyword "name")    ; => :name
(keyword->string :name)     ; => "name"
(char->integer #\A)         ; => 65
(integer->char 65)          ; => #\A
(char->string #\a)          ; => "a"
(string->char "a")          ; => #\a
(string->list "abc")        ; => (#\a #\b #\c)
(list->string '(#\h #\i))   ; => "hi"
(vector->list [1 2 3])      ; => (1 2 3)
(list->vector '(1 2 3))     ; => [1 2 3]
(bytevector->list #u8(65))   ; => (65)
(list->bytevector '(1 2 3))  ; => #u8(1 2 3)
(utf8->string #u8(104 105))  ; => "hi"
(string->utf8 "hi")          ; => #u8(104 105)
(type 42)                    ; => "integer"
```

---


# Special Forms

Special forms are built into the evaluator â€” they control evaluation order and cannot be redefined.

## Definitions & Assignment

### `define`

Bind a value or define a function.

```scheme
(define x 42)                          ; bind a value
(define (square x) (* x x))           ; define a function (shorthand)
```

### `set!`

Mutate an existing binding.

```scheme
(set! x 99)
```

## Functions

### `lambda`

Create an anonymous function.

```scheme
(lambda (x y) (+ x y))
```

### `fn`

Alias for `lambda`.

```scheme
(fn (x) (* x x))
(fn (x . rest) rest)                   ; rest parameters with dot notation
```

## Conditionals

### `if`

Two-branch conditional.

```scheme
(if (> x 0) "positive" "non-positive")
```

### `cond`

Multi-branch conditional with `else` fallback.

```scheme
(cond
  ((< x 0) "negative")
  ((= x 0) "zero")
  (else "positive"))
```

### `case`

Match a value against literal alternatives.

```scheme
(case (:status response)
  ((:ok) "success")
  ((:error :timeout) "failure")
  (else "unknown"))
```

### `when`

Execute body only if condition is true. Returns `nil` otherwise.

```scheme
(when (> x 0) (println "positive"))
```

### `unless`

Execute body only if condition is false.

```scheme
(unless (> x 0) (println "not positive"))
```

## Bindings

### `let`

Parallel bindings â€” all init expressions are evaluated before any binding is created.

```scheme
(let ((x 10) (y 20))
  (+ x y))
```

### `let*`

Sequential bindings â€” each binding is visible to subsequent ones.

```scheme
(let* ((x 10) (y (* x 2)))
  (+ x y))
```

### `letrec`

Recursive bindings â€” all bindings are visible to all init expressions. Useful for mutually recursive functions.

```scheme
(letrec ((even? (fn (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd?  (fn (n) (if (= n 0) #f (even? (- n 1))))))
  (even? 10))
```

### Named `let`

Loop construct with tail-call optimization.

```scheme
(let loop ((i 0) (sum 0))
  (if (= i 100)
    sum
    (loop (+ i 1) (+ sum i))))
```

## Sequencing & Logic

### `begin`

Evaluate expressions in order, return the last result.

```scheme
(begin expr1 expr2 ... exprN)
```

### `and`

Short-circuit logical AND. Returns the last truthy value or `#f`.

```scheme
(and a b c)
```

### `or`

Short-circuit logical OR. Returns the first truthy value or `#f`.

```scheme
(or a b c)
```

## Iteration

### `do`

Scheme `do` loop with variable bindings, step expressions, and a termination test.

```scheme
;; (do ((var init step) ...) (test result ...) body ...)
(do ((i 0 (+ i 1))
     (sum 0 (+ sum i)))
    ((= i 10) sum))                    ; => 45
```

With a body for side effects:

```scheme
(do ((i 0 (+ i 1)))
    ((= i 5))
  (println i))                         ; prints 0..4
```

## Lazy Evaluation

### `delay`

Create a promise â€” the expression is not evaluated until forced.

```scheme
(define p (delay (+ 1 2)))
```

### `force`

Evaluate a promise and memoize the result. Non-promise values pass through.

```scheme
(force p)                              ; => 3 (evaluate and memoize)
(force p)                              ; => 3 (returns cached value)
(force 42)                             ; => 42 (non-promise passes through)
```

### `promise?`

Check if a value is a promise.

```scheme
(promise? p)                           ; => #t
```

### `promise-forced?`

Check if a promise has already been forced.

```scheme
(promise-forced? p)                    ; => #t (after forcing)
```

## Record Types

### `define-record-type`

Define a record type with constructor, predicate, and field accessors.

```scheme
(define-record-type point
  (make-point x y)
  point?
  (x point-x)
  (y point-y))

(define p (make-point 3 4))
(point? p)                             ; => #t
(point-x p)                           ; => 3
(point-y p)                           ; => 4
(record? p)                           ; => #t
(type p)                              ; => :point
(equal? (make-point 1 2) (make-point 1 2))  ; => #t
```

## Error Handling

### `try` / `catch`

Catch errors with structured error maps.

```scheme
(try
  (/ 1 0)
  (catch e
    (println (format "Error: ~a" (:message e)))
    (:type e)))        ; => :eval
```

::: warning
`try`/`catch` catches **all** error types â€” not just user exceptions thrown with `throw`. This includes internal errors like `:unbound` (typos in variable names), `:permission-denied`, and `:arity` (wrong number of arguments). Catching everything can silently mask bugs. **Re-throw errors you don't intend to handle.**
:::

#### Error map fields

Every caught error is a map with at least `:type`, `:message`, and `:stack-trace`. Some error types include additional fields:

| `:type` | Description | Extra fields |
|---|---|---|
| `:reader` | Syntax / parse error | â€” |
| `:eval` | General evaluation error | â€” |
| `:type-error` | Wrong argument type | `:expected`, `:got` |
| `:arity` | Wrong number of arguments | â€” |
| `:unbound` | Undefined variable | `:name` |
| `:llm` | LLM provider error | â€” |
| `:io` | File / network I/O error | â€” |
| `:permission-denied` | Sandboxed capability denied | `:function`, `:capability` |
| `:user` | Thrown with `throw` | `:value` (the original thrown value) |

#### Discriminating error types

Use the `:type` field to handle specific errors and re-throw the rest:

```scheme
(try
  (some-operation)
  (catch e
    (cond
      ((= (get e :type) :permission-denied)
       (println "Access denied!"))
      ((= (get e :type) :user)
       (println (format "User error: ~a" (get e :message))))
      (else
       (throw e)))))  ;; re-throw unexpected errors
```

### `throw`

Throw any value as an error.

```scheme
(throw "something went wrong")
(throw {:code 404 :reason "not found"})
```

---


# Macros & Modules

## Macros

Sema supports `defmacro`-style macros with quasiquoting, unquoting, and splicing.

### `defmacro`

Define a macro that transforms code at expansion time.

```scheme
(defmacro unless2 (test . body)
  `(if ,test nil (begin ,@body)))

(unless2 #f (println "runs!"))
```

### `macroexpand`

Inspect the expansion of a macro call without evaluating it.

```scheme
(macroexpand '(unless2 #f (println "x")))
```

### `gensym`

Generate a unique symbol for hygienic-ish macro writing.

```scheme
(gensym "tmp")   ; => tmp_42 (unique each call)
```

## Metaprogramming

### `eval`

Evaluate data as code.

```scheme
(eval '(+ 1 2))   ; => 3
```

### `read`

Parse a string into a Sema value.

```scheme
(read "(+ 1 2)")   ; => (+ 1 2) as a list value
```

### `read-many`

Parse a string containing multiple forms.

```scheme
(read-many "(+ 1 2) (* 3 4)")   ; => ((+ 1 2) (* 3 4))
```

### `type`

Return the type of a value as a string.

```scheme
(type 42)              ; => "integer"
(type "hi")            ; => "string"
(type :foo)            ; => "keyword"
```

### Type Conversion Functions

```scheme
(string->symbol "foo")       ; => foo
(keyword->string :bar)       ; => "bar"
(string->keyword "name")     ; => :name
(symbol->string 'foo)        ; => "foo"
```

## Modules

### `module`

Define a module with explicit exports.

```scheme
;; math-utils.sema
(module math-utils
  (export square cube)
  (define (square x) (* x x))
  (define (cube x) (* x x x))
  (define (internal-helper x) x))      ; not exported
```

### `import`

Import a module from a file. Only exported bindings become available.

```scheme
;; main.sema
(import "math-utils.sema")
(square 5)   ; => 25
(cube 3)     ; => 27
```

---


# LLM Primitives

Sema's differentiating feature: LLM operations are first-class language primitives with prompts, conversations, tools, and agents as native data types.

## Setup

Set one or more API keys as environment variables:

```bash
export ANTHROPIC_API_KEY=sk-ant-...
export OPENAI_API_KEY=sk-...
# or any other supported provider
```

Sema auto-detects and configures all available providers on startup. Use `--no-llm` to skip auto-configuration.

See [Provider Management](./providers.md) for the full list of supported providers and configuration options.

## Features

### [Completion & Chat](./completion.md)

Simple completions, multi-message chat, and streaming responses.

### [Prompts & Messages](./prompts.md)

Prompts as composable s-expressions, message construction, and prompt inspection.

### [Conversations](./conversations.md)

Persistent, immutable conversation state with automatic LLM round-trips.

### [Tools & Agents](./tools-agents.md)

Define tools the LLM can invoke, and build agents with system prompts, tools, and multi-turn loops.

### [Embeddings & Similarity](./embeddings.md)

Generate embeddings (as bytevectors), compute cosine similarity, and access embedding dimensions.

### [Structured Extraction](./extraction.md)

Extract structured data from text and images, classify inputs, and work with multi-modal content.

### [Vector Store & Math](./vector-store.md)

In-memory vector store for semantic search, plus vector math utilities (cosine similarity, dot product, normalize, distance).

### [Caching](./caching.md)

In-memory LLM response caching for iterative development and deduplication.

### [Resilience & Retry](./resilience.md)

Fallback provider chains, rate limiting, generic retry with exponential backoff, and convenience functions (`llm/summarize`, `llm/compare`).

### [Provider Management](./providers.md)

Auto-configuration, runtime provider switching, custom providers, and OpenAI-compatible endpoints.

### [Cost Tracking & Budgets](./cost.md)

Usage tracking, budget enforcement, and batch/parallel operations.

---


# Completion & Chat

## Completion

### `llm/complete`

Send a single prompt string and get a completion back.

```scheme
;; Simple completion
(llm/complete "Say hello in 5 words" {:max-tokens 50})
```

With options:

```scheme
(llm/complete "Explain monads"
  {:model "claude-haiku-4-5-20251001"
   :max-tokens 200
   :temperature 0.3
   :system "You are a Haskell expert."})
```

### `llm/stream`

Stream a completion, printing chunks as they arrive.

```scheme
(llm/stream "Tell me a story" {:max-tokens 200})
```

With a callback function:

```scheme
(llm/stream "Tell me a story"
  (fn (chunk) (display chunk))
  {:max-tokens 200})
```

## Chat

### `llm/chat`

Send a list of messages and get a response. Supports system, user, and assistant messages.

```scheme
(llm/chat
  [(message :system "You are a helpful assistant.")
   (message :user "What is Lisp? One sentence.")]
  {:max-tokens 100})
```

### Multi-Modal Chat

Send messages that include images alongside text using `message/with-image`.

```scheme
;; Load an image and ask the LLM about it
(define img (file/read-bytes "photo.jpg"))
(define msg (message/with-image :user "Describe this image." img))
(llm/chat (list msg))
```

Combine with regular messages:

```scheme
(llm/chat
  [(message :system "You are an image analyst.")
   (message/with-image :user "What text is in this image?" (file/read-bytes "doc.png"))])
```

The image must be a bytevector. Media type (PNG, JPEG, GIF, WebP, PDF) is detected automatically from magic bytes. See [Vision Extraction](./extraction.md#vision-extraction) for structured data extraction from images.

### `llm/send`

Send a prompt value (composed from `prompt` expressions) to the LLM.

```scheme
(define review-prompt
  (prompt
    (system "You are a code reviewer. Be concise.")
    (user "Review this function.")))

(llm/send review-prompt {:max-tokens 200})
```

## Options

All completion and chat functions accept an options map with these keys:

| Key            | Description                                                   |
| -------------- | ------------------------------------------------------------- |
| `:model`       | Model name (e.g. `"claude-haiku-4-5-20251001"`)               |
| `:max-tokens`  | Maximum tokens in response                                    |
| `:temperature` | Sampling temperature (0.0â€“1.0)                                |
| `:system`      | System prompt (for `llm/complete`)                            |
| `:tools`       | List of tool values (see [Tools & Agents](./tools-agents.md)) |

---


# Prompts & Messages

Prompts in Sema are composable data structures â€” not string templates. They are built from message expressions and can be inspected, transformed, and composed before being sent to an LLM.

## Messages

### `message`

Create a message with a role and content.

```scheme
(message :system "You are a helpful assistant.")
(message :user "What is Lisp?")
(message :assistant "Lisp is a family of programming languages.")
```

### `message/role`

Get the role of a message.

```scheme
(message/role (message :user "hi"))     ; => :user
```

### `message/content`

Get the content of a message.

```scheme
(message/content (message :user "hi"))  ; => "hi"
```

## Prompts

### `prompt`

Build a prompt from message expressions. This creates a composable data structure.

```scheme
(define review-prompt
  (prompt
    (system "You are a code reviewer. Be concise.")
    (user "Review this function.")))
```

### `prompt/append`

Compose prompts by appending one to another.

```scheme
(define base (prompt (system "You are helpful.")))
(define question (prompt (user "What is 2+2?")))
(define full (prompt/append base question))

(llm/send full)
```

### `prompt/messages`

Get the list of messages from a prompt.

```scheme
(prompt/messages my-prompt)   ; => list of message values
```

### `prompt/set-system`

Create a new prompt with the system message replaced.

```scheme
(prompt/set-system my-prompt "new system instructions")
```

## Type Predicates

### `prompt?`

Check if a value is a prompt.

```scheme
(prompt? review-prompt)   ; => #t
```

### `message?`

Check if a value is a message.

```scheme
(message? (message :user "hi"))   ; => #t
```

---


# Conversations

Conversations are persistent, immutable data structures that maintain chat history with automatic LLM round-trips. Each operation returns a new conversation value â€” the original is never modified.

## Creating Conversations

### `conversation/new`

Create a new conversation, optionally with a default model.

```scheme
(define conv (conversation/new {:model "claude-haiku-4-5-20251001"}))
(define conv (conversation/new {}))
```

## Interacting

### `conversation/say`

Send a message in the conversation. This sends the full history to the LLM and returns a new conversation with both the user message and the assistant's reply appended.

```scheme
(define conv (conversation/new {:model "claude-haiku-4-5-20251001"}))
(define conv (conversation/say conv "Remember: the secret number is 7"))
(define conv (conversation/say conv "What is the secret number?"))
(conversation/last-reply conv)          ; => "The secret number is 7."
```

With options:

```scheme
(define conv (conversation/say conv "Explain more"
  {:temperature 0.5 :max-tokens 500}))
```

### `conversation/add-message`

Manually add a message to the conversation without making an LLM call.

```scheme
(define c (conversation/new {}))
(define c (conversation/add-message c :user "hello"))
(define c (conversation/add-message c :assistant "hi there"))
```

## Inspecting

### `conversation/last-reply`

Get the content of the last assistant message.

```scheme
(conversation/last-reply conv)
```

### `conversation/messages`

Get the full list of messages in the conversation.

```scheme
(conversation/messages conv)   ; => list of message values
```

### `conversation/model`

Get the model associated with the conversation.

```scheme
(conversation/model conv)   ; => "claude-haiku-4-5-20251001"
```

## Branching

### `conversation/fork`

Fork a conversation, creating an independent copy. Since conversations are immutable, this is equivalent to a clone.

```scheme
(define conv (conversation/new {}))
(define conv (conversation/say conv "Remember the number 7"))
(define branch (conversation/fork conv))
;; branch and conv are now independent
```

## Type Predicate

### `conversation?`

Check if a value is a conversation.

```scheme
(conversation? conv)   ; => #t
```

---


# Structured Extraction

Extract structured data from unstructured text using LLM-powered schema-based extraction and classification.

## Extraction

### `llm/extract`

Extract structured data from text according to a schema. The schema defines the expected fields and their types.

```scheme
(llm/extract
  {:vendor {:type :string}
   :amount {:type :number}
   :date   {:type :string}}
  "I bought coffee for $4.50 at Blue Bottle on Jan 15, 2025")
; => {:amount 4.5 :date "2025-01-15" :vendor "Blue Bottle"}
```

The schema map specifies field names as keys and type descriptors as values. Supported types include `:string`, `:number`, and `:boolean`.

### Options

`llm/extract` accepts an optional third argument â€” an options map:

```scheme
(llm/extract schema text {:model "claude-haiku-4-5-20251001"})
```

| Option      | Type    | Default | Description                                        |
| ----------- | ------- | ------- | -------------------------------------------------- |
| `:model`    | string  | â€”       | Override the default model                         |
| `:validate` | boolean | `false` | Validate response against the schema               |
| `:retries`  | integer | `0`     | Retry on validation failure (requires `:validate`) |

### Schema Validation

With `:validate true`, the extracted result is checked against the schema:

- All schema keys must be present in the result
- Types must match: `:string` â†’ string, `:number` â†’ integer or float, `:boolean` â†’ boolean, `:list`/`:array` â†’ list or vector

```scheme
;; Strict extraction with validation
(llm/extract
  {:name {:type :string}
   :age  {:type :number}}
  "Alice is 30 years old"
  {:validate true})
; => {:age 30 :name "Alice"}
```

If validation fails, an error is raised with details about which fields didn't match.

### Retry on Mismatch

Combine `:validate` with `:retries` to automatically re-send the request when the LLM returns data that doesn't match the schema:

```scheme
(llm/extract
  {:items {:type :list}
   :total {:type :number}}
  "3 apples, 2 oranges, total 5 items"
  {:validate true :retries 2})
```

On each retry, the validation errors are fed back to the LLM to improve the next attempt. After exhausting retries, the final validation error is raised.

## Classification

### `llm/classify`

Classify text into one of a set of categories. Returns the matching keyword.

```scheme
(llm/classify [:positive :negative :neutral]
              "This product is amazing!")
; => :positive
```

Pass a vector of keyword labels and the text to classify. The LLM picks the best-matching label.

## Vision Extraction

### `llm/extract-from-image`

Extract structured data from images using vision-capable LLMs. Accepts a schema, an image source (file path or bytevector), and optional options.

```scheme
;; Extract from a file path
(llm/extract-from-image
  {:text :string :background_color :string}
  "assets/logo.png")
; => {:background_color "white" :text "Sema"}

;; Extract from a bytevector
(define img (file/read-bytes "invoice.jpg"))
(llm/extract-from-image
  {:invoice_number :string :date :string :total :string}
  img)
; => {:date "2025-03-15" :invoice_number "12345" :total "$139.96"}
```

Supported image formats (detected automatically via magic bytes): PNG, JPEG, GIF, WebP, PDF.

### Options

`llm/extract-from-image` accepts an optional third argument â€” an options map:

```scheme
(llm/extract-from-image schema source {:model "gpt-4o"})
```

| Option   | Type   | Default | Description                |
| -------- | ------ | ------- | -------------------------- |
| `:model` | string | â€”       | Override the default model |

## Multi-Modal Messages

### `message/with-image`

Create a message that includes both text and an image, for use with `llm/chat`.

```scheme
(define img (file/read-bytes "photo.jpg"))
(define msg (message/with-image :user "What do you see?" img))
(llm/chat (list msg))
```

The image must be a bytevector (use `file/read-bytes` to load from disk). The media type is detected automatically.

You can combine image messages with regular messages:

```scheme
(llm/chat
  [(message :system "You are a helpful image analyst.")
   (message/with-image :user "Describe this chart." (file/read-bytes "chart.png"))])
```

### Provider Support

Vision features work with providers that support multi-modal input:

| Provider      | `llm/extract-from-image` | `message/with-image` |
| ------------- | ------------------------ | -------------------- |
| **Anthropic** | âœ…                       | âœ…                   |
| **OpenAI**    | âœ…                       | âœ…                   |
| **Gemini**    | âœ…                       | âœ…                   |
| **Ollama**    | âœ… (model-dependent)     | âœ… (model-dependent) |

For Ollama, use a vision-capable model like `gemma3:4b` or `llava`.

---


# Tools & Agents

## Tools

Tools let you define functions that the LLM can invoke during a conversation. The LLM sees the tool's name, description, and parameter schema, and can call it when appropriate.

### `deftool`

Define a tool with a name, description, parameter schema, and handler function.

```scheme
(deftool lookup-capital
  "Look up the capital of a country"
  {:country {:type :string :description "Country name"}}
  (lambda (country)
    (cond
      ((= country "Norway") "Oslo")
      ((= country "France") "Paris")
      (else "Unknown"))))
```

### Using Tools with Chat

Pass tools to `llm/chat` â€” the LLM will call them automatically when needed.

```scheme
(llm/chat
  [(message :user "What is the capital of Norway?")]
  {:tools [lookup-capital] :max-tokens 100})
```

### Inspecting Tools

### `tool/name`

```scheme
(tool/name lookup-capital)              ; => "lookup-capital"
```

### `tool/description`

```scheme
(tool/description lookup-capital)       ; => "Look up the capital..."
```

### `tool/parameters`

```scheme
(tool/parameters lookup-capital)        ; => {:country {:type :string ...}}
```

### `tool?`

```scheme
(tool? lookup-capital)                  ; => #t
```

## Agents

Agents combine a system prompt, tools, and a multi-turn loop. They handle the back-and-forth of tool calls automatically.

### `defagent`

Define an agent with a system prompt, tools, model, and turn limit.

```scheme
(deftool get-weather
  "Get weather for a city"
  {:city {:type :string}}
  (lambda (city)
    (format "~a: 22Â°C, sunny" city)))

(defagent weather-bot
  {:system "You are a weather assistant. Use the get-weather tool."
   :tools [get-weather]
   :model "claude-haiku-4-5-20251001"
   :max-turns 3})
```

### `agent/run`

Run an agent with a user message. The agent will loop, calling tools as needed, until it has a final answer or hits the turn limit.

```scheme
(agent/run weather-bot "What's the weather in Tokyo?")
```

### Inspecting Agents

### `agent/name`

```scheme
(agent/name weather-bot)                ; => "weather-bot"
```

### `agent/system`

```scheme
(agent/system weather-bot)              ; => "You are a weather assistant..."
```

### `agent/tools`

```scheme
(agent/tools weather-bot)               ; => list of tool values
```

### `agent/model`

```scheme
(agent/model weather-bot)               ; => "claude-haiku-4-5-20251001"
```

### `agent/max-turns`

```scheme
(agent/max-turns weather-bot)           ; => 3
```

### `agent?`

```scheme
(agent? weather-bot)                    ; => #t
```

---


# Embeddings & Similarity

Generate vector embeddings from text and compute similarity between them. Embeddings are auto-configured from environment variables (`JINA_API_KEY`, `VOYAGE_API_KEY`, or `COHERE_API_KEY`).

## Configuration

### `llm/configure-embeddings`

Configure a dedicated embedding provider separately from the chat provider.

```scheme
(llm/configure-embeddings :jina {:api-key (env "JINA_API_KEY")})
(llm/configure-embeddings :voyage {:api-key (env "VOYAGE_API_KEY")})
(llm/configure-embeddings :cohere {:api-key (env "COHERE_API_KEY")})

;; OpenAI-compatible embedding provider
(llm/configure-embeddings :openai {:api-key (env "OPENAI_API_KEY")})
```

This allows you to use one provider for chat (e.g., Anthropic) and a different one for embeddings.

## Generating Embeddings

### `llm/embed`

Generate an embedding for a string or a list of strings. Returns a **bytevector** containing densely-packed f64 values in little-endian format. This representation is 2Ã— more memory efficient and 4Ã— faster for similarity computations compared to a list of floats.

```scheme
;; Single embedding (returns a bytevector)
(define v1 (llm/embed "hello world"))

;; Batch embeddings
(llm/embed ["cat" "dog" "fish"])       ; => list of bytevectors
```

## Embedding Accessors

### `embedding/length`

Returns the number of dimensions (f64 elements) in an embedding bytevector.

```scheme
(define v (llm/embed "hello"))
(embedding/length v)                   ; => 1024 (depends on provider)
```

### `embedding/ref`

Access a specific dimension by index.

```scheme
(define v (llm/embed "hello"))
(embedding/ref v 0)                    ; => 0.0123 (first dimension)
```

### `embedding/->list`

Convert an embedding bytevector to a list of floats (useful for interop).

```scheme
(define v (llm/embed "hello"))
(embedding/->list v)                   ; => (0.0123 -0.0456 ...)
```

### `embedding/list->embedding`

Convert a list of numbers to an embedding bytevector.

```scheme
(define v (embedding/list->embedding '(0.1 0.2 0.3)))
(embedding/length v)                   ; => 3
```

## Computing Similarity

### `llm/similarity`

Compute cosine similarity between two embedding vectors. Returns a value between -1.0 and 1.0. Accepts both bytevectors (fast path) and lists of floats (backward compatible).

```scheme
(define v1 (llm/embed "hello world"))
(define v2 (llm/embed "hi there"))
(llm/similarity v1 v2)                 ; => 0.87 (cosine similarity)

;; Also works with plain lists
(llm/similarity '(0.1 0.2 0.3) '(0.4 0.5 0.6))
```

## Token Counting

### `llm/token-count`

Estimate the number of tokens in a string or list of strings. Uses a heuristic (chars/4) â€” no tokenizer dependency required.

```scheme
(llm/token-count "hello world")           ; => 3
(llm/token-count '("hello" "world"))      ; => sum of individual counts
```

### `llm/token-estimate`

Returns a detailed estimate map with the token count and the estimation method used.

```scheme
(llm/token-estimate "hello world")
; => {:method "chars/4" :tokens 3}
```

## Supported Embedding Providers

| Provider | Env Variable     |
| -------- | ---------------- |
| Jina     | `JINA_API_KEY`   |
| Voyage   | `VOYAGE_API_KEY` |
| Cohere   | `COHERE_API_KEY` |
| OpenAI   | `OPENAI_API_KEY` |

See [Provider Management](./providers.md) for the full provider capability table.

---


# Vector Store & Math

## In-Memory Vector Store

Sema includes an in-memory vector store for semantic search over embeddings. Create named stores, add documents with embeddings and metadata, and search by cosine similarity. Stores can optionally be persisted to disk as JSON.

### `vector-store/create`

Create a named in-memory vector store. Returns the store name.

```scheme
(vector-store/create "my-store")
```

### `vector-store/open`

Open a named store backed by a file. If the file exists, its contents are loaded; otherwise an empty store is created. The path is remembered for subsequent `vector-store/save` calls.

```scheme
(vector-store/open "my-store" "embeddings.json")
```

### `vector-store/add`

Add a document with an ID, embedding (bytevector), and metadata map.

```scheme
(vector-store/add "my-store" "doc-1"
  (llm/embed "Hello world")
  {:source "greeting.txt" :page 1})
```

If a document with the same ID exists, it is replaced.

### `vector-store/search`

Search by cosine similarity. Takes store name, query embedding, and k (number of results). Returns a list of maps with `:id`, `:score`, and `:metadata`.

```scheme
(vector-store/search "my-store" (llm/embed "Hi there") 5)
;; => ({:id "doc-1" :score 0.92 :metadata {:source "greeting.txt" :page 1}} ...)
```

### `vector-store/delete`

Delete a document by ID. Returns `#t` if found, `#f` otherwise.

```scheme
(vector-store/delete "my-store" "doc-1")  ; => #t
```

### `vector-store/count`

Return the number of documents in a store.

```scheme
(vector-store/count "my-store")  ; => 42
```

### `vector-store/save`

Save a store to disk as JSON. If the store was opened with `vector-store/open`, the path is used automatically. Otherwise, pass a path explicitly.

```scheme
;; Explicit path
(vector-store/save "my-store" "embeddings.json")

;; Implicit path (if opened with vector-store/open)
(vector-store/save "my-store")
```

The file format is a JSON document with base64-encoded embeddings and full metadata, portable across platforms.

## Vector Math

These functions operate on embedding bytevectors (packed f64 arrays in little-endian format, as returned by `llm/embed` or `embedding/list->embedding`).

### `vector/cosine-similarity`

Cosine similarity between two embedding vectors. Returns a float between -1.0 and 1.0.

```scheme
(vector/cosine-similarity
  (embedding/list->embedding '(1.0 0.0))
  (embedding/list->embedding '(0.0 1.0)))
; => 0.0
```

### `vector/dot-product`

Dot product of two embedding vectors.

```scheme
(vector/dot-product
  (embedding/list->embedding '(1.0 2.0 3.0))
  (embedding/list->embedding '(4.0 5.0 6.0)))
; => 32.0
```

### `vector/normalize`

Return a unit-length copy of the vector.

```scheme
(vector/normalize (embedding/list->embedding '(3.0 4.0)))
;; => embedding with values (0.6 0.8)
```

### `vector/distance`

Euclidean distance between two embedding vectors.

```scheme
(vector/distance
  (embedding/list->embedding '(0.0 0.0))
  (embedding/list->embedding '(3.0 4.0)))
; => 5.0
```

## Full Example

A RAG-style workflow: embed documents, store them, search semantically, and persist to disk.

```scheme
;; Open a persistent store (creates file if it doesn't exist)
(vector-store/open "docs" "my-docs.json")

(define texts '("Rust is a systems language"
                "Python is great for ML"
                "Lisp is homoiconic"))

(for-each
  (lambda (text)
    (vector-store/add "docs" text (llm/embed text) {:text text}))
  texts)

;; Save to disk
(vector-store/save "docs")

;; Search
(define results
  (vector-store/search "docs" (llm/embed "programming languages") 2))
(map (lambda (r) (:text (:metadata r))) results)
```

Next time you run, `(vector-store/open "docs" "my-docs.json")` will load the saved embeddings instantly â€” no re-embedding needed.

---


# Response Caching

Sema provides an in-memory response cache for LLM calls, keyed on prompt + model + temperature. Caching is per-session and useful for iterative development, avoiding duplicate API calls when re-running scripts with the same prompts.

## Cache Scope

### `llm/with-cache`

Wraps a thunk (lambda), enabling the response cache for all LLM calls within it. An optional second argument is an options map with `:ttl` (time-to-live in seconds, default 3600). Returns the thunk's result.

```scheme
(llm/with-cache (lambda () (llm/complete "hello")))

(llm/with-cache (lambda () (llm/complete "hello")) {:ttl 7200})
```

## Inspection & Debugging

### `llm/cache-key`

Generate the SHA-256 cache key for a given prompt and options. Useful for debugging cache behavior. Takes 1â€“2 args: a prompt string and an optional options map.

```scheme
(llm/cache-key "hello" {:model "gpt-4" :temperature 0.5})
```

### `llm/cache-stats`

Returns a map with `:hits`, `:misses`, and `:size` (number of cached entries).

```scheme
(llm/cache-stats)  ; => {:hits 0 :misses 0 :size 0}
```

## Cache Management

### `llm/cache-clear`

Clear all cached responses. Returns the number of entries cleared.

```scheme
(llm/cache-clear)  ; => 0
```

---


# Resilience & Retry

## Fallback Provider Chains

### `llm/with-fallback`

Wraps a thunk with a fallback chain of providers. If the LLM call fails with one provider, automatically tries the next provider in the list.

```scheme
(llm/with-fallback [:anthropic :openai :groq]
  (lambda () (llm/complete "Hello")))
```

## Rate Limiting

### `llm/with-rate-limit`

Wraps a thunk with token-bucket rate limiting. Takes a rate (requests per second) and a thunk. Useful to avoid hitting API rate limits.

```scheme
(llm/with-rate-limit 5 (lambda () (llm/complete "Hello")))
```

## Generic Retry

### `retry`

Retries a thunk on failure with exponential backoff. Takes a thunk and an optional options map.

```scheme
;; Default: 3 attempts, 100ms base delay, 2.0 backoff
(retry (lambda () (http/get "https://example.com")))

;; Custom options
(retry (lambda () (http/get "https://example.com"))
  {:max-attempts 5 :base-delay-ms 200 :backoff 1.5})
```

Options:

| Key              | Type    | Default | Description                        |
| ---------------- | ------- | ------- | ---------------------------------- |
| `:max-attempts`  | integer | 3       | Maximum number of attempts         |
| `:base-delay-ms` | integer | 100     | Initial delay between retries (ms) |
| `:backoff`       | float   | 2.0     | Backoff multiplier                 |

> **Note:** `retry` is in the stdlib (not LLM-specific) â€” it works with any function.

## LLM Convenience Functions

### `llm/summarize`

Summarize text using an LLM. Takes text and an optional options map.

```scheme
(llm/summarize "Long article text here...")
(llm/summarize "Long text" {:model "claude-haiku-4-5-20251001" :max-tokens 200})
```

### `llm/compare`

Compare two texts using an LLM. Takes two strings and an optional options map.

```scheme
(llm/compare "Text A" "Text B")
(llm/compare "Text A" "Text B" {:model "claude-haiku-4-5-20251001"})
```

---


# Provider Management

## Auto-Configuration

Sema auto-detects and configures all available providers from environment variables on startup. No manual setup is required â€” just set the API key for your provider.

### `llm/auto-configure`

Manually trigger auto-configuration (runs automatically on startup unless `--no-llm` is used).

```scheme
(llm/auto-configure)
```

## Manual Configuration

### `llm/configure`

Manually configure a known provider with specific options.

```scheme
(llm/configure :anthropic {:api-key "sk-..."})

;; Ollama with custom host
(llm/configure :ollama {:host "http://localhost:11434"
                         :default-model "llama3"})
```

### OpenAI-Compatible Providers

Any provider with an OpenAI-compatible API can be registered by passing `:api-key` and `:base-url` with any provider name. No Rust code required.

```scheme
;; Together AI
(llm/configure :together
  {:api-key (env "TOGETHER_API_KEY")
   :base-url "https://api.together.xyz/v1"
   :default-model "meta-llama/Llama-3-70b-chat-hf"})

;; Azure OpenAI
(llm/configure :azure
  {:api-key (env "AZURE_OPENAI_KEY")
   :base-url "https://my-resource.openai.azure.com/openai/deployments/gpt-4/v1"
   :default-model "gpt-4"})

;; Local vLLM / LiteLLM / text-generation-inference
(llm/configure :local
  {:api-key "not-needed"
   :base-url "http://localhost:8000/v1"
   :default-model "my-model"})

;; Once configured, use like any other provider
(llm/complete "Hello from Together!" {:model "meta-llama/Llama-3-70b-chat-hf"})
```

This works for any service that implements the OpenAI chat completions API: Together, Fireworks, Perplexity, Azure OpenAI, Anyscale, vLLM, LiteLLM, text-generation-inference, and others.

## Lisp-Defined Providers

For full control over request/response handling, you can define providers entirely in Sema using `llm/define-provider`. The provider's `:complete` function receives the request as a map and returns either a string or a response map.

### `llm/define-provider`

```scheme
(llm/define-provider :name {:complete fn :default-model "..."})
```

**Parameters:**

- `:complete` â€” **(required)** A function that takes a request map and returns a response
- `:default-model` â€” Model name used when none is specified (default: `"default"`)

### Request Map

The `:complete` function receives a map with these keys:

| Key               | Type           | Description                        |
| ----------------- | -------------- | ---------------------------------- |
| `:model`          | string         | Model name                         |
| `:messages`       | list of maps   | Each has `:role` and `:content`    |
| `:max-tokens`     | integer or nil | Token limit                        |
| `:temperature`    | float or nil   | Sampling temperature               |
| `:system`         | string or nil  | System prompt                      |
| `:tools`          | list or nil    | Tool schemas (if tools are in use) |
| `:stop-sequences` | list or nil    | Stop sequences for generation      |

### Response Format

The function can return either:

- **A string** â€” used as the assistant's response content
- **A map** with optional keys:

| Key            | Type   | Default       |
| -------------- | ------ | ------------- |
| `:content`     | string | `""`          |
| `:role`        | string | `"assistant"` |
| `:model`       | string | request model |
| `:stop-reason` | string | `"end_turn"`  |
| `:usage`       | map    | zero tokens   |
| `:tool-calls`  | list   | empty list    |

The `:usage` map can contain `:prompt-tokens` and `:completion-tokens` (both integers).

The `:tool-calls` list contains maps with `:id` (string), `:name` (string), and `:arguments` (map). This enables Lisp-defined providers to work with tool-calling agents.

### Examples

**Echo provider** â€” returns the user's message back:

```scheme
(llm/define-provider :echo
  {:complete (fn (req)
    (string-append "Echo: " (:content (last (:messages req)))))
   :default-model "echo-v1"})

(llm/complete "hello")  ;; => "Echo: hello"
```

**HTTP proxy** â€” forward to a custom API:

```scheme
(llm/define-provider :my-api
  {:complete (fn (req)
    (define resp (json/decode
      (http/post "https://my-api.example.com/chat"
        {:headers {"Authorization" (string-append "Bearer " (env "MY_API_KEY"))
                   "Content-Type" "application/json"}
         :body (json/encode {:model (:model req)
                             :prompt (:content (last (:messages req)))})})))
    {:content (:text resp)
     :usage {:prompt-tokens (:input-tokens resp)
             :completion-tokens (:output-tokens resp)}})
   :default-model "my-model-v2"})
```

**Mock provider for testing** â€” deterministic responses without API calls:

```scheme
(define responses (list "First response" "Second response" "Third response"))
(define call-count (atom 0))

(llm/define-provider :mock
  {:complete (fn (req)
    (let ((i (deref call-count)))
      (swap! call-count (fn (n) (+ n 1)))
      (nth responses (mod i (length responses)))))
   :default-model "mock-v1"})

;; Now all llm/complete calls return deterministic values
(llm/complete "anything")  ;; => "First response"
(llm/complete "anything")  ;; => "Second response"
```

**Routing provider** â€” dispatch to different backends by model name:

```scheme
(llm/configure :anthropic {:api-key (env "ANTHROPIC_API_KEY")})
(llm/configure :openai {:api-key (env "OPENAI_API_KEY")})

(llm/define-provider :router
  {:complete (fn (req)
    (let ((model (:model req)))
      (cond
        ((string/starts-with? model "claude")
         (begin (llm/set-default :anthropic)
                (llm/complete (:content (last (:messages req))) {:model model})))
        ((string/starts-with? model "gpt")
         (begin (llm/set-default :openai)
                (llm/complete (:content (last (:messages req))) {:model model})))
        (else (error (string-append "Unknown model: " model))))))
   :default-model "claude-sonnet-4-20250514"})
```

### Switching Between Providers

Lisp-defined providers integrate with the standard provider management functions:

```scheme
(llm/define-provider :mock
  {:complete (fn (req) "mock response") :default-model "m1"})

(llm/configure :anthropic {:api-key (env "ANTHROPIC_API_KEY")})

(llm/set-default :mock)      ;; use mock
(llm/complete "test")         ;; => "mock response"

(llm/set-default :anthropic)  ;; switch to real API
(llm/complete "test")         ;; => real API response
```

## Runtime Provider Switching

### `llm/list-providers`

List all configured providers.

```scheme
(llm/list-providers)   ; => (:anthropic :gemini :openai ...)
(llm/providers)        ; => same (alias)
```

### `llm/current-provider`

Get the currently active provider and model.

```scheme
(llm/current-provider)   ; => {:name :anthropic :model "claude-sonnet-4-20250514"}
(llm/default-provider)   ; => same (alias)
```

### `llm/set-default`

Switch the active provider at runtime.

```scheme
(llm/set-default :openai)
```

## Supported Providers

All providers are auto-configured from environment variables. Use `(llm/configure :provider {...})` for manual setup.

| Provider            | Type                  | Chat | Stream | Tools | Embeddings | Vision |
| ------------------- | --------------------- | ---- | ------ | ----- | ---------- | ------ |
| **Anthropic**       | Native                | âœ…   | âœ…     | âœ…    | â€”          | âœ…     |
| **OpenAI**          | Native                | âœ…   | âœ…     | âœ…    | âœ…         | âœ…     |
| **Google Gemini**   | Native                | âœ…   | âœ…     | âœ…    | â€”          | âœ…     |
| **Ollama**          | Native (local)        | âœ…   | âœ…     | âœ…    | â€”          | âœ… Â²   |
| **Groq**            | OpenAI-compat         | âœ…   | âœ…     | âœ…    | â€”          | â€”      |
| **xAI**             | OpenAI-compat         | âœ…   | âœ…     | âœ…    | â€”          | â€”      |
| **Mistral**         | OpenAI-compat         | âœ…   | âœ…     | âœ…    | â€”          | â€”      |
| **Moonshot**        | OpenAI-compat         | âœ…   | âœ…     | âœ…    | â€”          | â€”      |
| **Jina**            | Embedding-only        | â€”    | â€”      | â€”     | âœ…         | â€”      |
| **Voyage**          | Embedding-only        | â€”    | â€”      | â€”     | âœ…         | â€”      |
| **Cohere**          | Embedding-only        | â€”    | â€”      | â€”     | âœ…         | â€”      |
| _Any OpenAI-compat_ | `llm/configure`       | âœ…   | âœ…     | âœ…    | â€”          | âœ…     |
| _Custom Lisp_       | `llm/define-provider` | âœ…   | Â¹      | âœ…    | â€”          | â€”      |

Â¹ Streaming falls back to non-streaming (sends complete response as a single chunk).

Â² Vision requires a vision-capable model (e.g., `gemma3:4b`, `llava`).

## Environment Variables

| Variable             | Description                                           |
| -------------------- | ----------------------------------------------------- |
| `ANTHROPIC_API_KEY`  | Anthropic API key                                     |
| `OPENAI_API_KEY`     | OpenAI API key                                        |
| `GROQ_API_KEY`       | Groq API key                                          |
| `XAI_API_KEY`        | xAI/Grok API key                                      |
| `MISTRAL_API_KEY`    | Mistral API key                                       |
| `MOONSHOT_API_KEY`   | Moonshot API key                                      |
| `GOOGLE_API_KEY`     | Google Gemini API key                                 |
| `OLLAMA_HOST`        | Ollama server URL (default: `http://localhost:11434`) |
| `JINA_API_KEY`       | Jina embeddings API key                               |
| `VOYAGE_API_KEY`     | Voyage embeddings API key                             |
| `COHERE_API_KEY`     | Cohere embeddings API key                             |
| `SEMA_DEFAULT_MODEL` | Default model name                                    |
| `SEMA_LLM_PROVIDER`  | Preferred provider                                    |

---


# Cost Tracking & Budgets

## Usage Tracking

### `llm/last-usage`

Get token usage from the most recent LLM call.

```scheme
(llm/last-usage)   ; => {:prompt-tokens 42 :completion-tokens 15 ...}
```

### `llm/session-usage`

Get cumulative usage across all LLM calls in the current session.

```scheme
(llm/session-usage)
```

### `llm/reset-usage`

Reset session usage counters.

```scheme
(llm/reset-usage)
```

## Pricing Sources

Sema tracks LLM costs using pricing data from multiple sources, checked in this order:

1. **Custom pricing** â€” set via `(llm/set-pricing "model" input output)`, always wins
2. **Dynamic pricing** â€” fetched from [llm-prices.com](https://www.llm-prices.com) during `(llm/auto-configure)`, cached locally at `~/.sema/pricing-cache.json`
3. **Built-in estimates** â€” hardcoded fallback table (may be outdated)
4. **Unknown** â€” if no source matches, cost tracking returns `nil` and budget enforcement is best-effort

Dynamic pricing is fetched with a short timeout (2s) and failures are silently ignored. The language works fully offline â€” the cache persists between sessions.

### `llm/pricing-status`

Check which pricing source is active and when it was last updated.

```scheme
(llm/pricing-status)
; => {:source fetched :updated-at "2025-10-10"}
; or {:source hardcoded} if no dynamic pricing is available
```

## Budget Enforcement

> **Note:** If pricing is unknown for a model (not in any source), budget enforcement operates in best-effort mode â€” the call proceeds with a one-time warning. Use `(llm/set-pricing)` to set pricing for unlisted models.

### `llm/set-budget`

Set a spending limit (in dollars) for the session. LLM calls that would exceed the budget will fail.

```scheme
(llm/set-budget 1.00)   ; set $1.00 spending limit
```

### `llm/budget-remaining`

Check current budget status.

```scheme
(llm/budget-remaining)   ; => {:limit 1.0 :spent 0.05 :remaining 0.95}
```

### `llm/with-budget`

Scoped budget â€” sets spending limits for the duration of a thunk, then restores the previous budget when done. At least one of `:max-cost-usd` or `:max-tokens` is required. When both are provided, **whichever limit is hit first** triggers the error.

```scheme
;; Cost-based budget
(llm/with-budget {:max-cost-usd 0.50} (lambda ()
  (llm/complete "Expensive operation")))

;; Token-based budget (useful when pricing is unknown or stale)
(llm/with-budget {:max-tokens 10000} (lambda ()
  (llm/complete "Limited tokens")))

;; Both limits â€” whichever is reached first stops execution
(llm/with-budget {:max-cost-usd 1.00 :max-tokens 50000} (lambda ()
  (llm/complete "Double-capped")
  (println (format "Budget: ~a" (llm/budget-remaining)))))
```

When a token budget is active, `llm/budget-remaining` includes `:token-limit`, `:tokens-spent`, and `:tokens-remaining` in addition to the cost fields.

### `llm/clear-budget`

Remove the spending limit.

```scheme
(llm/clear-budget)
```

### `llm/set-pricing`

Set custom pricing for a model (overrides both dynamic and built-in pricing). Costs are per million tokens.

```scheme
(llm/set-pricing "my-model" 1.0 3.0)   ; $1.00/M input, $3.00/M output
```

## Batch & Parallel

### `llm/batch`

Send multiple prompts concurrently and collect all results.

```scheme
(llm/batch ["Translate 'hello' to French"
            "Translate 'hello' to Spanish"
            "Translate 'hello' to German"])
```

### `llm/pmap`

Map a function over items, sending all resulting prompts in parallel.

```scheme
(llm/pmap
  (fn (word) (format "Define: ~a" word))
  '("serendipity" "ephemeral" "ubiquitous")
  {:max-tokens 50})
```

---


# Standard Library

Sema ships with **460+ built-in functions** across **21 modules**, covering everything from string manipulation and file I/O to HTTP requests, regex, and cryptographic hashing.

## Naming Conventions

Sema's stdlib follows consistent naming patterns:

| Pattern           | Convention           | Example                                |
| ----------------- | -------------------- | -------------------------------------- |
| `module/function` | Slash-namespaced     | `string/trim`, `file/read`, `math/gcd` |
| `legacy-name`     | Scheme compatibility | `string-append`, `string-length`       |
| `type->type`      | Arrow conversions    | `string->symbol`, `list->vector`       |
| `predicate?`      | Predicate suffix     | `null?`, `list?`, `even?`              |

## Quick Reference

### [Math & Arithmetic](./math)

| Function                                                                       | Description               |
| ------------------------------------------------------------------------------ | ------------------------- |
| `+`, `-`, `*`, `/`, `mod`                                                      | Basic arithmetic          |
| `<`, `>`, `<=`, `>=`, `=`                                                      | Comparison                |
| `abs`, `min`, `max`, `pow`, `sqrt`, `log`                                      | Numeric utilities         |
| `floor`, `ceil`, `round`, `truncate`                                           | Rounding                  |
| `sin`, `cos`, `math/tan`                                                       | Trigonometry              |
| `math/asin`, `math/acos`, `math/atan`, `math/atan2`                            | Inverse trig              |
| `math/sinh`, `math/cosh`, `math/tanh`                                          | Hyperbolic                |
| `math/exp`, `math/log10`, `math/log2`                                          | Exponential & logarithmic |
| `math/gcd`, `math/lcm`, `math/quotient`, `math/remainder`                      | Integer math              |
| `math/random`, `math/random-int`                                               | Random numbers            |
| `math/clamp`, `math/sign`, `math/lerp`, `math/map-range`                       | Interpolation & clamping  |
| `math/degrees->radians`, `math/radians->degrees`                               | Angle conversion          |
| `even?`, `odd?`, `positive?`, `negative?`, `zero?`                             | Numeric predicates        |
| `math/nan?`, `math/infinite?`                                                  | Float predicates          |
| `pi`, `e`, `math/infinity`, `math/nan`                                         | Constants                 |
| `bit/and`, `bit/or`, `bit/xor`, `bit/not`, `bit/shift-left`, `bit/shift-right` | Bitwise operations        |

### [Strings & Characters](./strings)

| Function                                                                            | Description               |
| ----------------------------------------------------------------------------------- | ------------------------- |
| `string-append`, `string-length`, `string-ref`, `substring`                         | Core string ops           |
| `str`, `format`                                                                     | Conversion & formatting   |
| `string/split`, `string/join`, `string/trim`                                        | Split, join, trim         |
| `string/upper`, `string/lower`, `string/capitalize`, `string/title-case`            | Case conversion           |
| `string/contains?`, `string/starts-with?`, `string/ends-with?`                      | Search predicates         |
| `string/replace`, `string/index-of`, `string/last-index-of`, `string/reverse`       | Manipulation              |
| `string/chars`, `string/repeat`, `string/pad-left`, `string/pad-right`              | Utilities                 |
| `string/map`, `string/number?`, `string/empty?`                                     | Higher-order & predicates |
| `string/after`, `string/before`, `string/between`, `string/take`                    | Slicing & extraction      |
| `string/chop-start`, `string/chop-end`, `string/ensure-start`, `string/ensure-end`  | Prefix & suffix           |
| `string/wrap`, `string/unwrap`, `string/remove`                                     | Wrapping & removal        |
| `string/replace-first`, `string/replace-last`                                       | Targeted replacement      |
| `string/snake-case`, `string/kebab-case`, `string/camel-case`, `string/pascal-case` | Case conversion           |
| `string/headline`, `string/words`                                                   | Headline & word splitting |
| `char->integer`, `integer->char`, `char-alphabetic?`, ...                           | Character operations      |
| `string->number`, `number->string`, `string->symbol`, ...                           | Type conversions          |

### [Lists](./lists)

| Function                                                                | Description                   |
| ----------------------------------------------------------------------- | ----------------------------- |
| `list`, `cons`, `car`, `cdr`, `first`, `rest`                           | Construction & access         |
| `cadr`, `caddr`, `last`, `nth`                                          | Positional access             |
| `length`, `append`, `reverse`, `range`                                  | Basic operations              |
| `map`, `filter`, `foldl`, `foldr`, `reduce`, `flat-map`                 | Higher-order functions        |
| `sort`, `sort-by`, `apply`, `for-each`                                  | Ordering & application        |
| `take`, `drop`, `flatten`, `flatten-deep`, `zip`, `partition`           | Sublists                      |
| `member`, `any`, `every`, `list/index-of`, `list/unique`, `list/dedupe` | Searching                     |
| `list/group-by`, `list/interleave`, `list/chunk`, `frequencies`         | Grouping                      |
| `list/sum`, `list/min`, `list/max`                                      | Aggregation                   |
| `list/shuffle`, `list/pick`                                             | Random                        |
| `list/repeat`, `make-list`, `iota`                                      | Construction                  |
| `list/split-at`, `list/take-while`, `list/drop-while`                   | Splitting                     |
| `assoc`, `assq`, `assv`                                                 | Association lists             |
| `interpose`                                                             | Interleaving                  |
| `list/reject`, `list/find`, `list/sole`                                 | Filtering & searching         |
| `list/pluck`, `list/key-by`                                             | Map extraction                |
| `list/avg`, `list/median`, `list/mode`                                  | Statistics                    |
| `list/diff`, `list/intersect`, `list/duplicates`                        | Set operations                |
| `list/sliding`, `list/page`, `list/cross-join`                          | Windowing & pagination        |
| `list/pad`, `list/join`, `list/times`                                   | Padding, joining & generation |
| `tap`                                                                   | Utility                       |

### [Vectors](./vectors)

| Function                       | Description     |
| ------------------------------ | --------------- |
| `vector`                       | Create a vector |
| `vector->list`, `list->vector` | Conversion      |

### [Maps & HashMaps](./maps)

| Function                                           | Description                  |
| -------------------------------------------------- | ---------------------------- |
| `hash-map`, `get`, `assoc`, `dissoc`, `merge`      | Core map ops                 |
| `keys`, `vals`, `contains?`, `count`               | Inspection                   |
| `map/entries`, `map/from-entries`                  | Entry conversion             |
| `map/map-vals`, `map/map-keys`, `map/filter`       | Higher-order                 |
| `map/select-keys`, `map/update`                    | Selection & update           |
| `map/sort-keys`, `map/except`, `map/zip`           | Sorting, exclusion & zipping |
| `hashmap/new`, `hashmap/get`, `hashmap/assoc`, ... | HashMap operations           |

### [Predicates & Type Checking](./predicates)

| Function                                                          | Description           |
| ----------------------------------------------------------------- | --------------------- |
| `null?`, `nil?`, `empty?`, `list?`, `pair?`                       | Collection predicates |
| `number?`, `integer?`, `float?`, `string?`, `symbol?`, `keyword?` | Type predicates       |
| `char?`, `record?`, `bytevector?`, `bool?`, `fn?`                 | More type predicates  |
| `map?`, `vector?`                                                 | Container predicates  |
| `promise?`, `promise-forced?`                                     | Promise predicates    |
| `eq?`, `=`, `zero?`, `even?`, `odd?`, `positive?`, `negative?`    | Equality & numeric    |
| `prompt?`, `message?`, `conversation?`, `tool?`, `agent?`         | LLM type predicates   |

### [File I/O & Paths](./file-io)

| Function                                                                                                      | Description                  |
| ------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| `display`, `println`, `pprint`, `print`, `print-error`, `println-error`, `newline`, `read-line`, `read-stdin` | Console I/O                  |
| `file/read`, `file/write`, `file/append`                                                                      | File read/write              |
| `file/read-bytes`, `file/write-bytes`                                                                         | Binary file I/O              |
| `file/read-lines`, `file/write-lines`                                                                         | Line-based I/O               |
| `file/for-each-line`, `file/fold-lines`                                                                       | Streaming line I/O           |
| `file/delete`, `file/rename`, `file/copy`                                                                     | File management              |
| `file/exists?`, `file/is-file?`, `file/is-directory?`, `file/is-symlink?`                                     | File predicates              |
| `file/list`, `file/mkdir`, `file/info`                                                                        | Directory operations         |
| `file/glob`                                                                                                   | File globbing                |
| `path/join`, `path/dirname`, `path/basename`, `path/extension`, `path/absolute`                               | Path manipulation            |
| `path/ext`, `path/stem`, `path/dir`, `path/filename`, `path/absolute?`                                        | Path predicates & components |

### [PDF Processing](./pdf)

| Function                 | Description                                           |
| ------------------------ | ----------------------------------------------------- |
| `pdf/extract-text`       | Extract all text from a PDF                           |
| `pdf/extract-text-pages` | Extract text per page (returns list)                  |
| `pdf/page-count`         | Get number of pages                                   |
| `pdf/metadata`           | Get metadata map (`:title`, `:author`, `:pages`, ...) |

### [HTTP & JSON](./http-json)

| Function                                                           | Description        |
| ------------------------------------------------------------------ | ------------------ |
| `http/get`, `http/post`, `http/put`, `http/delete`, `http/request` | HTTP methods       |
| `json/encode`, `json/encode-pretty`, `json/decode`                 | JSON serialization |

### [Regex](./regex)

| Function                                            | Description             |
| --------------------------------------------------- | ----------------------- |
| `regex/match?`, `regex/match`, `regex/find-all`     | Matching                |
| `regex/replace`, `regex/replace-all`, `regex/split` | Replacement & splitting |

### [CSV, Crypto & Encoding](./csv-encoding)

| Function                                      | Description     |
| --------------------------------------------- | --------------- |
| `csv/parse`, `csv/parse-maps`, `csv/encode`   | CSV operations  |
| `uuid/v4`                                     | UUID generation |
| `base64/encode`, `base64/decode`              | Base64 encoding |
| `base64/encode-bytes`, `base64/decode-bytes`  | Binary Base64   |
| `hash/sha256`, `hash/md5`, `hash/hmac-sha256` | Hashing         |

### [Date & Time](./datetime)

| Function                    | Description          |
| --------------------------- | -------------------- |
| `time/now`, `time-ms`       | Current time         |
| `time/format`, `time/parse` | Formatting & parsing |
| `time/date-parts`           | Date decomposition   |
| `time/add`, `time/diff`     | Arithmetic           |
| `sleep`                     | Delay execution      |

### [System](./system)

| Function                                                    | Description           |
| ----------------------------------------------------------- | --------------------- |
| `env`, `sys/env-all`, `sys/set-env`                         | Environment variables |
| `sys/args`, `sys/cwd`, `sys/platform`, `sys/os`, `sys/arch` | System info           |
| `sys/pid`, `sys/tty`, `sys/which`, `sys/elapsed`            | Process info          |
| `sys/interactive?`, `sys/hostname`, `sys/user`              | Session info          |
| `sys/home-dir`, `sys/temp-dir`                              | Directory paths       |
| `shell`                                                     | Run shell commands    |
| `exit`                                                      | Exit process          |

### [Bytevectors](./bytevectors)

| Function                                                       | Description       |
| -------------------------------------------------------------- | ----------------- |
| `bytevector`, `make-bytevector`                                | Construction      |
| `bytevector-length`, `bytevector-u8-ref`, `bytevector-u8-set!` | Access & mutation |
| `bytevector-copy`, `bytevector-append`                         | Copy & append     |
| `bytevector->list`, `list->bytevector`                         | List conversion   |
| `utf8->string`, `string->utf8`                                 | String conversion |

### [Records](./records)

| Function             | Description          |
| -------------------- | -------------------- |
| `define-record-type` | Define a record type |
| `record?`            | Record predicate     |
| `type`               | Get record type tag  |

### [Terminal Styling](./terminal)

| Function                                                         | Description                         |
| ---------------------------------------------------------------- | ----------------------------------- |
| `term/bold`, `term/red`, `term/green`, ...                       | Individual style functions          |
| `term/style`                                                     | Apply multiple styles with keywords |
| `term/rgb`                                                       | 24-bit true color                   |
| `term/strip`                                                     | Remove ANSI escape codes            |
| `term/spinner-start`, `term/spinner-stop`, `term/spinner-update` | Animated spinners                   |

### [Text Processing](./text-processing)

| Function                                                                  | Description                                |
| ------------------------------------------------------------------------- | ------------------------------------------ |
| `text/chunk`, `text/chunk-by-separator`, `text/split-sentences`           | Text chunking                              |
| `text/clean-whitespace`, `text/strip-html`                                | Text cleaning                              |
| `text/truncate`, `text/word-count`, `text/trim-indent`                    | Text utilities                             |
| `text/excerpt`, `text/normalize-newlines`                                 | Excerpt extraction & newline normalization |
| `prompt/template`, `prompt/render`                                        | Prompt templates                           |
| `document/create`, `document/text`, `document/metadata`, `document/chunk` | Document metadata                          |

### [Context](./context)

| Function                                                          | Description                              |
| ----------------------------------------------------------------- | ---------------------------------------- |
| `context/set`, `context/get`, `context/has?`                      | Core key-value context                   |
| `context/remove`, `context/pull`, `context/all`                   | Retrieval & cleanup                      |
| `context/merge`, `context/clear`                                  | Bulk operations                          |
| `context/with`                                                    | Scoped overrides (auto-restores on exit) |
| `context/push`, `context/stack`, `context/pop`                    | Named stacks                             |
| `context/set-hidden`, `context/get-hidden`, `context/has-hidden?` | Hidden (non-logged) context              |

### [Key-Value Store](./kv-store)

| Function                        | Description                    |
| ------------------------------- | ------------------------------ |
| `kv/open`, `kv/close`           | Open/close a JSON-backed store |
| `kv/get`, `kv/set`, `kv/delete` | CRUD operations                |
| `kv/keys`                       | List all keys                  |

### [Playground & WASM](./playground)

| Function              | Description                                            |
| --------------------- | ------------------------------------------------------ |
| `web/user-agent`      | Browser user agent string (WASM only)                  |
| `web/user-agent-data` | Structured browser info map (Chromium only, WASM only) |

---


# Math & Arithmetic

## Basic Arithmetic

### `+`

Add numbers together. Accepts any number of arguments.

```scheme
(+ 1 2 3)     ; => 6
(+ 10)        ; => 10
(+)           ; => 0
```

### `-`

Subtract numbers. With one argument, negates. With multiple, subtracts left to right.

```scheme
(- 10 3)      ; => 7
(- 10 3 2)    ; => 5
(- 5)         ; => -5
```

### `*`

Multiply numbers together.

```scheme
(* 4 5)       ; => 20
(* 2 3 4)     ; => 24
(*)           ; => 1
```

### `/`

Divide numbers. Integer division when both operands are integers.

```scheme
(/ 10 2)      ; => 5
(/ 10 3)      ; => 3
(/ 10.0 3)    ; => 3.333...
```

### `mod`

Modulo (remainder after division).

```scheme
(mod 10 3)    ; => 1
(mod 7 2)     ; => 1
```

## Comparison

### `<`

Less than. Supports chaining.

```scheme
(< 1 2)       ; => #t
(< 1 2 3)     ; => #t
(< 3 2)       ; => #f
```

### `>`

Greater than.

```scheme
(> 3 2)       ; => #t
(> 1 2)       ; => #f
```

### `<=`

Less than or equal.

```scheme
(<= 1 2)      ; => #t
(<= 2 2)      ; => #t
```

### `>=`

Greater than or equal.

```scheme
(>= 3 2)      ; => #t
(>= 2 2)      ; => #t
```

### `=`

Numeric equality.

```scheme
(= 1 1)       ; => #t
(= 1 2)       ; => #f
```

## Numeric Utilities

### `abs`

Absolute value.

```scheme
(abs -5)      ; => 5
(abs 3)       ; => 3
(abs -3.14)   ; => 3.14
```

### `min`

Return the smallest of one or more numbers.

```scheme
(min 1 2 3)   ; => 1
(min 5)       ; => 5
```

### `max`

Return the largest of one or more numbers.

```scheme
(max 1 2 3)   ; => 3
(max 5)       ; => 5
```

### `pow`

Raise a number to a power.

```scheme
(pow 2 10)    ; => 1024
(pow 3 3)     ; => 27
```

### `sqrt`

Square root.

```scheme
(sqrt 16)     ; => 4.0
(sqrt 2)      ; => 1.4142...
```

### `log`

Natural logarithm.

```scheme
(log 1)       ; => 0.0
(log 100)     ; => 4.605...
```

### `floor`

Round down to nearest integer.

```scheme
(floor 3.7)   ; => 3
(floor -2.3)  ; => -3
```

### `ceil`

Round up to nearest integer.

```scheme
(ceil 3.2)    ; => 4
(ceil -2.7)   ; => -2
```

### `round`

Round to nearest integer.

```scheme
(round 3.5)   ; => 4
(round 3.4)   ; => 3
```

## Trigonometry

### `sin`

Sine (argument in radians).

```scheme
(sin 0)       ; => 0.0
(sin pi)      ; => ~0.0
```

### `cos`

Cosine (argument in radians).

```scheme
(cos 0)       ; => 1.0
(cos pi)      ; => -1.0
```

### `math/tan`

Tangent (argument in radians).

```scheme
(math/tan 0)       ; => 0.0
(math/tan (/ pi 4)); => ~1.0
```

### `math/asin`

Inverse sine. Returns radians.

```scheme
(math/asin 1)      ; => ~1.5707 (Ï€/2)
(math/asin 0)      ; => 0.0
```

### `math/acos`

Inverse cosine. Returns radians.

```scheme
(math/acos 0)      ; => ~1.5707 (Ï€/2)
(math/acos 1)      ; => 0.0
```

### `math/atan`

Inverse tangent. Returns radians.

```scheme
(math/atan 1)      ; => ~0.7854 (Ï€/4)
(math/atan 0)      ; => 0.0
```

### `math/atan2`

Two-argument inverse tangent. Returns the angle in radians between the positive x-axis and the point (x, y).

```scheme
(math/atan2 1 1)   ; => ~0.7854 (Ï€/4)
(math/atan2 0 -1)  ; => ~3.1416 (Ï€)
```

## Hyperbolic Functions

### `math/sinh`

Hyperbolic sine.

```scheme
(math/sinh 0)      ; => 0.0
(math/sinh 1)      ; => 1.1752...
```

### `math/cosh`

Hyperbolic cosine.

```scheme
(math/cosh 0)      ; => 1.0
(math/cosh 1)      ; => 1.5430...
```

### `math/tanh`

Hyperbolic tangent.

```scheme
(math/tanh 0)      ; => 0.0
(math/tanh 1)      ; => 0.7615...
```

## Exponential & Logarithmic

### `math/exp`

Euler's number raised to a power (e^x).

```scheme
(math/exp 1)       ; => 2.71828...
(math/exp 0)       ; => 1.0
```

### `math/log10`

Base-10 logarithm.

```scheme
(math/log10 100)   ; => 2.0
(math/log10 1000)  ; => 3.0
```

### `math/log2`

Base-2 logarithm.

```scheme
(math/log2 8)      ; => 3.0
(math/log2 1024)   ; => 10.0
```

## Integer Math

### `math/gcd`

Greatest common divisor.

```scheme
(math/gcd 12 8)    ; => 4
(math/gcd 15 10)   ; => 5
```

### `math/lcm`

Least common multiple.

```scheme
(math/lcm 4 6)     ; => 12
(math/lcm 3 5)     ; => 15
```

### `math/quotient`

Integer quotient (truncated division).

```scheme
(math/quotient 10 3)  ; => 3
(math/quotient 7 2)   ; => 3
```

### `math/remainder`

Remainder after truncated division.

```scheme
(math/remainder 10 3) ; => 1
(math/remainder 7 2)  ; => 1
```

## Random Numbers

### `math/random`

Return a random float between 0.0 (inclusive) and 1.0 (exclusive).

```scheme
(math/random)      ; => 0.7291... (varies)
```

### `math/random-int`

Return a random integer in a range (inclusive on both ends).

```scheme
(math/random-int 1 100)  ; => 42 (varies)
(math/random-int 0 9)    ; => 7 (varies)
```

## Interpolation & Clamping

### `math/clamp`

Clamp a value to a range.

```scheme
(math/clamp 15 0 10)   ; => 10
(math/clamp -5 0 10)   ; => 0
(math/clamp 5 0 10)    ; => 5
```

### `math/sign`

Return the sign of a number: -1, 0, or 1.

```scheme
(math/sign -5)     ; => -1
(math/sign 0)      ; => 0
(math/sign 42)     ; => 1
```

### `math/lerp`

Linear interpolation between two values. `(math/lerp a b t)` returns `a + (b - a) * t`.

```scheme
(math/lerp 0 100 0.5)   ; => 50.0
(math/lerp 0 100 0.25)  ; => 25.0
(math/lerp 10 20 0.0)   ; => 10.0
```

### `math/map-range`

Map a value from one range to another. `(math/map-range value in-min in-max out-min out-max)`.

```scheme
(math/map-range 5 0 10 0 100)    ; => 50.0
(math/map-range 0.5 0 1 0 255)   ; => 127.5
```

## Angle Conversion

### `math/degrees->radians`

Convert degrees to radians.

```scheme
(math/degrees->radians 180)   ; => 3.14159...
(math/degrees->radians 90)    ; => 1.5707...
```

### `math/radians->degrees`

Convert radians to degrees.

```scheme
(math/radians->degrees pi)    ; => 180.0
(math/radians->degrees 1)     ; => 57.295...
```

## Numeric Predicates

### `even?`

Test if an integer is even.

```scheme
(even? 4)      ; => #t
(even? 3)      ; => #f
```

### `odd?`

Test if an integer is odd.

```scheme
(odd? 3)       ; => #t
(odd? 4)       ; => #f
```

### `positive?`

Test if a number is positive.

```scheme
(positive? 1)  ; => #t
(positive? -1) ; => #f
(positive? 0)  ; => #f
```

### `negative?`

Test if a number is negative.

```scheme
(negative? -1) ; => #t
(negative? 1)  ; => #f
```

### `zero?`

Test if a number is zero.

```scheme
(zero? 0)      ; => #t
(zero? 1)      ; => #f
```

### `math/nan?`

Test if a value is NaN (not a number).

```scheme
(math/nan? math/nan)       ; => #t
(math/nan? 42)             ; => #f
```

### `math/infinite?`

Test if a value is infinite.

```scheme
(math/infinite? math/infinity)  ; => #t
(math/infinite? 42)             ; => #f
```

## Constants

### `pi`

The mathematical constant Ï€ (3.14159...).

```scheme
pi             ; => 3.141592653589793
```

### `e`

Euler's number (2.71828...).

```scheme
e              ; => 2.718281828459045
```

### `math/infinity`

Positive infinity.

```scheme
math/infinity  ; => Inf
```

### `math/nan`

Not a number.

```scheme
math/nan       ; => NaN
```

## Scheme Aliases

### `modulo`

Alias for `mod`.

```scheme
(modulo 10 3)  ; => 1
```

### `expt`

Alias for `pow` (Scheme name for exponentiation).

```scheme
(expt 2 10)   ; => 1024
```

### `ceiling`

Alias for `ceil`.

```scheme
(ceiling 3.2)  ; => 4
```

### `truncate`

Truncate toward zero.

```scheme
(truncate 3.7)  ; => 3
(truncate -3.7) ; => -3
```

## Bitwise Operations

### `bit/and`

Bitwise AND.

```scheme
(bit/and 5 3)      ; => 1
(bit/and 15 9)     ; => 9
```

### `bit/or`

Bitwise OR.

```scheme
(bit/or 5 3)       ; => 7
(bit/or 8 4)       ; => 12
```

### `bit/xor`

Bitwise XOR.

```scheme
(bit/xor 5 3)      ; => 6
```

### `bit/not`

Bitwise NOT (complement).

```scheme
(bit/not 5)        ; => -6
```

### `bit/shift-left`

Left bit shift.

```scheme
(bit/shift-left 1 4)   ; => 16
(bit/shift-left 3 2)   ; => 12
```

### `bit/shift-right`

Right bit shift.

```scheme
(bit/shift-right 16 2) ; => 4
(bit/shift-right 8 1)  ; => 4
```

---


# Strings & Characters

## Core String Operations

### `string/split`

Split a string by a delimiter.

```scheme
(string/split "a,b,c" ",")        ; => ("a" "b" "c")
(string/split "hello world" " ")  ; => ("hello" "world")
```

### `string/join`

Join a list of strings with a separator.

```scheme
(string/join '("a" "b" "c") ", ")  ; => "a, b, c"
(string/join '("x" "y") "-")      ; => "x-y"
```

### `string/trim`

Remove whitespace from both ends.

```scheme
(string/trim "  hello  ")   ; => "hello"
(string/trim "\thello\n")   ; => "hello"
```

### `string/trim-left`

Remove whitespace from the left.

```scheme
(string/trim-left "  hi")   ; => "hi"
```

### `string/trim-right`

Remove whitespace from the right.

```scheme
(string/trim-right "hi  ")  ; => "hi"
```

### `string/upper`

Convert string to uppercase.

```scheme
(string/upper "hello")   ; => "HELLO"
```

### `string/lower`

Convert string to lowercase.

```scheme
(string/lower "HELLO")   ; => "hello"
```

### `string/capitalize`

Capitalize the first character.

```scheme
(string/capitalize "hello")   ; => "Hello"
```

### `string/title-case`

Capitalize the first character of each word.

```scheme
(string/title-case "hello world")   ; => "Hello World"
```

### `string/contains?`

Test if a string contains a substring.

```scheme
(string/contains? "hello" "ell")   ; => #t
(string/contains? "hello" "xyz")   ; => #f
```

### `string/starts-with?`

Test if a string starts with a prefix.

```scheme
(string/starts-with? "hello" "he")   ; => #t
(string/starts-with? "hello" "lo")   ; => #f
```

### `string/ends-with?`

Test if a string ends with a suffix.

```scheme
(string/ends-with? "hello" "lo")   ; => #t
(string/ends-with? "hello" "he")   ; => #f
```

### `string/replace`

Replace all occurrences of a substring.

```scheme
(string/replace "hello" "l" "r")   ; => "herro"
(string/replace "aaa" "a" "b")    ; => "bbb"
```

### `string/index-of`

Return the byte index of the first occurrence of a substring, or `nil` if not found.

```scheme
(string/index-of "hello" "ll")   ; => 2
(string/index-of "hello" "xyz")  ; => nil
```

### `string/last-index-of`

Find the last occurrence of a substring. Returns the index or -1 if not found.

```scheme
(string/last-index-of "abcabc" "abc")   ; => 3
(string/last-index-of "hello" "xyz")    ; => -1
```

### `string/chars`

Convert a string to a list of characters.

```scheme
(string/chars "abc")   ; => (#\a #\b #\c)
```

### `string/repeat`

Repeat a string N times.

```scheme
(string/repeat "ab" 3)   ; => "ababab"
(string/repeat "-" 5)    ; => "-----"
```

### `string/pad-left`

Pad a string on the left to a given width.

```scheme
(string/pad-left "42" 5 "0")   ; => "00042"
(string/pad-left "hi" 5)       ; => "   hi"
```

### `string/pad-right`

Pad a string on the right to a given width.

```scheme
(string/pad-right "hi" 5)       ; => "hi   "
(string/pad-right "42" 5 "0")   ; => "42000"
```

### `string/number?`

Test if a string represents a valid number.

```scheme
(string/number? "42")      ; => #t
(string/number? "3.14")   ; => #t
(string/number? "hello")  ; => #f
```

### `string/empty?`

Test if a string is empty.

```scheme
(string/empty? "")      ; => #t
(string/empty? "hello") ; => #f
```

### `string/map`

Apply a character function to each character in a string, returning a new string.

```scheme
(string/map char-upcase "hello")   ; => "HELLO"
```

### `string/reverse`

Reverse a string.

```scheme
(string/reverse "hello")   ; => "olleh"
```

## Unicode & Encoding

### `string/byte-length`

Return the UTF-8 byte length of a string (as opposed to character count from `string-length`). Useful for understanding the actual memory footprint â€” emoji and CJK characters use more bytes than ASCII.

```scheme
(string/byte-length "hello")   ; => 5   (ASCII: 1 byte each)
(string/byte-length "hÃ©llo")   ; => 6   (Ã© is 2 bytes in UTF-8)
(string/byte-length "æ—¥æœ¬èªž")   ; => 9   (CJK: 3 bytes each)
(string/byte-length "ðŸ˜€")      ; => 4   (emoji: 4 bytes)
```

Compare with `string-length` which counts characters:

```scheme
(string-length "ðŸ˜€")           ; => 1   (one character)
(string/byte-length "ðŸ˜€")      ; => 4   (four bytes)
```

### `string/codepoints`

Return a list of Unicode codepoint integers for each character in a string. This reveals the internal structure of composed characters and emoji sequences.

```scheme
(string/codepoints "ABC")      ; => (65 66 67)
(string/codepoints "Ã©")        ; => (233)
(string/codepoints "ðŸ˜€")       ; => (128512)
```

Emoji that appear as a single glyph are often multiple codepoints joined by Zero Width Joiner (U+200D = 8205):

```scheme
;; ðŸ‘¨â€ðŸ‘©â€ðŸ‘¦ is actually ðŸ‘¨ + ZWJ + ðŸ‘© + ZWJ + ðŸ‘¦
(string/codepoints "ðŸ‘¨â€ðŸ‘©â€ðŸ‘¦")   ; => (128104 8205 128105 8205 128102)

;; ðŸ‘‹ðŸ½ is ðŸ‘‹ + skin tone modifier
(string/codepoints "ðŸ‘‹ðŸ½")      ; => (128075 127997)
```

### `string/from-codepoints`

Construct a string from a list of Unicode codepoint integers. This is the inverse of `string/codepoints` and enables building emoji programmatically by combining codepoints.

```scheme
(string/from-codepoints (list 65 66 67))   ; => "ABC"
(string/from-codepoints (list 233))        ; => "Ã©"
```

Build emoji by combining people with ZWJ (8205):

```scheme
;; Build a family: ðŸ‘¨ + ZWJ + ðŸ‘© + ZWJ + ðŸ‘§
(string/from-codepoints (list 128104 8205 128105 8205 128103))
;; => ðŸ‘¨â€ðŸ‘©â€ðŸ‘§

;; Build a profession: ðŸ‘© + ZWJ + ðŸ’»
(string/from-codepoints (list 128105 8205 128187))
;; => ðŸ‘©â€ðŸ’»

;; Add skin tone: ðŸ‘‹ + modifier
(string/from-codepoints (list 128075 127997))
;; => ðŸ‘‹ðŸ½

;; Build flags from Regional Indicators (A=127462):
(string/from-codepoints (list 127475 127476))
;; => ðŸ‡³ðŸ‡´ (NO = Norway)
```

Roundtrip any string through codepoints:

```scheme
(string/from-codepoints (string/codepoints "Hello ä¸–ç•Œ"))
;; => "Hello ä¸–ç•Œ"
```

### `string/normalize`

Normalize a string to a Unicode normalization form. Supported forms: `:nfc`, `:nfd`, `:nfkc`, `:nfkd` (as keywords or strings).

- **NFC** â€” Canonical Decomposition, followed by Canonical Composition (most common)
- **NFD** â€” Canonical Decomposition
- **NFKC** â€” Compatibility Decomposition, followed by Canonical Composition
- **NFKD** â€” Compatibility Decomposition

```scheme
;; NFC: combine decomposed characters
;; e + combining acute accent â†’ Ã©
(string/normalize "e\u0301" :nfc)    ; => "Ã©"

;; NFD: decompose composed characters
(string-length (string/normalize "Ã©" :nfd))  ; => 2 (e + combining accent)

;; NFKC/NFKD: compatibility decomposition (ligatures, etc.)
(string/normalize "\uFB01" :nfkc)    ; => "fi" (ï¬ ligature â†’ two letters)

;; String form names also work
(string/normalize "e\u0301" "NFC")   ; => "Ã©"
```

### `string/foldcase`

Apply Unicode case folding to a string. Useful for case-insensitive comparisons and normalization. Uses full Unicode-aware lowercasing.

```scheme
(string/foldcase "HELLO")        ; => "hello"
(string/foldcase "Hello World")  ; => "hello world"
(string/foldcase "StraÃŸe")       ; => "straÃŸe"
(string/foldcase "Î©ÎœÎ•Î“Î‘")        ; => "Ï‰Î¼ÎµÎ³Î±"
```

### `string-ci=?`

Case-insensitive string equality comparison. Compares two strings after applying case folding to both.

```scheme
(string-ci=? "Hello" "hello")   ; => #t
(string-ci=? "ABC" "abc")       ; => #t
(string-ci=? "CAFÃ‰" "cafÃ©")     ; => #t
(string-ci=? "hello" "world")   ; => #f
```

## Scheme Compatibility Aliases

These functions use legacy Scheme/R7RS naming conventions. They work identically to their modern equivalents and are kept for compatibility. Prefer the `string/` namespaced variants in new code.

### `string-append`

Concatenate strings together.

```scheme
(string-append "hello" " " "world")   ; => "hello world"
(string-append "a" "b" "c")           ; => "abc"
```

### `string-length`

Return the number of characters in a string.

```scheme
(string-length "hello")   ; => 5
(string-length "")        ; => 0
(string-length "hÃ©llo")   ; => 5
(string-length "æ—¥æœ¬èªž")   ; => 3
```

### `string-ref`

Return the character at a given index.

```scheme
(string-ref "hello" 0)    ; => #\h
(string-ref "hello" 4)    ; => #\o
```

### `substring`

Extract a substring by start and end character index.

```scheme
(substring "hello" 1 3)   ; => "el"
(substring "hello" 0 5)   ; => "hello"
(substring "hÃ©llo" 1 2)   ; => "Ã©"
```

### `str`

Convert any value to its string representation.

```scheme
(str 42)           ; => "42"
(str #t)           ; => "#t"
(str '(1 2 3))    ; => "(1 2 3)"
```

### `format`

Format a string with `~a` placeholders.

```scheme
(format "~a is ~a" "Sema" "great")   ; => "Sema is great"
(format "~a + ~a = ~a" 1 2 3)        ; => "1 + 2 = 3"
```

## Characters

Character literals are written with the `#\` prefix.

```scheme
#\a                ; character literal
#\space            ; named character: space
#\newline          ; named character: newline
#\tab              ; named character: tab
```

### `char->integer`

Convert a character to its Unicode code point.

```scheme
(char->integer #\A)   ; => 65
(char->integer #\a)   ; => 97
```

### `integer->char`

Convert a Unicode code point to a character.

```scheme
(integer->char 65)    ; => #\A
(integer->char 955)   ; => #\Î»
```

### `char-alphabetic?`

Test if a character is alphabetic.

```scheme
(char-alphabetic? #\a)   ; => #t
(char-alphabetic? #\5)   ; => #f
```

### `char-numeric?`

Test if a character is numeric.

```scheme
(char-numeric? #\5)      ; => #t
(char-numeric? #\a)      ; => #f
```

### `char-whitespace?`

Test if a character is whitespace.

```scheme
(char-whitespace? #\space)   ; => #t
(char-whitespace? #\a)       ; => #f
```

### `char-upper-case?`

Test if a character is uppercase.

```scheme
(char-upper-case? #\A)   ; => #t
(char-upper-case? #\a)   ; => #f
```

### `char-upcase`

Convert a character to uppercase.

```scheme
(char-upcase #\a)   ; => #\A
```

### `char-downcase`

Convert a character to lowercase.

```scheme
(char-downcase #\Z)   ; => #\z
```

### `char->string`

Convert a character to a single-character string.

```scheme
(char->string #\a)   ; => "a"
```

### `string->char`

Convert a single-character string to a character.

```scheme
(string->char "a")   ; => #\a
```

## Character Comparison (R7RS)

### `char=?`

Character equality.

```scheme
(char=? #\a #\a)   ; => #t
(char=? #\a #\b)   ; => #f
```

### `char<?`

Character less-than (by code point).

```scheme
(char<? #\a #\b)   ; => #t
```

### `char>?`

Character greater-than.

```scheme
(char>? #\b #\a)   ; => #t
```

### `char<=?`

Character less-than-or-equal.

```scheme
(char<=? #\a #\b)   ; => #t
(char<=? #\a #\a)   ; => #t
```

### `char>=?`

Character greater-than-or-equal.

```scheme
(char>=? #\b #\a)   ; => #t
```

### `char-ci=?`

Case-insensitive character equality.

```scheme
(char-ci=? #\A #\a)   ; => #t
```

## Type Conversions

### `string->number`

Parse a string as a number.

```scheme
(string->number "42")     ; => 42
(string->number "3.14")  ; => 3.14
```

### `number->string`

Convert a number to a string.

```scheme
(number->string 42)      ; => "42"
(number->string 3.14)   ; => "3.14"
```

### `string->symbol`

Convert a string to a symbol.

```scheme
(string->symbol "foo")   ; => foo
```

### `symbol->string`

Convert a symbol to a string.

```scheme
(symbol->string 'foo)   ; => "foo"
```

### `string->keyword`

Convert a string to a keyword.

```scheme
(string->keyword "name")   ; => :name
```

### `keyword->string`

Convert a keyword to a string.

```scheme
(keyword->string :name)   ; => "name"
```

### `string->list`

Convert a string to a list of characters.

```scheme
(string->list "abc")   ; => (#\a #\b #\c)
```

### `list->string`

Convert a list of characters to a string.

```scheme
(list->string '(#\h #\i))   ; => "hi"
```

## Slicing & Extraction

### `string/after`

Everything after the first occurrence of a needle. Returns the original string if needle not found.

```scheme
(string/after "hello@world.com" "@")  ; => "world.com"
(string/after "no-match" "@")         ; => "no-match"
```

### `string/after-last`

Everything after the last occurrence of a needle.

```scheme
(string/after-last "a.b.c" ".")  ; => "c"
```

### `string/before`

Everything before the first occurrence of a needle.

```scheme
(string/before "hello@world.com" "@")  ; => "hello"
(string/before "no-match" "@")         ; => "no-match"
```

### `string/before-last`

Everything before the last occurrence of a needle.

```scheme
(string/before-last "a.b.c" ".")  ; => "a.b"
```

### `string/between`

Extract the portion between two delimiters.

```scheme
(string/between "[hello]" "[" "]")  ; => "hello"
(string/between "start:middle:end" "start:" ":end")  ; => "middle"
```

### `string/take`

Take the first N characters (positive) or last N characters (negative).

```scheme
(string/take "hello" 3)   ; => "hel"
(string/take "hello" -2)  ; => "lo"
```

## Prefix & Suffix

### `string/chop-start`

Remove a prefix if present, otherwise return unchanged.

```scheme
(string/chop-start "Hello World" "Hello ")  ; => "World"
(string/chop-start "Hello" "Bye")           ; => "Hello"
```

### `string/chop-end`

Remove a suffix if present.

```scheme
(string/chop-end "file.txt" ".txt")  ; => "file"
(string/chop-end "file.txt" ".md")   ; => "file.txt"
```

### `string/ensure-start`

Ensure a string starts with a prefix (adds it if missing).

```scheme
(string/ensure-start "/path" "/")   ; => "/path"
(string/ensure-start "path" "/")    ; => "/path"
```

### `string/ensure-end`

Ensure a string ends with a suffix.

```scheme
(string/ensure-end "path" "/")   ; => "path/"
(string/ensure-end "path/" "/")  ; => "path/"
```

### `string/wrap`

Wrap a string with left and right delimiters.

```scheme
(string/wrap "hello" "(" ")")   ; => "(hello)"
(string/wrap "hello" "**")      ; => "**hello**"
```

### `string/unwrap`

Remove surrounding delimiters if both present.

```scheme
(string/unwrap "(hello)" "(" ")")  ; => "hello"
(string/unwrap "hello" "(" ")")    ; => "hello"
```

## Replacement

### `string/replace-first`

Replace only the first occurrence of a substring.

```scheme
(string/replace-first "aaa" "a" "b")  ; => "baa"
```

### `string/replace-last`

Replace only the last occurrence.

```scheme
(string/replace-last "aaa" "a" "b")  ; => "aab"
```

### `string/remove`

Remove all occurrences of a substring.

```scheme
(string/remove "hello world" "o")  ; => "hell wrld"
```

## Case Conversion

### `string/snake-case`

Convert to snake_case.

```scheme
(string/snake-case "helloWorld")     ; => "hello_world"
(string/snake-case "Hello World")   ; => "hello_world"
```

### `string/kebab-case`

Convert to kebab-case.

```scheme
(string/kebab-case "helloWorld")     ; => "hello-world"
(string/kebab-case "Hello World")   ; => "hello-world"
```

### `string/camel-case`

Convert to camelCase.

```scheme
(string/camel-case "hello_world")    ; => "helloWorld"
(string/camel-case "Hello World")    ; => "helloWorld"
```

### `string/pascal-case`

Convert to PascalCase.

```scheme
(string/pascal-case "hello_world")   ; => "HelloWorld"
(string/pascal-case "hello world")   ; => "HelloWorld"
```

### `string/headline`

Convert to Title Case headline.

```scheme
(string/headline "hello_world")   ; => "Hello World"
(string/headline "helloWorld")    ; => "Hello World"
```

### `string/words`

Split a string into words (splits on non-alphanumeric boundaries).

```scheme
(string/words "hello_world")     ; => ("hello" "world")
(string/words "helloWorld")      ; => ("hello" "World")
(string/words "Hello World!")    ; => ("Hello" "World")
```

---


# Lists

Lists are the fundamental data structure in Sema. They are built from cons pairs and support a rich set of operations.

## Construction & Access

### `list`

Create a new list.

```scheme
(list 1 2 3)       ; => (1 2 3)
(list)             ; => ()
(list "a" "b")     ; => ("a" "b")
```

### `cons`

Prepend an element to a list.

```scheme
(cons 0 '(1 2 3))  ; => (0 1 2 3)
(cons 1 '())       ; => (1)
```

### `car`

Return the first element of a list.

```scheme
(car '(1 2 3))     ; => 1
```

### `cdr`

Return the rest of a list (everything after the first element).

```scheme
(cdr '(1 2 3))     ; => (2 3)
(cdr '(1))         ; => ()
```

### `first`

Alias for `car`. Return the first element.

```scheme
(first '(1 2 3))   ; => 1
```

### `rest`

Alias for `cdr`. Return the rest of the list.

```scheme
(rest '(1 2 3))    ; => (2 3)
```

### `cadr`, `caddr`, ...

Compositions of `car` and `cdr`. Available: `caar`, `cadr`, `cdar`, `cddr`, `caaar`, `caadr`, `cadar`, `caddr`, `cdaar`, `cdadr`, `cddar`, `cdddr`.

```scheme
(cadr '(1 2 3))    ; => 2
(caddr '(1 2 3))   ; => 3
```

### `last`

Return the last element of a list.

```scheme
(last '(1 2 3))    ; => 3
```

### `nth`

Return the element at index N (zero-based).

```scheme
(nth '(10 20 30) 1)   ; => 20
(nth '(10 20 30) 0)   ; => 10
```

## Association Lists

### `assoc`

Look up a key in an association list (list of pairs). Uses `equal?` comparison.

```scheme
(define alist '(("a" 1) ("b" 2) ("c" 3)))
(assoc "b" alist)   ; => ("b" 2)
(assoc "z" alist)   ; => #f
```

### `assq`

Like `assoc` but uses `eq?` comparison (pointer/symbol equality).

```scheme
(assq 'b '((a 1) (b 2)))   ; => (b 2)
```

### `assv`

Like `assoc` but uses `eqv?` comparison (value equality for numbers).

```scheme
(assv 2 '((1 "one") (2 "two")))   ; => (2 "two")
```

## Basic Operations

### `length`

Return the number of elements in a list.

```scheme
(length '(1 2 3))  ; => 3
(length '())       ; => 0
```

### `append`

Concatenate lists.

```scheme
(append '(1 2) '(3 4))     ; => (1 2 3 4)
(append '(1) '(2) '(3))    ; => (1 2 3)
```

### `reverse`

Reverse a list.

```scheme
(reverse '(1 2 3))   ; => (3 2 1)
```

### `range`

Generate a list of integers. With one argument, generates 0 to N-1. With two, generates from start to end-1.

```scheme
(range 5)       ; => (0 1 2 3 4)
(range 1 5)     ; => (1 2 3 4)
```

## Higher-Order Functions

### `map`

Apply a function to each element of one or more lists.

```scheme
(map (fn (x) (* x x)) '(1 2 3))      ; => (1 4 9)
(map + '(1 2 3) '(10 20 30))          ; => (11 22 33)
```

### `filter`

Return elements that satisfy a predicate.

```scheme
(filter even? '(1 2 3 4 5))   ; => (2 4)
(filter string? '(1 "a" 2))   ; => ("a")
```

### `foldl`

Left fold. `(foldl f init list)` â€” accumulates from left to right.

```scheme
(foldl + 0 '(1 2 3 4 5))   ; => 15
(foldl cons '() '(1 2 3))  ; => (3 2 1)
```

### `foldr`

Right fold. `(foldr f init list)` â€” accumulates from right to left.

```scheme
(foldr cons '() '(1 2 3))   ; => (1 2 3)
```

### `reduce`

Like `foldl` but uses the first element as the initial value.

```scheme
(reduce + '(1 2 3 4 5))   ; => 15
```

### `for-each`

Apply a function to each element for side effects.

```scheme
(for-each println '("a" "b" "c"))
;; prints: a, b, c (each on a new line)
```

### `sort`

Sort a list in ascending order.

```scheme
(sort '(3 1 4 1 5))   ; => (1 1 3 4 5)
```

### `sort-by`

Sort a list by a key function.

```scheme
(sort-by length '("bb" "a" "ccc"))   ; => ("a" "bb" "ccc")
(sort-by abs '(-3 1 -2))             ; => (1 -2 -3)
```

### `flat-map`

Map a function over a list and flatten the results by one level.

```scheme
(flat-map (fn (x) (list x (* x 10))) '(1 2 3))
; => (1 10 2 20 3 30)
```

### `apply`

Apply a function to a list of arguments.

```scheme
(apply + '(1 2 3))   ; => 6
(apply max '(3 1 4)) ; => 4
```

## Sublists

### `take`

Take the first N elements.

```scheme
(take 3 '(1 2 3 4 5))   ; => (1 2 3)
(take 10 '(1 2))         ; => (1 2)
```

### `drop`

Drop the first N elements.

```scheme
(drop 2 '(1 2 3 4 5))   ; => (3 4 5)
```

### `flatten`

Flatten nested lists into a single list.

```scheme
(flatten '(1 (2 (3)) 4))   ; => (1 2 3 4)
```

### `flatten-deep`

Recursively flatten all nested lists.

```scheme
(flatten-deep '(1 (2 (3 (4)))))   ; => (1 2 3 4)
```

### `zip`

Combine corresponding elements from two lists into pairs.

```scheme
(zip '(1 2 3) '("a" "b" "c"))   ; => ((1 "a") (2 "b") (3 "c"))
```

### `partition`

Split a list into two lists based on a predicate. Returns a list of two lists: elements that satisfy the predicate and those that don't.

```scheme
(partition even? '(1 2 3 4 5))   ; => ((2 4) (1 3 5))
```

## Searching

### `member`

Return the tail of the list starting from the first matching element.

```scheme
(member 3 '(1 2 3 4))   ; => (3 4)
(member 9 '(1 2 3))     ; => #f
```

### `any`

Test if any element satisfies a predicate.

```scheme
(any even? '(1 3 5 6))   ; => #t
(any even? '(1 3 5))     ; => #f
```

### `every`

Test if all elements satisfy a predicate.

```scheme
(every even? '(2 4 6))     ; => #t
(every even? '(2 3 6))     ; => #f
```

### `list/index-of`

Return the index of the first occurrence of a value, or -1 if not found.

```scheme
(list/index-of '(10 20 30) 20)   ; => 1
(list/index-of '(10 20 30) 99)   ; => -1
```

### `list/unique`

Remove duplicate elements, preserving order.

```scheme
(list/unique '(1 2 2 3 3 3))   ; => (1 2 3)
```

### `list/dedupe`

Remove consecutive duplicates from a list.

```scheme
(list/dedupe '(1 1 2 2 3 3 2))   ; => (1 2 3 2)
```

## Grouping

### `list/group-by`

Group elements by a function, returning a map.

```scheme
(list/group-by even? '(1 2 3 4 5))   ; => {#f (1 3 5) #t (2 4)}
```

### `list/interleave`

Interleave elements from two lists.

```scheme
(list/interleave '(1 2 3) '(a b c))   ; => (1 a 2 b 3 c)
```

### `list/chunk`

Split a list into chunks of a given size.

```scheme
(list/chunk 2 '(1 2 3 4 5))   ; => ((1 2) (3 4) (5))
(list/chunk 3 '(1 2 3 4 5 6)) ; => ((1 2 3) (4 5 6))
```

### `frequencies`

Count occurrences of each element, returning a map.

```scheme
(frequencies '(a b a c b a))   ; => {a 3 b 2 c 1}
```

### `interpose`

Insert a separator between elements.

```scheme
(interpose ", " '("a" "b" "c"))   ; => ("a" ", " "b" ", " "c")
```

## Aggregation

### `list/sum`

Sum all numbers in a list.

```scheme
(list/sum '(1 2 3 4 5))   ; => 15
```

### `list/min`

Return the minimum value in a list.

```scheme
(list/min '(3 1 4 1 5))   ; => 1
```

### `list/max`

Return the maximum value in a list.

```scheme
(list/max '(3 1 4 1 5))   ; => 5
```

## Random

### `list/shuffle`

Return a randomly shuffled copy of a list.

```scheme
(list/shuffle '(1 2 3 4 5))   ; => (3 1 5 2 4) (varies)
```

### `list/pick`

Pick a random element from a list.

```scheme
(list/pick '(1 2 3 4 5))   ; => 3 (varies)
```

## Construction

### `list/repeat`

Create a list by repeating a value N times.

```scheme
(list/repeat 3 0)   ; => (0 0 0)
(list/repeat 4 "x") ; => ("x" "x" "x" "x")
```

### `make-list`

Alias for `list/repeat`.

```scheme
(make-list 3 0)   ; => (0 0 0)
```

### `iota`

Generate a list of numbers. `(iota count)`, `(iota count start)`, or `(iota count start step)`.

```scheme
(iota 5)         ; => (0 1 2 3 4)
(iota 3 10)      ; => (10 11 12)
(iota 4 0 2)     ; => (0 2 4 6)
```

## Splitting

### `list/split-at`

Split a list at a given index, returning two lists.

```scheme
(list/split-at '(1 2 3 4 5) 3)   ; => ((1 2 3) (4 5))
```

### `list/take-while`

Take elements from the front while a predicate holds.

```scheme
(list/take-while (fn (x) (< x 4)) '(1 2 3 4 5))   ; => (1 2 3)
```

### `list/drop-while`

Drop elements from the front while a predicate holds.

```scheme
(list/drop-while (fn (x) (< x 4)) '(1 2 3 4 5))   ; => (4 5)
```

## Filtering

### `list/reject`

Return elements that do NOT satisfy a predicate (inverse of `filter`).

```scheme
(list/reject even? '(1 2 3 4 5))   ; => (1 3 5)
```

### `list/find`

Return the first element that satisfies a predicate, or `nil` if none found.

```scheme
(list/find even? '(1 3 4 5 6))   ; => 4
(list/find even? '(1 3 5))       ; => nil
```

### `list/sole`

Return the single element matching a predicate. Errors if zero or more than one match.

```scheme
(list/sole (fn (x) (> x 4)) '(1 2 3 4 5))   ; => 5
```

## Set Operations

### `list/diff`

Return elements in the first list that are not in the second list.

```scheme
(list/diff '(1 2 3 4 5) '(3 4))   ; => (1 2 5)
```

### `list/intersect`

Return elements present in both lists.

```scheme
(list/intersect '(1 2 3 4 5) '(3 4 6))   ; => (3 4)
```

### `list/duplicates`

Return values that appear more than once in a list.

```scheme
(list/duplicates '(1 2 2 3 3 3 4))   ; => (2 3)
```

## Extraction

### `list/pluck`

Extract a specific key from each map in a list.

```scheme
(define people (list {:name "Alice" :age 30} {:name "Bob" :age 25}))
(list/pluck :name people)   ; => ("Alice" "Bob")
```

### `list/key-by`

Transform a list of maps into a map keyed by a function result.

```scheme
(list/key-by (fn (p) (get p :id)) people)   ; => map keyed by :id
```

## Statistics

### `list/avg`

Return the average of a numeric list.

```scheme
(list/avg '(2 4 6))   ; => 4.0
```

### `list/median`

Return the statistical median.

```scheme
(list/median '(3 1 2))     ; => 2.0
(list/median '(1 2 3 4))   ; => 2.5
```

### `list/mode`

Return the most frequent value. If tied, returns a list.

```scheme
(list/mode '(1 2 2 3 3 3))   ; => 3
(list/mode '(1 1 2 2))       ; => (1 2)
```

## Windowing

### `list/sliding`

Create a sliding window over a list. Optional step parameter.

```scheme
(list/sliding '(1 2 3 4 5) 2)     ; => ((1 2) (2 3) (3 4) (4 5))
(list/sliding '(1 2 3 4 5 6) 2 3) ; => ((1 2) (4 5))
```

### `list/page`

Paginate a list. `(list/page items page per-page)` â€” 1-indexed pages.

```scheme
(list/page (range 20) 1 5)   ; => (0 1 2 3 4)
(list/page (range 20) 2 5)   ; => (5 6 7 8 9)
```

### `list/cross-join`

Cartesian product of two lists.

```scheme
(list/cross-join '(1 2) '(3 4))   ; => ((1 3) (1 4) (2 3) (2 4))
```

## Padding & Joining

### `list/pad`

Pad a list to a target length with a fill value.

```scheme
(list/pad '(1 2 3) 5 0)   ; => (1 2 3 0 0)
```

### `list/join`

Join list elements into a string. Optional final separator.

```scheme
(list/join '(1 2 3) ", ")             ; => "1, 2, 3"
(list/join '(1 2 3) ", " " and ")     ; => "1, 2 and 3"
```

## Generation

### `list/times`

Generate a list by calling a function N times with the index (0-based).

```scheme
(list/times 5 (fn (i) (* i i)))   ; => (0 1 4 9 16)
```

## Utility

### `tap`

Apply a side-effect function to a value, then return the original value.

```scheme
(tap 42 (fn (x) (println x)))   ; prints 42, returns 42
```

---


# Vectors

Vectors are fixed-size, indexed collections written with bracket syntax. Most list functions also work on vectors.

## Literal Syntax

Vectors use square brackets:

```scheme
[1 2 3]              ; a vector of three integers
["a" "b" "c"]        ; a vector of strings
[]                   ; empty vector
[1 [2 3] 4]          ; nested vectors
```

## Construction

### `vector`

Create a vector from arguments.

```scheme
(vector 1 2 3)       ; => [1 2 3]
(vector)             ; => []
(vector "a" "b")     ; => ["a" "b"]
```

## Conversion

### `vector->list`

Convert a vector to a list.

```scheme
(vector->list [1 2 3])   ; => (1 2 3)
(vector->list [])         ; => ()
```

### `list->vector`

Convert a list to a vector.

```scheme
(list->vector '(1 2 3))   ; => [1 2 3]
(list->vector '())         ; => []
```

## Using List Functions with Vectors

Most list functions work seamlessly with vectors:

```scheme
(map (fn (x) (* x x)) [1 2 3])     ; => (1 4 9)
(filter even? [1 2 3 4 5])          ; => (2 4)
(length [1 2 3])                    ; => 3
(nth [10 20 30] 1)                  ; => 20
(first [1 2 3])                     ; => 1
(rest [1 2 3])                      ; => (2 3)
(reverse [1 2 3])                   ; => (3 2 1)
```

---


# Maps & HashMaps

Sema provides two map types: sorted **maps** (BTreeMap-backed, deterministic ordering) and **hashmaps** (for O(1) performance-critical lookups).

## Maps

Maps use curly-brace literal syntax with keyword keys:

```scheme
{:name "Ada" :age 36}   ; map literal
{:a 1 :b 2 :c 3}       ; keywords as keys
```

Keywords are callable â€” when used as a function, they look up their value in a map:

```scheme
(:name {:name "Ada" :age 36})   ; => "Ada"
```

### `hash-map`

Create a map from key-value pairs.

```scheme
(hash-map :a 1 :b 2)   ; => {:a 1 :b 2}
```

### `get`

Look up a value by key. Works on both maps and hashmaps.

```scheme
(get {:a 1 :b 2} :a)   ; => 1
(get {:a 1 :b 2} :z)   ; => nil
```

### `assoc`

Add or update a key-value pair, returning a new map.

```scheme
(assoc {:a 1} :b 2)     ; => {:a 1 :b 2}
(assoc {:a 1} :a 99)    ; => {:a 99}
```

### `dissoc`

Remove a key, returning a new map. Works on both maps and hashmaps.

```scheme
(dissoc {:a 1 :b 2} :a)                     ; => {:b 2}
(dissoc (hashmap/new :a 1 :b 2) :a)         ; hashmap without :a
```

### `merge`

Merge multiple maps together. Later maps override earlier ones. Works on both maps and hashmaps â€” the result type matches the first argument.

```scheme
(merge {:a 1} {:b 2} {:c 3})   ; => {:a 1 :b 2 :c 3}
(merge {:a 1} {:a 99})         ; => {:a 99}
(merge (hashmap/new :a 1) {:b 2})  ; hashmap with :a and :b
```

### `keys`

Return the keys of a map as a list.

```scheme
(keys {:a 1 :b 2})   ; => (:a :b)
```

### `vals`

Return the values of a map as a list.

```scheme
(vals {:a 1 :b 2})   ; => (1 2)
```

### `contains?`

Test if a map contains a key.

```scheme
(contains? {:a 1} :a)   ; => #t
(contains? {:a 1} :b)   ; => #f
```

### `count`

Return the number of key-value pairs.

```scheme
(count {:a 1 :b 2})   ; => 2
```

### `map/entries`

Return the entries as a list of key-value pairs.

```scheme
(map/entries {:a 1 :b 2})   ; => ((:a 1) (:b 2))
```

### `map/from-entries`

Create a map from a list of key-value pairs.

```scheme
(map/from-entries '((:a 1) (:b 2)))   ; => {:a 1 :b 2}
```

## Higher-Order Map Operations

### `map/map-vals`

Apply a function to every value in a map.

```scheme
(map/map-vals (fn (v) (* v 2)) {:a 1 :b 2})   ; => {:a 2 :b 4}
```

### `map/map-keys`

Apply a function to every key in a map.

```scheme
(map/map-keys
  (fn (k) (string->keyword (string/upper (keyword->string k))))
  {:a 1})
; => {:A 1}
```

### `map/filter`

Filter entries by a predicate that takes key and value.

```scheme
(map/filter (fn (k v) (> v 1)) {:a 1 :b 2 :c 3})   ; => {:b 2 :c 3}
```

### `map/select-keys`

Select only the given keys from a map.

```scheme
(map/select-keys {:a 1 :b 2 :c 3} '(:a :c))   ; => {:a 1 :c 3}
```

### `map/update`

Update a value at a key by applying a function.

```scheme
(map/update {:a 1} :a (fn (v) (+ v 10)))   ; => {:a 11}
```

## HashMaps

For performance-critical workloads with many keys, use `hashmap` for O(1) lookups instead of the sorted `map`.

### `hashmap/new`

Create a new hashmap from key-value pairs.

```scheme
(hashmap/new :a 1 :b 2 :c 3)   ; create a hashmap
(hashmap/new)                    ; empty hashmap
```

### `hashmap/get`

Look up a value in a hashmap.

```scheme
(hashmap/get (hashmap/new :a 1) :a)   ; => 1
```

### `hashmap/assoc`

Add a key-value pair to a hashmap.

```scheme
(hashmap/assoc (hashmap/new) :a 1)   ; hashmap with :a 1
```

### `hashmap/to-map`

Convert a hashmap to a sorted map.

```scheme
(hashmap/to-map (hashmap/new :b 2 :a 1))   ; => {:a 1 :b 2}
```

### `hashmap/keys`

Return the keys of a hashmap (unordered).

```scheme
(hashmap/keys (hashmap/new :a 1 :b 2))   ; => (:a :b)
```

### `hashmap/contains?`

Test if a hashmap contains a key.

```scheme
(hashmap/contains? (hashmap/new :a 1) :a)   ; => #t
```

### Generic Operations on HashMaps

The generic functions `get`, `assoc`, `dissoc`, `keys`, `vals`, `merge`, `count`, `contains?`, and all `map/*` higher-order operations also work on hashmaps, preserving the hashmap type:

```scheme
(get (hashmap/new :a 1 :b 2) :a)       ; => 1
(assoc (hashmap/new) :x 42)            ; hashmap with :x 42
(dissoc (hashmap/new :a 1 :b 2) :a)    ; hashmap without :a
(merge (hashmap/new :a 1) {:b 2})      ; hashmap with :a and :b
(count (hashmap/new :a 1 :b 2))        ; => 2
(map/map-vals (fn (v) (* v 2)) (hashmap/new :a 1))  ; hashmap with :a 2
(map/filter (fn (k v) (> v 1)) (hashmap/new :a 1 :b 2))  ; hashmap with :b
```

### `map/sort-keys`

Sort a map by its keys. Converts hashmaps to sorted maps.

```scheme
(map/sort-keys (hashmap/new :c 3 :a 1 :b 2))   ; => {:a 1 :b 2 :c 3}
```

### `map/except`

Remove specified keys from a map (inverse of `map/select-keys`).

```scheme
(map/except {:a 1 :b 2 :c 3} '(:b))       ; => {:a 1 :c 3}
(map/except {:a 1 :b 2 :c 3} '(:a :c))    ; => {:b 2}
```

### `map/zip`

Create a map from a list of keys and a list of values.

```scheme
(map/zip '(:a :b :c) '(1 2 3))   ; => {:a 1 :b 2 :c 3}
```

---


# Predicates & Type Checking

Predicates return `#t` or `#f` and conventionally end with `?`.

## Emptiness Predicates

### `null?`

Test if a value is the empty list.

```scheme
(null? '())    ; => #t
(null? '(1))   ; => #f
```

### `nil?`

Test if a value is `nil`.

```scheme
(nil? nil)     ; => #t
(nil? 0)       ; => #f
```

### `empty?`

Test if a collection or string is empty.

```scheme
(empty? "")        ; => #t
(empty? '())       ; => #t
(empty? "hello")   ; => #f
```

## Collection Predicates

### `list?`

Test if a value is a list.

```scheme
(list? '(1))    ; => #t
(list? 42)      ; => #f
```

### `pair?`

Test if a value is a non-empty list (Scheme compatibility).

```scheme
(pair? '(1 2))   ; => #t
(pair? '())      ; => #f
```

### `vector?`

Test if a value is a vector.

```scheme
(vector? [1])   ; => #t
(vector? '(1))  ; => #f
```

### `map?`

Test if a value is a map.

```scheme
(map? {:a 1})   ; => #t
(map? '())      ; => #f
```

## Numeric Predicates

### `number?`

Test if a value is a number (integer or float).

```scheme
(number? 42)     ; => #t
(number? 3.14)   ; => #t
(number? "42")   ; => #f
```

### `integer?`

Test if a value is an integer.

```scheme
(integer? 42)     ; => #t
(integer? 3.14)   ; => #f
```

### `float?`

Test if a value is a floating-point number.

```scheme
(float? 3.14)   ; => #t
(float? 42)     ; => #f
```

### `zero?`

Test if a number is zero.

```scheme
(zero? 0)   ; => #t
(zero? 1)   ; => #f
```

### `even?`

Test if an integer is even.

```scheme
(even? 4)   ; => #t
(even? 3)   ; => #f
```

### `odd?`

Test if an integer is odd.

```scheme
(odd? 3)   ; => #t
(odd? 4)   ; => #f
```

### `positive?`

Test if a number is positive.

```scheme
(positive? 1)    ; => #t
(positive? -1)   ; => #f
```

### `negative?`

Test if a number is negative.

```scheme
(negative? -1)   ; => #t
(negative? 1)    ; => #f
```

## Type Predicates

### `string?`

Test if a value is a string.

```scheme
(string? "hi")   ; => #t
(string? 42)     ; => #f
```

### `symbol?`

Test if a value is a symbol.

```scheme
(symbol? 'x)     ; => #t
(symbol? "x")    ; => #f
```

### `keyword?`

Test if a value is a keyword.

```scheme
(keyword? :k)    ; => #t
(keyword? "k")   ; => #f
```

### `char?`

Test if a value is a character.

```scheme
(char? #\a)      ; => #t
(char? "a")      ; => #f
```

### `bool?`

Test if a value is a boolean. `boolean?` is an alias.

```scheme
(bool? #t)   ; => #t
(bool? 0)    ; => #f
```

### `fn?`

Test if a value is a function. `procedure?` is an alias.

```scheme
(fn? car)        ; => #t
(fn? 42)         ; => #f
```

### `record?`

Test if a value is a record instance.

```scheme
(record? my-record)   ; => #t
(record? 42)          ; => #f
```

### `bytevector?`

Test if a value is a bytevector.

```scheme
(bytevector? #u8())   ; => #t
(bytevector? '())     ; => #f
```

## Promise Predicates

### `promise?`

Test if a value is a promise (created with `delay`).

```scheme
(promise? (delay 1))   ; => #t
(promise? 42)          ; => #f
```

### `promise-forced?`

Test if a promise has been forced (evaluated).

```scheme
(define p (delay (+ 1 2)))
(promise-forced? p)   ; => #f
(force p)
(promise-forced? p)   ; => #t
```

## Equality

### `eq?`

Test structural equality. `equal?` is an alias.

```scheme
(eq? 'a 'a)           ; => #t
(eq? '(1 2) '(1 2))   ; => #t
(eq? 1 2)             ; => #f
```

### `=`

Numeric equality.

```scheme
(= 1 1)       ; => #t
(= 1 1.0)     ; => #t
(= 1 2)       ; => #f
```

## LLM Type Predicates

### `prompt?`

Test if a value is an LLM prompt.

```scheme
(prompt? (prompt (user "hi")))   ; => #t
```

### `message?`

Test if a value is an LLM message.

```scheme
(message? (message :user "hi"))   ; => #t
```

### `conversation?`

Test if a value is a conversation.

```scheme
(conversation? (conversation/new {}))   ; => #t
```

### `tool?`

Test if a value is a tool definition.

```scheme
(deftool my-tool "A test tool" {:x {:type :string}} (lambda (x) x))
(tool? my-tool)   ; => #t
(tool? 42)        ; => #f
```

### `agent?`

Test if a value is an agent.

```scheme
(defagent my-agent {:system "test"})
(agent? my-agent)   ; => #t
(agent? 42)         ; => #f
```

---


# File I/O & Paths

## Console I/O

### `display`

Print a value without a trailing newline.

```scheme
(display "no newline")
(display 42)
```

### `println`

Print a value followed by a newline.

```scheme
(println "with newline")
(println 42)
```

### `print`

Alias for `display`. Print without a trailing newline.

```scheme
(print "also no newline")
```

### `print-error`

Print to stderr without a trailing newline.

```scheme
(print-error "warning: something happened")
```

### `println-error`

Print to stderr with a trailing newline.

```scheme
(println-error "error: file not found")
```

### `newline`

Print a newline character.

```scheme
(newline)
```

### `read-line`

Read a line of input from stdin.

```scheme
(define name (read-line))
```

### `read-stdin`

Read all of stdin as a string (until EOF).

```scheme
(define input (read-stdin))
```

## File Operations

### `file/read`

Read the entire contents of a file as a string.

```scheme
(file/read "data.txt")   ; => "file contents..."
```

### `file/write`

Write a string to a file, overwriting any existing content.

```scheme
(file/write "out.txt" "content")
```

### `file/append`

Append a string to a file.

```scheme
(file/append "log.txt" "new line\n")
```

### `file/read-lines`

Read a file as a list of lines.

```scheme
(file/read-lines "data.txt")   ; => ("line 1" "line 2" "line 3")
```

### `file/write-lines`

Write a list of strings to a file, one per line.

```scheme
(file/write-lines "out.txt" '("a" "b" "c"))
```

### `file/for-each-line`

Iterate over lines of a file, calling a function on each line. Memory-efficient for large files.

```scheme
(file/for-each-line "data.txt"
  (fn (line) (println line)))
```

### `file/fold-lines`

Fold over lines of a file with an accumulator. Uses a 256KB buffer for high throughput on large files.

```scheme
(file/fold-lines "data.csv"
  (fn (acc line) (+ acc 1))
  0)
; => number of lines
```

### `file/delete`

Delete a file.

```scheme
(file/delete "tmp.txt")
```

### `file/rename`

Rename or move a file.

```scheme
(file/rename "old.txt" "new.txt")
```

### `file/copy`

Copy a file.

```scheme
(file/copy "src.txt" "dst.txt")
```

## Binary File I/O

### `file/read-bytes`

Read a file as a bytevector (binary data).

```scheme
(file/read-bytes "image.png")   ; => #u8(137 80 78 71 ...)
```

### `file/write-bytes`

Write a bytevector to a file.

```scheme
(file/write-bytes "output.bin" my-bytes)
```

## File Predicates

### `file/exists?`

Test if a file or directory exists.

```scheme
(file/exists? "data.txt")   ; => #t or #f
```

### `file/is-file?`

Test if a path is a regular file.

```scheme
(file/is-file? "data.txt")   ; => #t
```

### `file/is-directory?`

Test if a path is a directory.

```scheme
(file/is-directory? "src/")   ; => #t
```

### `file/is-symlink?`

Test if a path is a symbolic link.

```scheme
(file/is-symlink? "link")   ; => #t or #f
```

## Directory Operations

### `file/list`

List entries in a directory.

```scheme
(file/list "src/")   ; => ("main.rs" "lib.rs" ...)
```

### `file/mkdir`

Create a directory.

```scheme
(file/mkdir "new-dir")
```

### `file/glob`

Find files matching a glob pattern.

```scheme
(file/glob "src/**/*.rs")      ; => ("src/main.rs" "src/lib.rs" ...)
(file/glob "*.txt")            ; => ("readme.txt" "notes.txt")
```

### `file/info`

Get file metadata. Returns a map with `:size`, `:modified`, and other keys.

```scheme
(file/info "data.txt")   ; => {:size 1234 :modified 1707955200 ...}
```

## Path Manipulation

### `path/join`

Join path components.

```scheme
(path/join "src" "main.rs")   ; => "src/main.rs"
(path/join "a" "b" "c.txt")  ; => "a/b/c.txt"
```

### `path/dirname`

Return the directory portion of a path.

```scheme
(path/dirname "/a/b/c.txt")   ; => "/a/b"
```

### `path/basename`

Return the filename portion of a path.

```scheme
(path/basename "/a/b/c.txt")   ; => "c.txt"
```

### `path/extension`

Return the file extension (without the dot).

```scheme
(path/extension "file.rs")     ; => "rs"
(path/extension "Makefile")    ; => ""
```

### `path/absolute`

Return the absolute path.

```scheme
(path/absolute ".")   ; => "/full/path/to/current/dir"
```

### `path/ext`

Return the file extension (without the dot).

```scheme
(path/ext "file.rs")     ; => "rs"
(path/ext "Makefile")    ; => ""
```

### `path/stem`

Return the filename without extension.

```scheme
(path/stem "file.rs")      ; => "file"
(path/stem "archive.tar.gz")  ; => "archive.tar"
```

### `path/dir`

Return the directory portion of a path.

```scheme
(path/dir "/a/b/c.txt")   ; => "/a/b"
```

### `path/filename`

Return the filename portion of a path.

```scheme
(path/filename "/a/b/c.txt")   ; => "c.txt"
```

### `path/absolute?`

Test if a path is absolute.

```scheme
(path/absolute? "/usr/bin")   ; => #t
(path/absolute? "relative")  ; => #f
```

---


# PDF Processing

Pure-Rust PDF text extraction, page counting, and metadata reading. No external tools required â€” works cross-platform including macOS, Linux, and Windows.

::: tip
These functions use the `pdf-extract` and `lopdf` Rust crates internally. They work with text-based PDFs. For scanned/image-only PDFs, consider using [`llm/extract-from-image`](/docs/llm/extraction) with vision models instead.
:::

## Text Extraction

### `pdf/extract-text`

Extract all text from a PDF file, concatenated across all pages.

```scheme
(pdf/extract-text "invoice.pdf")
; => "Invoice\nDate: 2025-01-15\nAmount: $50.00 USD\n..."

;; Clean up whitespace for LLM processing
(text/clean-whitespace (pdf/extract-text "invoice.pdf"))
; => "Invoice Date: 2025-01-15 Amount: $50.00 USD ..."
```

### `pdf/extract-text-pages`

Extract text from a PDF, returning a list of strings â€” one per page.

```scheme
(pdf/extract-text-pages "report.pdf")
; => ("Page 1 content..." "Page 2 content..." "Page 3 content...")

;; Get text from a specific page
(nth (pdf/extract-text-pages "report.pdf") 0)
; => "Page 1 content..."

;; Process each page separately
(for-each
  (fn (page-text)
    (println (format "Page has ~a words" (text/word-count page-text))))
  (pdf/extract-text-pages "report.pdf"))
```

## Metadata

### `pdf/page-count`

Return the number of pages in a PDF.

```scheme
(pdf/page-count "report.pdf")
; => 12
```

### `pdf/metadata`

Return a map of PDF metadata fields. Always includes `:pages`; other fields (`:title`, `:author`, `:subject`, `:creator`, `:producer`) are included when present in the PDF.

```scheme
(pdf/metadata "document.pdf")
; => {:author "John Doe" :pages 5 :producer "LibreOffice" :title "Quarterly Report"}

;; Access individual fields
(get (pdf/metadata "document.pdf") :title)
; => "Quarterly Report"

(get (pdf/metadata "document.pdf") :pages)
; => 5
```

## Example: Receipt Processor

Combine PDF extraction with [LLM structured extraction](/docs/llm/extraction) to build an intelligent document processor:

```scheme
;; Extract text from a PDF invoice
(define text (text/clean-whitespace (pdf/extract-text "invoice.pdf")))
(define pages (pdf/page-count "invoice.pdf"))
(println (format "Extracted ~a chars from ~a page(s)" (string-length text) pages))

;; Use LLM to classify and extract structured data
(llm/auto-configure)
(define result
  (llm/extract
    {:isReceipt {:type :boolean :description "Is this a receipt or invoice?"}
     :vendor {:type :string :description "The seller/merchant name"}
     :amount {:type :string :description "Total amount with currency"}
     :date {:type :string :description "Invoice date in YYYY-MM-DD format"}}
    text))

(println (format "Vendor: ~a" (get result :vendor)))
(println (format "Amount: ~a" (get result :amount)))
```

See the full [GLaDOS receipt processor example](https://github.com/helgesverre/sema/blob/main/examples/glados-downloads.sema) for a complete implementation.

---


# HTTP & JSON

## HTTP

HTTP functions make synchronous requests and return a map with `:status`, `:headers`, and `:body` keys.

### `http/get`

Make an HTTP GET request.

```scheme
(http/get "https://httpbin.org/get")
; => {:status 200 :headers {...} :body "..."}
```

### `http/post`

Make an HTTP POST request. Maps in `:body` are automatically serialized as JSON.

```scheme
(http/post "https://httpbin.org/post"
  {:body {:key "value"}
   :headers {"Authorization" "Bearer ..."}})
; => {:status 200 :headers {...} :body "..."}
```

### `http/put`

Make an HTTP PUT request.

```scheme
(http/put "https://example.com/resource"
  {:body "data"})
```

### `http/delete`

Make an HTTP DELETE request.

```scheme
(http/delete "https://example.com/resource/123")
```

### `http/request`

Make a generic HTTP request with full control over method and options.

```scheme
(http/request "PATCH" "https://example.com/resource"
  {:headers {"Content-Type" "text/plain"}}
  "data")
```

## JSON

### `json/encode`

Encode a Sema value as a JSON string.

```scheme
(json/encode {:name "Ada" :age 36})
; => "{\"age\":36,\"name\":\"Ada\"}"

(json/encode [1 2 3])
; => "[1,2,3]"
```

### `json/encode-pretty`

Encode a Sema value as a pretty-printed JSON string.

```scheme
(json/encode-pretty {:a 1 :b [2 3]})
; => "{\n  \"a\": 1,\n  \"b\": [\n    2,\n    3\n  ]\n}"
```

### `json/decode`

Decode a JSON string into a Sema value.

```scheme
(json/decode "{\"name\":\"Ada\"}")   ; => {:name "Ada"}
(json/decode "[1,2,3]")             ; => (1 2 3)
```

---


# Regex

Regular expression functions for pattern matching, searching, and replacement. Patterns use Rust regex syntax.

## Matching

### `regex/match?`

Test if a pattern matches anywhere in a string. Returns `#t` or `#f`.

```scheme
(regex/match? "\\d+" "abc123")     ; => #t
(regex/match? "\\d+" "no digits")  ; => #f
```

### `regex/match`

Match a pattern and return the full match plus any capture groups as a list. Returns `#f` if no match.

```scheme
(regex/match "^(\\w+)@(\\w+)" "user@host")
; => ("user@host" "user" "host")

(regex/match "(\\d+)-(\\d+)" "2025-01")
; => ("2025-01" "2025" "01")

(regex/match "xyz" "abc")
; => #f
```

### `regex/find-all`

Find all non-overlapping matches of a pattern.

```scheme
(regex/find-all "\\d+" "a1b2c3")    ; => ("1" "2" "3")
(regex/find-all "[A-Z]" "Hello World")  ; => ("H" "W")
```

## Replacement

### `regex/replace`

Replace the first match of a pattern.

```scheme
(regex/replace "\\d" "a1b2" "X")   ; => "aXb2"
```

### `regex/replace-all`

Replace all matches of a pattern.

```scheme
(regex/replace-all "\\d" "a1b2" "X")   ; => "aXbX"
(regex/replace-all "\\s+" "a  b  c" " ")  ; => "a b c"
```

## Splitting

### `regex/split`

Split a string by a regex pattern.

```scheme
(regex/split "," "a,b,c")          ; => ("a" "b" "c")
(regex/split "\\s+" "hello  world")  ; => ("hello" "world")
```

---


# CSV, Crypto & Encoding

## CSV

### `csv/parse`

Parse a CSV string into a list of lists (rows of fields).

```scheme
(csv/parse "a,b\n1,2\n3,4")
; => (("a" "b") ("1" "2") ("3" "4"))
```

### `csv/parse-maps`

Parse a CSV string into a list of maps, using the first row as keys.

```scheme
(csv/parse-maps "name,age\nAda,36\nBob,25")
; => ({:age "36" :name "Ada"} {:age "25" :name "Bob"})
```

### `csv/encode`

Encode a list of lists into a CSV string.

```scheme
(csv/encode '(("a" "b") ("1" "2")))
; => "a,b\n1,2\n"
```

## UUID

### `uuid/v4`

Generate a random UUID v4 string.

```scheme
(uuid/v4)   ; => "550e8400-e29b-41d4-a716-446655440000" (varies)
```

## Base64 Encoding

### `base64/encode`

Encode a string to Base64.

```scheme
(base64/encode "hello")   ; => "aGVsbG8="
(base64/encode "")        ; => ""
```

### `base64/decode`

Decode a Base64 string.

```scheme
(base64/decode "aGVsbG8=")   ; => "hello"
```

### `base64/encode-bytes`

Encode a bytevector to Base64.

```scheme
(base64/encode-bytes (file/read-bytes "image.png"))   ; => "iVBORw0KGgo..."
```

### `base64/decode-bytes`

Decode a Base64 string to a bytevector.

```scheme
(base64/decode-bytes "aGVsbG8=")   ; => #u8(104 101 108 108 111)
```

## Hashing

### `hash/sha256`

Compute the SHA-256 hash of a string. Returns a hex-encoded string.

```scheme
(hash/sha256 "hello")   ; => "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
```

### `hash/md5`

Compute the MD5 hash of a string. Returns a hex-encoded string.

```scheme
(hash/md5 "hello")   ; => "5d41402abc4b2a76b9719d911017c592"
```

### `hash/hmac-sha256`

Compute an HMAC-SHA256 of a message with a secret key. Returns a hex-encoded string.

```scheme
(hash/hmac-sha256 "secret-key" "message")   ; => "hex-encoded-hmac..."
```

---


# Date & Time

## Current Time

### `time/now`

Return the current time as a Unix timestamp in seconds (with fractional milliseconds).

```scheme
(time/now)   ; => 1707955200.123
```

### `time-ms`

Return the current time as Unix milliseconds (integer).

```scheme
(time-ms)   ; => 1707955200123
```

## Formatting & Parsing

### `time/format`

Format a Unix timestamp using a format string. Uses `strftime`-style directives.

```scheme
(time/format (time/now) "%Y-%m-%d")        ; => "2025-02-15"
(time/format (time/now) "%H:%M:%S")        ; => "14:30:00"
(time/format (time/now) "%Y-%m-%d %H:%M")  ; => "2025-02-15 14:30"
```

### `time/parse`

Parse a date string into a Unix timestamp using a format string.

```scheme
(time/parse "2025-01-15" "%Y-%m-%d")        ; => 1736899200.0
(time/parse "2025-01-15 10:30" "%Y-%m-%d %H:%M")
```

## Date Decomposition

### `time/date-parts`

Decompose a Unix timestamp into a map of date/time components.

```scheme
(time/date-parts (time/now))
; => {:year 2025 :month 2 :day 15 :hour 14 :minute 30 :second 0 ...}
```

## Arithmetic

### `time/add`

Add seconds to a timestamp.

```scheme
(time/add (time/now) 86400)     ; one day later
(time/add (time/now) 3600)      ; one hour later
(time/add (time/now) -86400)    ; one day earlier
```

### `time/diff`

Compute the difference between two timestamps in seconds.

```scheme
(define t1 (time/now))
;; ... some work ...
(define t2 (time/now))
(time/diff t1 t2)   ; => elapsed seconds
```

## Delay

### `sleep`

Sleep for a given number of milliseconds.

```scheme
(sleep 1000)   ; sleep for 1 second
(sleep 500)    ; sleep for 500ms
```

---


# System

## Environment Variables

### `env`

Get the value of an environment variable. Returns `nil` if not set.

```scheme
(env "HOME")       ; => "/Users/ada"
(env "PATH")       ; => "/usr/bin:/bin:..."
(env "MISSING")    ; => nil
```

### `sys/env-all`

Return all environment variables as a map.

```scheme
(sys/env-all)   ; => {:HOME "/Users/ada" :PATH "..." ...}
```

### `sys/set-env`

Set an environment variable for the current process.

```scheme
(sys/set-env "KEY" "value")
(env "KEY")   ; => "value"
```

## System Information

### `sys/args`

Return the command-line arguments as a list.

```scheme
(sys/args)   ; => ("sema" "script.sema" "--flag")
```

### `sys/cwd`

Return the current working directory.

```scheme
(sys/cwd)   ; => "/current/dir"
```

### `sys/platform`

Return the platform name.

```scheme
(sys/platform)   ; => "macos" / "linux" / "windows"
```

### `sys/os`

Return the operating system name.

```scheme
(sys/os)   ; => "macos"
```

### `sys/arch`

Return the CPU architecture.

```scheme
(sys/arch)   ; => "aarch64" / "x86_64"
```

## Process Information

### `sys/pid`

Return the current process ID.

```scheme
(sys/pid)   ; => 12345
```

### `sys/tty`

Return the TTY device path, or `nil` if not running in a terminal.

```scheme
(sys/tty)   ; => "/dev/ttys003" or nil
```

### `sys/which`

Find the full path to an executable, or `nil` if not found.

```scheme
(sys/which "cargo")   ; => "/Users/ada/.cargo/bin/cargo"
(sys/which "nonexistent")  ; => nil
```

### `sys/elapsed`

Return nanoseconds elapsed since the process started.

```scheme
(sys/elapsed)   ; => 482937100
```

## Session Information

### `sys/interactive?`

Test if stdin is a TTY (i.e., running interactively).

```scheme
(sys/interactive?)   ; => #t in REPL, #f in scripts
```

### `sys/hostname`

Return the system hostname.

```scheme
(sys/hostname)   ; => "my-machine"
```

### `sys/user`

Return the current username.

```scheme
(sys/user)   ; => "ada"
```

## Directory Paths

### `sys/home-dir`

Return the user's home directory.

```scheme
(sys/home-dir)   ; => "/Users/ada"
```

### `sys/temp-dir`

Return the system temporary directory.

```scheme
(sys/temp-dir)   ; => "/tmp"
```

## Shell & Process Control

### `shell`

Run a shell command and return its stdout as a string.

```scheme
(shell "ls -la")       ; => "total 42\n..."
(shell "echo hello")   ; => "hello\n"
```

### `exit`

Exit the process with a given status code.

```scheme
(exit 0)   ; exit successfully
(exit 1)   ; exit with error
```

---


# Bytevectors

Bytevectors are sequences of unsigned 8-bit integers (0â€“255), useful for binary data and string encoding.

## Literal Syntax

```scheme
#u8(1 2 3)       ; bytevector literal
#u8()            ; empty bytevector
#u8(255 0 128)   ; arbitrary byte values
```

## Construction

### `bytevector`

Create a bytevector from byte values.

```scheme
(bytevector 1 2 3)       ; => #u8(1 2 3)
(bytevector)             ; => #u8()
```

### `make-bytevector`

Create a bytevector of a given length, optionally filled with a value.

```scheme
(make-bytevector 4)       ; => #u8(0 0 0 0)
(make-bytevector 3 255)   ; => #u8(255 255 255)
```

## Access & Mutation

### `bytevector-length`

Return the length of a bytevector.

```scheme
(bytevector-length #u8(1 2 3))   ; => 3
(bytevector-length #u8())        ; => 0
```

### `bytevector-u8-ref`

Return the byte at a given index.

```scheme
(bytevector-u8-ref #u8(10 20 30) 1)   ; => 20
(bytevector-u8-ref #u8(10 20 30) 0)   ; => 10
```

### `bytevector-u8-set!`

Set the byte at a given index. Uses copy-on-write â€” the original bytevector is unchanged.

```scheme
(bytevector-u8-set! #u8(1 2 3) 0 9)   ; => #u8(9 2 3)
```

## Copy & Append

### `bytevector-copy`

Copy a slice of a bytevector. `(bytevector-copy bv start end)`.

```scheme
(bytevector-copy #u8(1 2 3 4 5) 1 3)   ; => #u8(2 3)
```

### `bytevector-append`

Concatenate bytevectors.

```scheme
(bytevector-append #u8(1 2) #u8(3 4))   ; => #u8(1 2 3 4)
```

## List Conversion

### `bytevector->list`

Convert a bytevector to a list of integers.

```scheme
(bytevector->list #u8(65 66))   ; => (65 66)
```

### `list->bytevector`

Convert a list of integers to a bytevector.

```scheme
(list->bytevector '(1 2 3))   ; => #u8(1 2 3)
```

## String Conversion

### `utf8->string`

Decode a bytevector as a UTF-8 string.

```scheme
(utf8->string #u8(104 105))       ; => "hi"
(utf8->string #u8(72 101 108))    ; => "Hel"
```

### `string->utf8`

Encode a string as a UTF-8 bytevector.

```scheme
(string->utf8 "hi")     ; => #u8(104 105)
(string->utf8 "Hello")  ; => #u8(72 101 108 108 111)
```

---


# Records

Records are user-defined data types with named fields, created via the `define-record-type` special form. They provide constructors, type predicates, and field accessors.

## Defining Record Types

### `define-record-type`

Define a new record type with a constructor, predicate, and field accessors.

```scheme
(define-record-type point
  (make-point x y)       ; constructor
  point?                  ; predicate
  (x point-x)            ; field name and accessor
  (y point-y))
```

The syntax is:

```scheme
(define-record-type <type-name>
  (<constructor> <field-name> ...)
  <predicate>
  (<field-name> <accessor>) ...)
```

This defines:

- **Constructor** â€” `make-point` creates a new point record
- **Predicate** â€” `point?` tests if a value is a point
- **Accessors** â€” `point-x` and `point-y` extract field values

## Usage

```scheme
(define-record-type point
  (make-point x y)
  point?
  (x point-x)
  (y point-y))

(define p (make-point 3 4))

(point? p)       ; => #t
(point? 42)      ; => #f
(point-x p)      ; => 3
(point-y p)      ; => 4
```

## Equality

Records support structural equality with `equal?` â€” two records of the same type with equal fields are equal.

```scheme
(equal? (make-point 1 2) (make-point 1 2))   ; => #t
(equal? (make-point 1 2) (make-point 3 4))   ; => #f
```

## Introspection

### `record?`

Test if a value is any record instance.

```scheme
(record? (make-point 3 4))   ; => #t
(record? 42)                 ; => #f
```

### `type`

Return the type tag of a record as a keyword.

```scheme
(type (make-point 3 4))   ; => :point
```

## Example: Multiple Record Types

```scheme
(define-record-type color
  (make-color r g b)
  color?
  (r color-r)
  (g color-g)
  (b color-b))

(define-record-type person
  (make-person name age)
  person?
  (name person-name)
  (age person-age))

(define red (make-color 255 0 0))
(define ada (make-person "Ada" 36))

(color? red)         ; => #t
(person? ada)        ; => #t
(color? ada)         ; => #f

(color-r red)        ; => 255
(person-name ada)    ; => "Ada"
(type red)           ; => :color
(type ada)           ; => :person
```

---


# Text Processing

Sema includes utilities for text chunking, cleaning, prompt templates, and structured documents â€” building blocks for LLM pipelines.

## Text Chunking

### `text/chunk`

Recursively split text into chunks, trying natural boundaries (paragraphs, sentences, words) before hard-splitting. Takes text and an optional options map.

```scheme
(text/chunk "Long text here...")
(text/chunk "Long text here..." {:size 500 :overlap 100})
```

Options: `:size` (default 1000), `:overlap` (default 200). Returns a list of strings.

### `text/chunk-by-separator`

Split text by a specific separator string.

```scheme
(text/chunk-by-separator "a\nb\nc" "\n")  ; => ("a" "b" "c")
```

### `text/split-sentences`

Split text into sentences at `.`, `!`, `?` boundaries.

```scheme
(text/split-sentences "Hello world. How are you? Fine.")
; => ("Hello world." "How are you?" "Fine.")
```

## Text Cleaning

### `text/clean-whitespace`

Collapse multiple whitespace characters (spaces, newlines, tabs) into single spaces.

```scheme
(text/clean-whitespace "  hello   world  \n\n  foo  ")
; => "hello world foo"
```

### `text/strip-html`

Remove HTML tags and decode common entities (`&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, `&apos;`, `&nbsp;`).

```scheme
(text/strip-html "<p>Hello <b>world</b></p>")  ; => "Hello world"
(text/strip-html "a &amp; b &lt; c")            ; => "a & b < c"
```

### `text/truncate`

Truncate text to a maximum length with a suffix. Takes text, max-length, and optional suffix (default `"..."`).

```scheme
(text/truncate "hello world" 5)       ; => "he..."
(text/truncate "hello world" 8 "â€¦")   ; => "hello wâ€¦"
(text/truncate "hi" 10)               ; => "hi"
```

### `text/word-count`

Count words in text (split by whitespace).

```scheme
(text/word-count "hello world foo bar")  ; => 4
```

### `text/trim-indent`

Remove common leading indentation from all lines.

```scheme
(text/trim-indent "    hello\n    world")   ; => "hello\nworld"
(text/trim-indent "    hello\n      world") ; => "hello\n  world"
```

### `text/excerpt`

Extract a snippet around a search term with omission markers. Case-insensitive search. Returns `nil` if query not found.

```scheme
(text/excerpt "The quick brown fox jumps over the lazy dog" "fox" {:radius 10})
; => "...brown fox jumps ov..."

(text/excerpt "Hello world" "Hello")
; => "Hello world"

;; Custom omission marker
(text/excerpt "Long text here..." "text" {:radius 5 :omission "[â€¦]"})
; => "[â€¦]g text here[â€¦]"
```

Options map (optional third argument):

- `:radius` â€” number of characters to show on each side (default: 100)
- `:omission` â€” marker string for truncated parts (default: `"..."`)

### `text/normalize-newlines`

Convert `\r\n` (Windows) and `\r` (old Mac) line endings to `\n` (Unix).

```scheme
(text/normalize-newlines "line1\r\nline2\rline3")
; => "line1\nline2\nline3"
```

## Prompt Templates

### `prompt/template`

Create a template string for use with `prompt/render`.

```scheme
(define tmpl (prompt/template "Hello {{name}}, welcome to {{place}}."))
```

### `prompt/render`

Render a template by substituting `{{key}}` placeholders with values from a map. Missing keys are left as-is.

```scheme
(prompt/render "Hello {{name}}, welcome to {{place}}."
  {:name "Alice" :place "Wonderland"})
; => "Hello Alice, welcome to Wonderland."

(prompt/render "Hello {{name}}, {{missing}}." {:name "Bob"})
; => "Hello Bob, {{missing}}."

;; Non-string values are stringified
(prompt/render "Count: {{n}}" {:n 42})
; => "Count: 42"
```

## Documents

Structured documents with metadata, designed for use with chunking and vector stores.

### `document/create`

Create a document map with `:text` and `:metadata`.

```scheme
(document/create "Hello world" {:source "test.txt" :page 1})
; => {:metadata {:page 1 :source "test.txt"} :text "Hello world"}
```

### `document/text`

Extract the text from a document.

```scheme
(document/text doc)  ; => "Hello world"
```

### `document/metadata`

Extract the metadata from a document.

```scheme
(document/metadata doc)  ; => {:source "test.txt" :page 1}
```

### `document/chunk`

Chunk a document, preserving and extending metadata. Each chunk gets `:chunk-index` and `:total-chunks` added to its metadata.

```scheme
(document/chunk
  (document/create "long text..." {:source "paper.pdf"})
  {:size 500})
; => ({:text "chunk 1..." :metadata {:source "paper.pdf" :chunk-index 0 :total-chunks 3}}
;     {:text "chunk 2..." :metadata {:source "paper.pdf" :chunk-index 1 :total-chunks 3}}
;     ...)
```

---


# Key-Value Store

Sema includes a persistent, JSON-backed key-value store for storing structured data across sessions. Data is automatically flushed to disk on every write.

::: tip
`kv/open`, `kv/set`, and `kv/delete` require filesystem write capabilities (they are gated by `FS_WRITE`).
:::

## Functions

### `kv/open`

Open (or create) a named KV store backed by a JSON file. If the file exists, its contents are loaded.

```scheme
(kv/open "config" "/path/to/config.json")
```

### `kv/get`

Get a value by key. Returns `nil` if the key doesn't exist.

```scheme
(kv/get "config" "api-key")  ; => "sk-..." or nil
```

### `kv/set`

Set a key-value pair. Values are serialized as JSON (strings, numbers, booleans, lists, maps are all supported). Returns the value.

```scheme
(kv/set "config" "api-key" "sk-...")
(kv/set "config" "retries" 3)
(kv/set "config" "tags" '("a" "b" "c"))
```

### `kv/delete`

Delete a key. Returns `#t` if the key existed, `#f` otherwise.

```scheme
(kv/delete "config" "api-key")  ; => #t
```

### `kv/keys`

List all keys in the store.

```scheme
(kv/keys "config")  ; => ("api-key" "retries" "tags")
```

### `kv/close`

Close a store, flushing any pending data.

```scheme
(kv/close "config")
```

## Example

```scheme
;; Create a persistent store for caching API results
(kv/open "cache" "api-cache.json")

;; Store some data
(kv/set "cache" "user:123" {:name "Alice" :email "alice@example.com"})
(kv/set "cache" "user:456" {:name "Bob" :email "bob@example.com"})

;; Retrieve it
(kv/get "cache" "user:123")
; => {:email "alice@example.com" :name "Alice"}

;; List keys
(kv/keys "cache")
; => ("user:123" "user:456")

;; Clean up
(kv/delete "cache" "user:123")
(kv/close "cache")
```

---


# Context

Sema provides an ambient context system â€” a key-value store that flows through your entire execution without explicit parameter passing. Inspired by [Laravel's Context](https://laravel.com/docs/12.x/context), it's designed for tracing, metadata propagation, and sharing configuration across deeply nested calls.

Context data is automatically appended as metadata to log output (`log/info`, `log/warn`, `log/error`, `log/debug`).

## Core Functions

### `context/set`

Set a key-value pair in the current context frame.

```scheme
(context/set :trace-id "abc-123")
(context/set :user-id 42)
```

### `context/get`

Retrieve a value by key. Returns `nil` if the key doesn't exist.

```scheme
(context/get :trace-id)   ; => "abc-123"
(context/get :missing)    ; => nil
```

### `context/has?`

Check if a key exists in the context.

```scheme
(context/has? :trace-id)  ; => #t
(context/has? :missing)   ; => #f
```

### `context/remove`

Remove a key from all context frames. Returns the removed value, or `nil`.

```scheme
(context/set :temp "data")
(context/remove :temp)    ; => "data"
(context/remove :temp)    ; => nil (already gone)
```

### `context/pull`

Get a value and remove it in one step (identical to `context/remove`).

```scheme
(context/set :token "abc")
(context/pull :token)     ; => "abc"
(context/has? :token)     ; => #f
```

### `context/all`

Get all context as a merged map.

```scheme
(context/set :a 1)
(context/set :b 2)
(context/all)  ; => {:a 1 :b 2}
```

### `context/merge`

Merge a map of key-value pairs into the current context.

```scheme
(context/merge {:trace-id "abc" :env "production" :version "1.0"})
(context/get :env)  ; => "production"
```

### `context/clear`

Clear all context, resetting to an empty state.

```scheme
(context/clear)
(context/all)  ; => {}
```

## Scoped Overrides

### `context/with`

Push a temporary context frame for the duration of a thunk. The frame is automatically popped when the thunk completes â€” even if it raises an error.

```scheme
(context/set :env "production")

(context/with {:env "staging" :debug #t}
  (lambda ()
    (context/get :env)      ; => "staging"
    (context/get :debug)))  ; => #t

(context/get :env)    ; => "production" (restored)
(context/get :debug)  ; => nil (gone)
```

Scopes nest naturally â€” inner values shadow outer ones:

```scheme
(context/set :a 1)
(context/with {:b 2}
  (lambda ()
    (context/with {:c 3}
      (lambda ()
        (list (context/get :a) (context/get :b) (context/get :c))))))
; => (1 2 3)
```

::: warning
Values set with `context/set` inside a `context/with` block are written to the inner frame and discarded when the scope exits. If you need a value to persist, set it before entering `context/with`.
:::

## Stacks

Context stacks are ordered lists of values that you can push to and pop from. Unlike key-value context, stacks are **not scoped** by `context/with` â€” pushes persist across scope boundaries.

### `context/push`

Append a value to a named stack.

```scheme
(context/push :breadcrumbs "login")
(context/push :breadcrumbs "dashboard")
(context/push :breadcrumbs "settings")
```

### `context/stack`

Get all values in a named stack as a list.

```scheme
(context/stack :breadcrumbs)
; => ("login" "dashboard" "settings")
```

### `context/pop`

Remove and return the last value from a stack. Returns `nil` if the stack is empty.

```scheme
(context/pop :breadcrumbs)  ; => "settings"
(context/stack :breadcrumbs)
; => ("login" "dashboard")
```

## Hidden Context

Hidden context stores values that are **not visible** via `context/get`, `context/all`, or log metadata. Use it for sensitive data like API keys or internal state.

### `context/set-hidden`

```scheme
(context/set-hidden :api-key "sk-secret-123")
```

### `context/get-hidden`

```scheme
(context/get-hidden :api-key)  ; => "sk-secret-123"
(context/get :api-key)         ; => nil (not visible in regular context)
```

### `context/has-hidden?`

```scheme
(context/has-hidden? :api-key)  ; => #t
```

## Log Integration

When context is non-empty, `log/info`, `log/warn`, `log/error`, and `log/debug` automatically append the context map as metadata:

```scheme
(context/set :trace-id "abc-123")
(context/set :user-id 42)
(log/info "Request processed")
```

Output:

```
[INFO] Request processed {:trace-id "abc-123" :user-id 42}
```

Hidden context is **not** included in log output.

## Examples

### Request tracing

```scheme
(context/set :request-id (uuid/v4))
(context/set :method "GET")
(context/set :path "/api/users")

(log/info "Request started")
; [INFO] Request started {:method "GET" :path "/api/users" :request-id "a1b2c3..."}

;; All downstream functions automatically include this context in their logs
(process-request)
```

### Pipeline breadcrumbs

```scheme
(define (process-document doc)
  (context/push :steps "parse")
  (let ((parsed (parse doc)))
    (context/push :steps "validate")
    (let ((valid (validate parsed)))
      (context/push :steps "transform")
      (transform valid))))

(process-document input)
(context/stack :steps)
; => ("parse" "validate" "transform")
```

### Scoped configuration

```scheme
;; Set default model
(context/set :model "claude-sonnet")

;; Override for a specific block
(context/with {:model "gpt-4o" :temperature 0.9}
  (lambda ()
    ;; Code here sees the overridden values
    (context/get :model)))       ; => "gpt-4o"

(context/get :model)             ; => "claude-sonnet"
```

## Function Reference

| Function              | Args        | Description                       |
| --------------------- | ----------- | --------------------------------- |
| `context/set`         | `key value` | Set a context value               |
| `context/get`         | `key`       | Get a value (or `nil`)            |
| `context/has?`        | `key`       | Check if key exists               |
| `context/remove`      | `key`       | Remove and return value           |
| `context/pull`        | `key`       | Get and remove (alias for remove) |
| `context/all`         |             | Get all context as a map          |
| `context/merge`       | `map`       | Merge map into context            |
| `context/clear`       |             | Clear all context                 |
| `context/with`        | `map thunk` | Scoped override                   |
| `context/push`        | `key value` | Push to named stack               |
| `context/stack`       | `key`       | Get stack as list                 |
| `context/pop`         | `key`       | Pop from named stack              |
| `context/set-hidden`  | `key value` | Set hidden value                  |
| `context/get-hidden`  | `key`       | Get hidden value                  |
| `context/has-hidden?` | `key`       | Check hidden key exists           |

---


# Terminal Styling

## Text Styling

### Individual Style Functions

These wrap text in ANSI escape codes and return the styled string.

**Modifiers:** `term/bold`, `term/dim`, `term/italic`, `term/underline`, `term/inverse`, `term/strikethrough`

**Colors:** `term/black`, `term/red`, `term/green`, `term/yellow`, `term/blue`, `term/magenta`, `term/cyan`, `term/white`, `term/gray`

```scheme
(term/bold "important")     ; => bold text
(term/red "error")          ; => red text
(println (term/green "success"))
```

### `term/style`

Apply multiple styles at once using keywords.

```scheme
(term/style "warning" :bold :yellow)
(term/style "error" :bold :red :underline)
```

Available keywords: `:bold`, `:dim`, `:italic`, `:underline`, `:inverse`, `:strikethrough`, `:black`, `:red`, `:green`, `:yellow`, `:blue`, `:magenta`, `:cyan`, `:white`, `:gray`

### `term/rgb`

Apply 24-bit true color to text. Takes text, red, green, blue (0-255).

```scheme
(term/rgb "custom color" 255 128 0)   ; => orange text
```

### `term/strip`

Remove ANSI escape sequences from a string.

```scheme
(term/strip (term/bold "hello"))   ; => "hello"
```

## Spinners

Animated terminal spinners for long-running operations.

### `term/spinner-start`

Start a spinner with a message. Returns a spinner ID.

```scheme
(define id (term/spinner-start "Processing..."))
```

### `term/spinner-update`

Update the spinner message while it's running.

```scheme
(term/spinner-update id "Still processing...")
```

### `term/spinner-stop`

Stop a spinner. Optionally show a final status.

```scheme
(term/spinner-stop id)

;; With final status
(term/spinner-stop id {:symbol "âœ”" :text "Done"})
```

---


# Playground & WASM

When running in the browser playground at [sema.run](https://sema.run), Sema executes as WebAssembly. Most stdlib functions work identically, but some behave differently due to browser sandbox constraints, and a few web-only functions are available.

## Web-Only Functions

These functions are **only available in the WASM playground** â€” they access browser APIs that don't exist in the native CLI.

### `web/user-agent`

Return the browser's `navigator.userAgent` string. Works in all browsers.

```scheme
(web/user-agent)
; => "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 ..."
```

### `web/user-agent-data`

Return structured browser information from `navigator.userAgentData`. Returns a map on Chromium-based browsers (Chrome, Edge, Opera), `nil` on Firefox and Safari.

```scheme
(web/user-agent-data)
; Chromium => {:mobile false :platform "macOS" :brands ("Chromium/120" "Google Chrome/120")}
; Firefox/Safari => nil
```

::: tip
`userAgentData` is the modern replacement for UA string parsing â€” it returns structured, reliable data instead of a messy string. However, it's Chromium-only. Use `web/user-agent` for cross-browser compatibility.
:::

## WASM Behavior Differences

### System Information

System functions return web-appropriate values instead of OS-specific ones:

| Function           | Native                              | WASM                        |
| ------------------ | ----------------------------------- | --------------------------- |
| `sys/platform`     | `"macos"` / `"linux"` / `"windows"` | `"web"`                     |
| `sys/os`           | `"macos"`                           | `"web"`                     |
| `sys/arch`         | `"aarch64"` / `"x86_64"`            | `"wasm32"`                  |
| `sys/cwd`          | Current directory path              | `"/"`                       |
| `sys/interactive?` | `#t` in REPL                        | `#f`                        |
| `sys/pid`          | Process ID                          | `0`                         |
| `sys/elapsed`      | Nanoseconds since process start     | Nanoseconds since page load |
| `time-ms`          | `SystemTime` milliseconds           | `Date.now()` milliseconds   |

These always return `nil` in WASM: `sys/hostname`, `sys/user`, `sys/home-dir`, `sys/which`, `sys/tty`.

### File I/O (Virtual Filesystem)

File operations work against an **in-memory virtual filesystem** (VFS). Files persist for the duration of your session but are **lost on page reload**.

```scheme
;; These all work in the playground
(file/write "/hello.txt" "Hello from WASM!")
(file/read "/hello.txt")       ; => "Hello from WASM!"
(file/exists? "/hello.txt")    ; => #t
(file/mkdir "/mydir")
(file/is-directory? "/mydir")  ; => #t
(file/list "/")                ; => ("hello.txt")
```

All file functions are supported: `file/read`, `file/write`, `file/append`, `file/delete`, `file/rename`, `file/copy`, `file/exists?`, `file/list`, `file/mkdir`, `file/is-file?`, `file/is-directory?`, `file/is-symlink?`, `file/info`, `file/read-lines`, `file/write-lines`. Path functions (`path/join`, `path/dirname`, `path/basename`, `path/extension`, `path/absolute`) also work.

The `load` function reads from the VFS and evaluates the parsed expressions.

### Terminal Styling

All `term/*` functions work but return text **without ANSI formatting** (since the browser has no terminal):

```scheme
(term/bold "hello")   ; => "hello" (no bold applied)
(term/red "error")    ; => "error" (no color applied)
(term/style "hi" :bold :cyan)  ; => "hi"
```

### HTTP Functions

HTTP functions work in the playground via the browser's `fetch()` API. They return the same `{:status :headers :body}` map as the native CLI.

```scheme
(define resp (http/get "https://httpbin.org/get"))
(:status resp)    ; => 200
(:body resp)      ; => "{\"args\": {}, ...}"

(http/post "https://httpbin.org/post" {:name "sema"})
; => {:status 200 :headers {...} :body "..."}
```

All HTTP functions are supported: `http/get`, `http/post`, `http/put`, `http/delete`, `http/request`.

::: warning CORS Restrictions
Browser security rules (CORS) may block requests to servers that don't include `Access-Control-Allow-Origin` headers. Public APIs like httpbin.org work fine. If you get a network error, the target server likely doesn't allow cross-origin requests.
:::

### Not Available in WASM

These functions return an error when called in the playground:

| Function     | Reason                                       |
| ------------ | -------------------------------------------- |
| `shell`      | No subprocess execution in browser           |
| `exit`       | No process to exit                           |
| `read-line`  | No stdin in browser                          |
| `read-stdin` | No stdin in browser                          |
| `sleep`      | Cannot block the browser main thread (no-op) |

---

# Architecture Overview

Sema is a Lisp with first-class LLM primitives, implemented in Rust. The primary execution path is a tree-walking interpreter â€” the evaluator walks the AST directly via a trampoline loop for tail-call optimization. A [bytecode VM](./bytecode-vm.md) is available as an opt-in execution path (via `--vm`) for faster execution of compute-heavy workloads. The runtime is single-threaded (`Rc`, not `Arc`), with deterministic destruction via reference counting instead of a garbage collector.

The entire implementation is ~15k lines of Rust spread across 7 crates, each with a clear responsibility and strict dependency ordering.

## Crate Map

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚              sema                    â”‚
                â”‚  (binary: CLI, REPL, embedding API)  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  sema-stdlib   â”‚    â”‚    sema-llm     â”‚
              â”‚  ~350 native   â”‚    â”‚  LLM providers  â”‚
              â”‚  functions     â”‚    â”‚  + embeddings   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚                   â”‚
                       â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚    â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â–¼â”€â”€â”
              â”‚   sema-eval    â”‚
              â”‚  trampoline    â”‚
              â”‚  evaluator     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
              â”‚    sema-vm     â”‚
              â”‚  bytecode VM   â”‚
              â”‚  (opt-in)      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  sema-reader   â”‚
              â”‚  lexer/parser  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   sema-core    â”‚
              â”‚  Value, Env,   â”‚
              â”‚  SemaError     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Dependency flow:** `sema-core â† sema-reader â† sema-vm â† sema-eval â† sema-stdlib / sema-llm â† sema`

The critical constraint: **sema-stdlib and sema-llm depend on sema-core, not on sema-eval.** This avoids circular dependencies but creates a problem â€” both crates sometimes need to evaluate user code. They solve it via dependency inversion:

- **sema-stdlib** invokes the real evaluator via thread-local callbacks (`call_callback`/`eval_callback`) registered by `sema-eval` at startup
- **sema-llm** uses its own eval callback for legacy reasons, plus the core callbacks

This is discussed in detail in [The Circular Dependency Problem](#the-circular-dependency-problem).

### Crate Responsibilities

| Crate           | Role                            | Key types                                                                                                                                 |
| --------------- | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **sema-core**   | Shared types                    | `Value` (NaN-boxed 8-byte), `Env`, `SemaError`, string interner, `NativeFn`, `Lambda`, `Macro`, `Record`, LLM types                       |
| **sema-reader** | Parsing                         | `Lexer` (24 token types) + recursive descent `Parser` â†’ `Value` AST + `SpanMap`                                                           |
| **sema-vm**     | Bytecode VM (opt-in via `--vm`) | `CoreExpr`, `ResolvedExpr`, `Op`, `Chunk`, `Emitter` â€” lowering, resolution, compilation, VM dispatch                                     |
| **sema-eval**   | Evaluation                      | Trampoline-based evaluator, 39 special forms, module system, call stack + span table                                                      |
| **sema-stdlib** | Standard library                | ~350 native functions across 19 modules                                                                                                   |
| **sema-llm**    | LLM integration                 | `LlmProvider` trait, 4 native providers (Anthropic, OpenAI, Gemini, Ollama), OpenAI-compatible shim, 3 embedding providers, cost tracking |
| **sema**        | Binary                          | clap CLI, rustyline REPL, `InterpreterBuilder` embedding API                                                                              |

## The Value Type

All Sema data is represented by a single NaN-boxed `Value` â€” an 8-byte `struct Value(u64)` that encodes every type in IEEE 754 quiet NaN payload space:

```rust
// crates/sema-core/src/value.rs
#[repr(transparent)]
pub struct Value(u64);

// Encoding: floats stored as raw f64 bits.
// All other types packed into quiet NaN payloads:
//   sign=1 | exponent=0x7FF | quiet=1 | TAG(6 bits) | PAYLOAD(45 bits)
//
// Immediate types (no heap allocation):
//   Nil, Bool, Char, Symbol(Spur), Keyword(Spur), IntSmall(Â±2^44)
//
// Heap types (Rc pointer in 45-bit payload):
//   String, List, Vector, Map, HashMap, Lambda, Macro, NativeFn,
//   Prompt, Message, Conversation, ToolDef, Agent, Thunk, Record, Bytevector
//
// Pattern matching via val.view() â†’ ValueView enum
```

Several design choices here are worth examining.

### Why `Rc`, Not `Arc`

Sema is single-threaded. `Arc` adds an atomic increment/decrement on every clone/drop â€” unnecessary overhead when there's no cross-thread sharing. `Rc` uses ordinary (non-atomic) reference counting, which is cheaper and also means the compiler can catch accidental `Send`/`Sync` usage at compile time.

The trade-off versus a tracing garbage collector: reference counting gives deterministic destruction (values are freed the instant their last reference drops), but cannot collect cycles. In practice this is rarely a problem â€” Lisp closures tend to create tree-shaped reference graphs, not cycles. A lambda captures its enclosing environment, which may capture its own enclosing environment, forming a chain. Cycles are theoretically possible (e.g., named lambdas bind themselves in their own environment, and `Thunk` uses `RefCell` which could close over itself), but they don't arise in typical Sema programs. If they did, the leaked memory would be bounded by the closure's captured environment â€” not a growing leak.

Sema uses NaN-boxing â€” encoding values in the unused bits of IEEE 754 NaN representations to fit a tagged value in 8 bytes, the same technique used by Janet. This makes `Value` the same size as a `f64` or a pointer, meaning the value stack and constant pool have excellent cache locality. Heap types like `List`, `Map`, and `Lambda` add one level of `Rc` pointer indirection, with the pointer stored in the 45-bit payload field (using the 8-byte alignment guarantee to shift the pointer right by 3 bits). Small integers (Â±17.5 trillion), symbols, keywords, characters, booleans, and nil are all stored entirely within the 8-byte NaN-box with zero heap allocation.

### Why Vector-Backed Lists

`Value::List(Rc<Vec<Value>>)` stores list elements in a contiguous `Vec`, not a linked list of cons cells. This is a deliberate departure from traditional Lisp:

| Operation                      | Vec-backed     | Cons cells      |
| ------------------------------ | -------------- | --------------- |
| Random access (`nth`)          | O(1)           | O(n)            |
| `length`                       | O(1)           | O(n)            |
| Cache locality                 | Contiguous     | Pointer-chasing |
| `cons` (prepend)               | O(n) copy      | O(1)            |
| `append`                       | O(n) copy      | O(n)            |
| Pattern matching (`car`/`cdr`) | Slice indexing | Natural         |

The performance win comes from cache locality â€” modern CPUs prefetch sequential memory, so iterating a `Vec` is dramatically faster than chasing pointers through a cons list. Random access and length are constant-time bonuses.

The cost is O(n) `cons` and `append`. Sema mitigates this with copy-on-write optimization (see [Performance Internals](./performance.md#_1-copy-on-write-map-mutation)): when the `Rc` refcount is 1, mutations happen in place instead of copying. In practice, most list construction uses `list`, `map`, `filter`, or `fold` â€” which build a new `Vec` directly â€” rather than repeated `cons`.

Clojure takes a third approach: persistent vectors backed by wide (32-way branching) array-mapped tries, giving effectively O(1) indexed access (O(logâ‚ƒâ‚‚ n), which is â‰¤ 7 for any practical size) with structural sharing. Sema's approach is simpler and faster for small to medium lists, at the cost of no structural sharing.

### Why `BTreeMap` for Maps, `hashbrown` Opt-In

`Value::Map` uses `BTreeMap` (sorted, deterministic iteration order) rather than `HashMap`. This matters for:

- **Deterministic equality:** Two maps with the same entries compare identically via the derived `PartialEq`, and iteration order is independent of insertion order â€” important for consistent hashing and display
- **Printing:** `{:a 1 :b 2}` always prints in the same order, making test assertions reliable
- **Usable as keys:** Maps can be keys in other `BTreeMap`s because `Value` implements `Ord`. Since `Map` variants compare by sorted content, two maps with the same entries are always equal under `Ord`, regardless of construction order

For performance-critical code, `Value::HashMap` wraps `hashbrown::HashMap` (the SwissTable implementation used inside Rust's standard library). It's opt-in via `(hashmap/new)` â€” see the [Performance Internals](./performance.md#_5-hashbrown-hashmap) for benchmarks.

### Why `Spur` for Symbols and Keywords

`Symbol(Spur)` and `Keyword(Spur)` store interned `u32` handles rather than strings. A thread-local `lasso::Rodeo` interner maps strings to `Spur` values and back:

```rust
thread_local! {
    static INTERNER: RefCell<Rodeo> = RefCell::new(Rodeo::default());
}

pub fn intern(s: &str) -> Spur {
    INTERNER.with(|r| r.borrow_mut().get_or_intern(s))
}

pub fn with_resolved<F, R>(spur: Spur, f: F) -> R
where
    F: FnOnce(&str) -> R,
{
    INTERNER.with(|r| {
        let interner = r.borrow();
        f(interner.resolve(&spur))
    })
}
```

This makes symbol equality O(1) (integer comparison instead of string comparison) and environment lookup faster (integer keys in the `BTreeMap`). It also means special form dispatch â€” the hottest path in the evaluator â€” compares `u32` values against pre-cached constants rather than resolving strings.

String interning is as old as Lisp itself. McCarthy's original LISP 1.5 (1962) interned atoms in the "object list" (oblist). The key difference: Sema uses a separate interner rather than pointer identity, so interning is explicit via `intern()` rather than implicit.

### LLM Types as First-Class Values

`Prompt`, `Message`, `Conversation`, `ToolDef`, and `Agent` sit in the `Value` enum at the same level as `List` and `Map`. They're not encoded as maps-with-conventions â€” they're distinct types with their own constructors, pattern matching, and display representations:

```scheme
;; These are values, not strings or maps
(define msg (message :user "Hello"))    ; => <message user "Hello">
(define p (prompt msg))                 ; => <prompt 1 messages>
(define conv (conversation p :model "claude-sonnet-4-20250514")) ; => <conversation 1 messages>
```

This means the type system catches errors like passing a string where a message is expected, and tools like `complete` can dispatch on the actual type rather than checking for the presence of magic keys in a map.

## Environment Model

The environment is a linked list of scopes, each holding a `SpurMap<Spur, Value>` (a `hashbrown::HashMap`):

```rust
pub struct Env {
    pub bindings: Rc<RefCell<SpurMap<Spur, Value>>>,
    pub parent: Option<Rc<Env>>,
}
```

Variable lookup walks the parent chain until it finds a binding or reaches the root. This is the standard lexical scoping model â€” a closure captures a reference to its defining environment, and lookups resolve outward through enclosing scopes.

### Operations

| Operation                 | Behavior                                      | Used by                     |
| ------------------------- | --------------------------------------------- | --------------------------- |
| `get(spur)`               | Walk parent chain, return first match         | Variable lookup             |
| `set(spur, val)`          | Insert in current scope                       | `define`, parameter binding |
| `set_existing(spur, val)` | Walk chain, update where found                | `set!` (mutation)           |
| `update(spur, val)`       | Overwrite in current scope, no key allocation | Hot-path env reuse          |
| `take(spur)`              | Remove from current scope, return value       | COW optimization            |
| `take_anywhere(spur)`     | Remove from any scope in chain                | COW optimization            |

`take` and `take_anywhere` exist for the copy-on-write optimization: by _removing_ a value from the environment before passing it to a function, the `Rc` refcount drops to 1, enabling in-place mutation. See [Performance Internals](./performance.md#_1-copy-on-write-map-mutation).

`update` exists for the lambda environment reuse optimization: when reusing an environment across iterations of a hot loop, `update` overwrites an existing binding without the overhead of `BTreeMap::insert`'s key allocation path. See [Performance Internals](./performance.md#_2-lambda-environment-reuse).

## Error Handling

`SemaError` is a `thiserror`-derived enum with 8 variants plus a `WithTrace` wrapper:

```rust
#[derive(Debug, Clone, thiserror::Error)]
pub enum SemaError {
    Reader { message: String, span: Span },
    Eval(String),
    Type { expected: String, got: String },
    Arity { name: String, expected: String, got: usize },
    Unbound(String),
    Llm(String),
    Io(String),
    UserException(Value),

    WithTrace { inner: Box<SemaError>, trace: StackTrace },
}
```

### Constructor Helpers

Errors are created via constructor methods, never raw enum variants:

```rust
SemaError::eval("division by zero")
SemaError::type_error("int", val.type_name())
SemaError::arity("map", "2", args.len())
```

This keeps error construction concise across ~350 native functions and 39 special forms.

### Lazy Stack Traces

Stack traces are not captured at error creation time. Instead, the `WithTrace` wrapper is attached during error _propagation_ â€” when the trampoline loop unwinds through a function call, it wraps the error with the current call stack:

```rust
pub fn with_stack_trace(self, trace: StackTrace) -> Self {
    if trace.0.is_empty() {
        return self;
    }
    match self {
        SemaError::WithTrace { .. } => self,  // already wrapped, don't double-wrap
        other => SemaError::WithTrace {
            inner: Box::new(other),
            trace,
        },
    }
}
```

This avoids the cost of capturing a stack trace for errors that are caught by `try`/`catch` â€” only errors that propagate to the top level pay the trace cost. The idempotence check (`WithTrace { .. } => self`) prevents double-wrapping when an error passes through multiple call frames.

## Interpreter State

Sema's evaluator state is held in an explicit `EvalContext` struct, defined in `sema-core/src/context.rs` and threaded through the evaluator as `ctx: &EvalContext`. Each `Interpreter` instance owns its own `EvalContext`, enabling multiple independent interpreters per thread with fully isolated state.

### EvalContext Fields

| Field               | Type                                | Purpose                                      |
| ------------------- | ----------------------------------- | -------------------------------------------- |
| `module_cache`      | `RefCell<BTreeMap<PathBuf, ...>>`   | Loaded modules (path â†’ exports)              |
| `current_file`      | `RefCell<Vec<PathBuf>>`             | Stack of file paths being executed           |
| `module_exports`    | `RefCell<Vec<Option<Vec<String>>>>` | Exports declared by currently-loading module |
| `module_load_stack` | `RefCell<Vec<PathBuf>>`             | Cycle detection during module loading        |
| `call_stack`        | `RefCell<Vec<CallFrame>>`           | Call frames for error traces                 |
| `span_table`        | `RefCell<HashMap<usize, Span>>`     | Rc pointer address â†’ source span             |
| `eval_depth`        | `Cell<usize>`                       | Recursion depth counter                      |
| `eval_step_limit`   | `Cell<usize>`                       | Step limit for fuzz targets                  |
| `eval_steps`        | `Cell<usize>`                       | Current step counter                         |

### Remaining Thread-Locals

Some state remains in thread-local storage â€” either because it's a pure performance cache or because it belongs to a subsystem that hasn't been refactored yet:

| Location                     | Thread-local        | Purpose                                       |
| ---------------------------- | ------------------- | --------------------------------------------- |
| `sema-core/value.rs`         | `INTERNER`          | String interner (`lasso::Rodeo`)              |
| `sema-core/context.rs`       | `EVAL_FN`           | Evaluator callback                            |
| `sema-core/context.rs`       | `CALL_FN`           | Call-value callback                           |
| `sema-core/context.rs`       | `STDLIB_CTX`        | Shared `EvalContext` for stdlib callbacks     |
| `sema-eval/special_forms.rs` | `SF`                | Cached `SpecialFormSpurs` (performance cache) |
| `sema-llm/builtins.rs`       | `PROVIDER_REGISTRY` | Registered LLM providers                      |
| `sema-llm/builtins.rs`       | `SESSION_USAGE`     | Cumulative token usage                        |
| `sema-llm/builtins.rs`       | `LAST_USAGE`        | Most recent completion's usage                |
| `sema-llm/builtins.rs`       | `EVAL_FN`           | Full evaluator callback                       |
| `sema-llm/builtins.rs`       | `SESSION_COST`      | Cumulative dollar cost                        |
| `sema-llm/builtins.rs`       | `BUDGET_LIMIT`      | Spending cap                                  |
| `sema-llm/builtins.rs`       | `BUDGET_SPENT`      | Spending against cap                          |
| `sema-llm/pricing.rs`        | `CUSTOM_PRICING`    | User-defined model pricing                    |

### Implications for Embedding

Multiple `Interpreter` instances can coexist on the same thread with fully isolated evaluator state â€” each has its own module cache, call stack, span table, and depth counters. The string interner (`INTERNER`) remains shared per-thread, which is correct since `Spur` handles must be consistent within a thread. LLM state (provider registry, usage tracking, budgets) is also per-thread, meaning all interpreters on the same thread share provider configuration and cost tracking.

`Value` instances are not `Send` or `Sync` (they use `Rc`, not `Arc`), so interpreters cannot be moved across threads.

## WASM Support

Sema compiles to WebAssembly with conditional compilation gates. The `#[cfg(not(target_arch = "wasm32"))]` attribute excludes modules that depend on OS-level capabilities:

**From sema-stdlib:**

- `io` â€” file system access (`file/read`, `file/write`, `file/fold-lines`, etc.)
- `system` â€” process execution, environment variables, exit
- `http` â€” HTTP client (`http/get`, `http/post`, etc.)
- `terminal` â€” terminal control (colors, cursor, raw mode)

**From sema-eval:**

- Module `import`/`load` (depends on file system)

**sema-llm** is excluded entirely â€” LLM providers require network access.

The pure-computation core (arithmetic, strings, lists, maps, JSON, regex, crypto, datetime, CSV, bytevectors, predicates, math, comparison, bitwise, meta) remains available in WASM, making Sema usable as an embedded scripting language in browser-based applications.

## The LLM Subsystem

### Provider Trait

All LLM providers implement a single trait:

```rust
pub trait LlmProvider: Send + Sync {
    fn name(&self) -> &str;
    fn complete(&self, request: ChatRequest) -> Result<ChatResponse, LlmError>;
    fn default_model(&self) -> &str;

    // Optional â€” defaults provided
    fn stream_complete(&self, request: ChatRequest,
        on_chunk: &mut dyn FnMut(&str) -> Result<(), LlmError>,
    ) -> Result<ChatResponse, LlmError> { /* non-streaming fallback */ }

    fn batch_complete(&self, requests: Vec<ChatRequest>)
        -> Vec<Result<ChatResponse, LlmError>> { /* sequential fallback */ }

    fn embed(&self, request: EmbedRequest)
        -> Result<EmbedResponse, LlmError> { /* unsupported error */ }
}
```

Note the `Send + Sync` bound â€” despite the single-threaded runtime, provider implementations use `tokio::runtime::Runtime::block_on` internally to run async HTTP clients. The trait itself is synchronous; async is hidden behind the provider boundary.

### Provider Registry

The `ProviderRegistry` holds registered providers by name with a default provider slot and a separate embedding provider slot:

```rust
pub struct ProviderRegistry {
    providers: HashMap<String, Box<dyn LlmProvider>>,
    default: Option<String>,
    embedding_provider: Option<String>,
}
```

At startup, the binary crate detects available API keys and registers providers:

- `ANTHROPIC_API_KEY` â†’ Anthropic (Claude)
- `OPENAI_API_KEY` â†’ OpenAI (GPT)
- `GEMINI_API_KEY` â†’ Gemini
- `OLLAMA_HOST` â†’ Ollama (local)
- `GROQ_API_KEY`, `XAI_API_KEY`, `MISTRAL_API_KEY`, `MOONSHOT_API_KEY` â†’ OpenAI-compatible shim

Embedding providers (Jina, Voyage, Cohere) are registered separately and selected via `(llm/set-embedding-provider)`.

### Cost Tracking

Every completion records token usage in `SESSION_USAGE` and computes dollar cost via a built-in pricing table (`pricing.rs`). The `llm/with-budget` function sets a scoped spending cap:

```scheme
(llm/with-budget {:max-cost-usd 0.50 :max-tokens 10000} (lambda ()
  (llm/complete "Summarize this document...")))
;; Raises an error if cumulative cost exceeds $0.50 or 10000 tokens
```

## The Circular Dependency Problem

The most architecturally significant constraint in Sema is the dependency direction between the evaluator and the library crates.

### The Problem

Both `sema-stdlib` and `sema-llm` sometimes need to evaluate user code:

- **sema-stdlib:** `file/fold-lines` invokes a user-provided lambda on each line. `map`, `filter`, `fold`, `for-each`, `sort` all take lambda arguments.
- **sema-llm:** Tool handlers defined via `deftool` are Sema expressions that must be evaluated when an LLM invokes the tool.

But `sema-stdlib` and `sema-llm` depend on `sema-core`, not `sema-eval`. They can't call `eval_value()` because that function lives in `sema-eval`, which is upstream.

```
sema-eval â”€â”€depends-onâ”€â”€â–º sema-core
sema-stdlib â”€â”€depends-onâ”€â”€â–º sema-core
sema-stdlib â”€â”€CANNOT depend onâ”€â”€â–º sema-eval  (would create a cycle)
```

### Solution 1: Callback Architecture (sema-core + sema-stdlib)

`sema-core` defines thread-local callback storage in `context.rs` that bridges the dependency gap using dependency inversion:

```rust
pub type EvalCallback = fn(&EvalContext, &Value, &Env) -> Result<Value, SemaError>;
pub type CallCallback = fn(&EvalContext, &Value, &[Value], &Env) -> Result<Value, SemaError>;

thread_local! {
    static EVAL_FN: Cell<Option<EvalCallback>> = Cell::new(None);
    static CALL_FN: Cell<Option<CallCallback>> = Cell::new(None);
    static STDLIB_CTX: RefCell<Option<EvalContext>> = RefCell::new(None);
}
```

At startup, `sema-eval` registers the real evaluator and call dispatch functions:

```rust
sema_core::set_eval_callback(eval_value);
sema_core::set_call_callback(call_value);
```

All stdlib higher-order functions (`map`, `filter`, `fold`, `sort-by`, `for-each`, `file/fold-lines`, etc.) invoke user-provided lambdas through `sema_core::call_callback`, which dispatches to the real evaluator:

```rust
// In sema-stdlib, e.g. map implementation
let result = sema_core::call_callback(&func, &[elem], env)?;
```

The `with_stdlib_ctx` function provides a shared `EvalContext` for stdlib callbacks, avoiding per-call allocation of a new context.

This is a clean dependency inversion â€” `sema-stdlib` depends only on the callback signature defined in `sema-core`, not on `sema-eval`. The runtime cost is one `Cell::get()` + function pointer dispatch per call, which is negligible. Unlike the previous mini-evaluator approach, this architecture uses the _same_ evaluator everywhere â€” all special forms, builtins, and features are available inside higher-order functions like `map` and `file/fold-lines`.

### Solution 2: Eval Callback (sema-llm)

`sema-llm` predates the core callback architecture and maintains its own eval callback in a thread-local. It stores a function pointer that bridges the dependency gap:

```rust
pub type EvalCallback = Box<dyn Fn(&EvalContext, &Value, &Env) -> Result<Value, SemaError>>;

thread_local! {
    static EVAL_FN: RefCell<Option<EvalCallback>> = RefCell::new(None);
}

pub fn set_eval_callback(f: impl Fn(&EvalContext, &Value, &Env) -> Result<Value, SemaError> + 'static) {
    EVAL_FN.with(|eval| {
        *eval.borrow_mut() = Some(Box::new(f));
    });
}
```

At startup, the binary crate registers the full evaluator:

```rust
sema_llm::builtins::set_eval_callback(sema_eval::eval_value);
```

When a tool handler needs to evaluate Sema code, it calls through this indirection:

```rust
fn full_eval(ctx: &EvalContext, expr: &Value, env: &Env) -> Result<Value, SemaError> {
    EVAL_FN.with(|eval_fn| {
        let eval_fn = eval_fn.borrow();
        match &*eval_fn {
            Some(f) => f(ctx, expr, env),
            None => simple_eval(expr, env),  // fallback if no callback registered
        }
    })
}
```

This is the classic dependency inversion pattern â€” `sema-llm` depends on an _interface_ (the callback signature) rather than the concrete implementation. The runtime cost is one `RefCell::borrow()` + dynamic dispatch per eval call, which is negligible for LLM tool invocations (the LLM API call dominates by orders of magnitude).

### Why Not a Trait?

An alternative would be to define an `Evaluator` trait in `sema-core` and have `sema-eval` implement it. This would work but adds complexity for little benefit â€” the callback is simpler, there's only one implementation, and it avoids threading a trait object through every function that might need evaluation. The callback approach also makes it easy to test `sema-llm` in isolation (register a mock evaluator).

### Architectural Lesson

The circular dependency constraint forced a callback architecture that turned out to be a better design than having direct access to the evaluator would have been. The dependency inversion through `sema-core` callbacks gives a single, canonical evaluator used everywhere â€” stdlib HOFs, LLM tool handlers, and the main interpreter all run the same code paths with full feature support. This also provides a clean seam for future work: with the bytecode VM now available via `--vm`, only the callback registrations needed to change â€” all call sites in stdlib and llm remained untouched, validating this design. Sometimes constraints lead to better designs than unconstrained freedom would have.

---

# Bytecode VM

::: tip Opt-In (Alpha)
The bytecode VM is functional and available via the `--vm` CLI flag. The tree-walking interpreter remains the default execution path. Both runtimes coexist and share the global environment.
:::

## Overview

Sema includes a bytecode VM alongside the existing tree-walking interpreter, enabled with the `--vm` CLI flag. The VM compiles Sema source code into stack-based bytecode for faster execution, targeting **5â€“15Ã— speedup** over the tree-walker on compute-heavy workloads.

The tree-walking interpreter (`sema-eval`) is preserved as the default execution path, the macro expansion engine, and `eval` fallback â€” the two runtimes coexist, sharing the global environment and `EvalContext`.

## Compilation Pipeline

```
Source text
  â†’ Reader       (tokenize + parse â†’ Value AST)
  â†’ Macro expand  (tree-walker evaluates macros)
  â†’ Lower         (Value AST â†’ CoreExpr IR)
  â†’ Resolve        (CoreExpr â†’ ResolvedExpr with slot/upvalue/global analysis)
  â†’ Compile        (ResolvedExpr â†’ bytecode Chunks)
  â†’ VM execution   (dispatch loop)
```

### Phase 1: Lowering (Value â†’ CoreExpr)

The lowering pass converts the `Value` AST into `CoreExpr`, a desugared intermediate representation. All ~35 special forms are lowered to ~30 CoreExpr variants. Several forms desugar into simpler ones:

| Source Form | Lowers To                                 |
| ----------- | ----------------------------------------- |
| `cond`      | Nested `If`                               |
| `when`      | `If` with nil else                        |
| `unless`    | `If` with swapped branches                |
| `case`      | `Let` + nested `If` with `Or` comparisons |
| `defun`     | `Define` + `Lambda`                       |

**Tail position analysis** happens during lowering. The `Call` node carries a `tail: bool` flag, set based on position:

- **Tail**: last expression in `lambda` body, `begin`, `let`/`let*`/`letrec` body, `if` branches, `cond` clauses, `and`/`or` last operand
- **Not tail**: `try` body (handler must be reachable), `do` loop body, non-last expressions

### Phase 2: Variable Resolution (CoreExpr â†’ ResolvedExpr)

The resolver walks the CoreExpr tree and classifies every variable reference as one of:

| Resolution          | Opcode                         | Description                              |
| ------------------- | ------------------------------ | ---------------------------------------- |
| `Local { slot }`    | `LoadLocal` / `StoreLocal`     | Variable in the current function's frame |
| `Upvalue { index }` | `LoadUpvalue` / `StoreUpvalue` | Captured from an enclosing function      |
| `Global { spur }`   | `LoadGlobal` / `StoreGlobal`   | Module-level binding                     |

This is the key optimization over the tree-walker: instead of hash-based environment chain lookup (O(scope depth) per access), variables are accessed by direct slot index (O(1)).

#### Upvalue Capture

Closures use the Lua/Steel upvalue model. When a lambda references a variable from an enclosing function:

1. The resolver marks the outer local as **captured**
2. An `UpvalueDesc` entry is added to the inner lambda: `ParentLocal(slot)` if capturing from the immediate parent, `ParentUpvalue(index)` if capturing through an intermediate function

```scheme
(lambda (x)           ; x = Local slot 0
  (lambda ()          ; captures x: UpvalueDesc::ParentLocal(0)
    (lambda ()        ; captures through chain: UpvalueDesc::ParentUpvalue(0)
      x)))            ; resolves to Upvalue { index: 0 }
```

### Phase 3: Bytecode Compilation (ResolvedExpr â†’ Chunk)

The compiler (`compiler.rs`) transforms `ResolvedExpr` into bytecode `Chunk`s. The `Compiler` struct wraps an `Emitter` (bytecode builder) and collects `Function` templates for inner lambdas.

**Compilation strategies:**

- **Constants**: `Nil`, `True`, `False` get dedicated opcodes. All other constants use `Const` + constant pool.
- **Variables**: `LoadLocal`/`StoreLocal` for locals, `LoadUpvalue`/`StoreUpvalue` for captures, `LoadGlobal`/`StoreGlobal`/`DefineGlobal` for globals.
- **Control flow**: `if` uses `JumpIfFalse` + `Jump` for short-circuit. `and`/`or` use `Dup` + conditional jumps to preserve the last truthy/falsy value.
- **Lambdas**: compiled to separate `Function` templates, referenced by `MakeClosure` instruction with upvalue descriptors.
- **`do` loops**: compile to backward `Jump` with `JumpIfTrue` for exit test.
- **`try`/`catch`**: adds entries to the chunk's exception table, no inline opcodes.
- **Named let**: compiled as `MakeClosure` + `Call` â€” the loop body becomes a function.

**Runtime-delegated forms** â€” forms that can't be compiled to pure bytecode are compiled as calls to `__vm-*` global functions registered by `sema-eval`:

| Source Form                                               | Delegate                                                     |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| `eval`                                                    | `__vm-eval`                                                  |
| `import`                                                  | `__vm-import`                                                |
| `load`                                                    | `__vm-load`                                                  |
| `defmacro`                                                | `__vm-defmacro-form` (passes entire form as quoted constant) |
| `define-record-type`                                      | `__vm-define-record-type`                                    |
| `delay`                                                   | `__vm-delay` (passes unevaluated body as quoted constant)    |
| `force`                                                   | `__vm-force`                                                 |
| `prompt`, `message`, `deftool`, `defagent`, `macroexpand` | Corresponding `__vm-*` delegates                             |

**Public API**: `compile()`, `compile_many()`, `compile_with_locals()`, `compile_many_with_locals()` â€” all return `CompileResult { chunk, functions }`.

### Phase 4: VM Execution

The VM (`vm.rs`) is a stack-based dispatch loop.

**Core structs:**

```rust
VM { stack: Vec<Value>, frames: Vec<CallFrame>, globals: Rc<Env>, functions: Vec<Rc<Function>> }
CallFrame { closure: Rc<Closure>, pc: usize, base: usize, open_upvalues: Vec<Option<Rc<UpvalueCell>>> }
```

**Key design points:**

- **Safe operations**: `pop()` and `peek()` return `Result` (no panicking on underflow). `Op::from_u8()` for opcode decoding (no unsafe transmute).
- **Closure interop**: VM closures are wrapped as `Value::NativeFn` values so the tree-walker can call them. Each NativeFn wrapper creates a fresh VM instance to execute the closure's bytecode.
- **Upvalue cells**: `UpvalueCell` with `Rc<RefCell<Value>>` for shared mutable state â€” `StoreLocal` syncs to open upvalue cells, `LoadLocal` reads from cells when present.
- **Exception handling**: `Throw` opcode triggers handler search via the chunk's exception table. Stack is restored to saved depth, error value pushed, PC jumps to handler.

**Entry points**: `VM::execute()` takes a closure and `EvalContext`. `eval_str()` is a convenience that parses, compiles, and runs. `compile_program()` is the shared pipeline: `Value AST â†’ lower â†’ resolve â†’ compile â†’ (Closure, Vec<Function>)`.

## Opcode Set

The VM uses a stack-based instruction set with variable-length encoding. Each opcode is one byte, followed by operands (u16, u32, or i32).

### Constants & Stack

| Opcode  | Operands  | Description             |
| ------- | --------- | ----------------------- |
| `Const` | u16 index | Push `constants[index]` |
| `Nil`   | â€”         | Push nil                |
| `True`  | â€”         | Push #t                 |
| `False` | â€”         | Push #f                 |
| `Pop`   | â€”         | Discard top of stack    |
| `Dup`   | â€”         | Duplicate top of stack  |

### Variable Access

| Opcode         | Operands  | Description                  |
| -------------- | --------- | ---------------------------- |
| `LoadLocal`    | u16 slot  | Push `locals[slot]`          |
| `StoreLocal`   | u16 slot  | `locals[slot] = pop`         |
| `LoadUpvalue`  | u16 index | Push `upvalues[index].get()` |
| `StoreUpvalue` | u16 index | `upvalues[index].set(pop)`   |
| `LoadGlobal`   | u32 spur  | Push `globals[spur]`         |
| `StoreGlobal`  | u32 spur  | `globals[spur] = pop`        |
| `DefineGlobal` | u32 spur  | Define new global binding    |

### Control Flow

| Opcode        | Operands   | Description                 |
| ------------- | ---------- | --------------------------- |
| `Jump`        | i32 offset | Unconditional relative jump |
| `JumpIfFalse` | i32 offset | Pop, jump if falsy          |
| `JumpIfTrue`  | i32 offset | Pop, jump if truthy         |

### Functions

| Opcode        | Operands                         | Description                           |
| ------------- | -------------------------------- | ------------------------------------- |
| `Call`        | u16 argc                         | Call function with argc args          |
| `TailCall`    | u16 argc                         | Tail call (reuse frame for TCO)       |
| `Return`      | â€”                                | Return top of stack                   |
| `MakeClosure` | u16 func_id, u16 n_upvalues, ... | Create closure from function template |
| `CallNative`  | u16 native_id, u16 argc          | Direct native function call           |

### Data Constructors

| Opcode        | Operands    | Description                    |
| ------------- | ----------- | ------------------------------ |
| `MakeList`    | u16 n       | Pop n values, push list        |
| `MakeVector`  | u16 n       | Pop n values, push vector      |
| `MakeMap`     | u16 n_pairs | Pop 2n values, push sorted map |
| `MakeHashMap` | u16 n_pairs | Pop 2n values, push hash map   |

### Arithmetic & Comparison

| Opcode                       | Description                           |
| ---------------------------- | ------------------------------------- |
| `Add`, `Sub`, `Mul`, `Div`   | Generic arithmetic (int/float/string) |
| `Negate`, `Not`              | Unary operators                       |
| `Eq`, `Lt`, `Gt`, `Le`, `Ge` | Generic comparison                    |
| `AddInt`, `SubInt`, `MulInt` | Specialized int fast paths            |
| `LtInt`, `EqInt`             | Specialized int comparison            |

### Exception Handling

| Opcode  | Description                   |
| ------- | ----------------------------- |
| `Throw` | Pop value, raise as exception |

Exception handling uses an **exception table** on the Chunk rather than inline opcodes. Each entry specifies a PC range, handler address, and stack depth to restore.

## Crate Structure

The bytecode VM lives in the `sema-vm` crate, which sits between `sema-reader` and `sema-eval` in the dependency graph:

```
sema-core â† sema-reader â† sema-vm â† sema-eval
```

`sema-vm` depends on `sema-core` (for `Value`, `Spur`, `SemaError`) and `sema-reader` (for parsing in test helpers). It does **not** depend on `sema-eval` â€” the evaluator will depend on the VM, not the other way around.

### Source Files

| File           | Purpose                                                           |
| -------------- | ----------------------------------------------------------------- |
| `opcodes.rs`   | `Op` enum â€” 42 bytecode opcodes                                   |
| `chunk.rs`     | `Chunk` (bytecode + constants + spans), `Function`, `UpvalueDesc` |
| `emit.rs`      | `Emitter` â€” bytecode builder with jump backpatching               |
| `disasm.rs`    | Human-readable bytecode disassembler                              |
| `core_expr.rs` | `CoreExpr` and `ResolvedExpr` IR enums                            |
| `lower.rs`     | Value AST â†’ CoreExpr lowering pass                                |
| `resolve.rs`   | Variable resolution (local/upvalue/global analysis)               |
| `compiler.rs`  | Bytecode compiler (ResolvedExpr â†’ Chunk)                          |
| `vm.rs`        | VM dispatch loop, call frames, closures, exception handling       |

## Current Limitations

- VM closures create a fresh VM per call (no true TCO across closure boundaries)
- `try`/`catch` doesn't catch runtime errors from native functions (e.g., division by zero)
- `try`/`catch` error value format may differ from tree-walker
- `define-record-type` bindings not visible to subsequent compiled code
- Generic arithmetic opcodes (`Add`, `Sub`, etc.) are defined but currently dead code â€” arithmetic goes through `NativeFn` globals
- `CallNative` opcode is defined but not yet used (no native function registry)
- `TailCall` falls back to regular `Call` (no frame reuse)

## CLI Usage

The `--vm` flag enables the bytecode compilation path. The tree-walker remains the default.

```bash
# Run a file with the bytecode VM
sema --vm examples/hello.sema

# REPL: toggle VM mode with ,vm
sema
> ,vm
```

Both paths share the global `Env` and `EvalContext`.

## Design Decisions

### Why Keep the Tree-Walker?

The tree-walking interpreter remains for:

1. **Macro expansion** â€” macros can call `eval` at expansion time, requiring a full evaluator before compilation
2. **`eval` fallback** â€” dynamic `eval` needs to parse, expand, compile, and execute at runtime
3. **Debugging** â€” tree-walking is easier to step through and inspect

### Why Not Delete CoreExpr After Resolution?

The pipeline uses two IR types: `CoreExpr` (variables as names) and `ResolvedExpr` (variables as slots). This provides type-level safety â€” the compiler can only receive resolved expressions, preventing accidental use of unresolved variable references.

---


# Bytecode File Format (`.semac`)

::: tip Status: Design Phase
This document specifies the `.semac` bytecode file format. Implementation is planned. The format is not yet stable â€” breaking changes are expected before v1.0.
:::

## Overview

Sema supports compiling source files to bytecode files (`.semac`) for faster loading and distribution without source. The compilation pipeline is:

```
Source (.sema) â†’ Reader â†’ Lower â†’ Resolve â†’ Compile â†’ Serialize â†’ .semac file
```

Loading a `.semac` file skips parsing, lowering, resolution, and compilation â€” the VM directly deserializes and executes the pre-compiled bytecode.

### CLI Interface

```bash
# Compile a source file to bytecode
sema compile script.sema                   # â†’ script.semac
sema compile -o output.semac script.sema   # explicit output path
sema compile --strip script.sema           # strip debug info

# Run a bytecode file (auto-detected via magic number)
sema script.semac
sema run script.semac

# Disassemble a bytecode file
sema disasm script.semac
sema disasm --json script.semac

# Check a bytecode file without executing
sema compile --check script.semac
```

### Design Goals

1. **Fast loading** â€” skip parsing and compilation; the primary benefit (like Lua's `luac`)
2. **Source protection** â€” distribute without revealing source code
3. **Debuggability** â€” optional debug sections for source maps, local names, breakpoints
4. **Forward compatibility** â€” version field allows graceful rejection of incompatible bytecode
5. **Simplicity** â€” flat section-based format, no complex container (no ELF, no zip)

### Non-Goals

- **Portability** â€” bytecode files are tied to the Sema version that produced them (like Lua). Always keep source files.
- **AOT native compilation** â€” Sema's dynamic nature (eval, macros, LLM primitives) makes this impractical
- **Streaming** â€” the entire file is read into memory; no mmap or lazy loading

## File Layout

A `.semac` file consists of a fixed **header**, followed by a sequence of **sections**. Each section has a type tag, length, and payload.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           File Header (24 bytes)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: String Table    (required) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: Function Table  (required) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: Main Chunk      (required) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: Source Map      (optional) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: Debug Symbols   (optional) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Section: Breakpoints     (optional) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ... future sections ...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

All multi-byte integers are **little-endian**. All strings are **UTF-8**.

## File Header

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0 | 4 | `magic` | `\x00SEM` (`0x00`, `0x53`, `0x45`, `0x4D`) |
| 4 | 2 | `format_version` | Bytecode format version (currently `1`) |
| 6 | 2 | `flags` | Bit flags (see below) |
| 8 | 2 | `sema_major` | Sema version major that produced this file |
| 10 | 2 | `sema_minor` | Sema version minor |
| 12 | 2 | `sema_patch` | Sema version patch |
| 14 | 2 | `n_sections` | Number of sections in the file |
| 16 | 4 | `source_hash` | CRC-32 of the original source file (0 if unknown) |
| 20 | 4 | `reserved` | Reserved for future use (must be 0) |

**Total: 24 bytes**

### Magic Number

The magic bytes `\x00SEM` serve two purposes:
1. **File type identification** â€” the CLI uses this to auto-detect bytecode vs source (source files never start with a null byte)
2. **Corruption detection** â€” if the magic doesn't match, reject the file immediately

### Flags (Bit Field)

| Bit | Name | Description |
|-----|------|-------------|
| 0 | `HAS_DEBUG` | File contains debug sections (Source Map, Debug Symbols) |
| 1 | `HAS_SOURCE_MAP` | File contains a Source Map section |
| 2 | `HAS_BREAKPOINTS` | File contains a Breakpoints section |
| 3â€“15 | â€” | Reserved (must be 0) |

When `--strip` is used during compilation, bits 0â€“2 are cleared and debug sections are omitted.

## Section Format

Each section begins with a section header:

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0 | 2 | `section_type` | Section type tag (see table) |
| 2 | 4 | `section_length` | Byte length of section payload (excluding this header) |

**Section header: 6 bytes**, followed by `section_length` bytes of payload.

### Section Types

| Type ID | Name | Required | Description |
|---------|------|----------|-------------|
| `0x01` | String Table | âœ… | All interned strings (Spur remapping) |
| `0x02` | Function Table | âœ… | Compiled function templates |
| `0x03` | Main Chunk | âœ… | Top-level bytecode |
| `0x10` | Source Map | â€” | Source file name + PC-to-line mapping |
| `0x11` | Debug Symbols | â€” | Local variable names per function |
| `0x12` | Breakpoints | â€” | Reserved for breakpoint table |
| `0x13` | Debug Scopes | â€” | Reserved for lexical scope ranges |

Unknown section types are **skipped** (forward compatibility).

## String Table (Section `0x01`)

The string table contains all unique strings referenced by the bytecode, including:
- Symbol names (global identifiers, function names)
- Keyword names
- String constants in the constant pool
- Source file paths (in debug sections)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  count: u32                â”‚  Number of strings
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  String Entry 0            â”‚
â”‚    len: u32                â”‚  Byte length of UTF-8 data
â”‚    data: [u8; len]         â”‚  UTF-8 bytes (no null terminator)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  String Entry 1            â”‚
â”‚    ...                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

On load, each string is interned into the global `lasso::ThreadedRodeo`, producing a fresh `Spur`. The loader builds a **remap table** (`Vec<Spur>`) mapping file-local string indices to process-local Spurs.

String index `0` is reserved and must be the empty string `""`.

## Main Chunk (Section `0x03`)

The main chunk contains the top-level bytecode and its constant pool.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  code_len: u32                 â”‚
â”‚  code: [u8; code_len]          â”‚  Raw bytecode
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  n_consts: u16                 â”‚
â”‚  constants: [SerializedValue]  â”‚  Constant pool entries
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  n_spans: u32                  â”‚
â”‚  spans: [(u32 pc, u32 line,    â”‚  PC â†’ source location
â”‚           u32 col)]            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  max_stack: u16                â”‚
â”‚  n_locals: u16                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  n_exceptions: u16             â”‚
â”‚  exceptions: [ExceptionEntry]  â”‚  Exception table
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Exception Entry (16 bytes each)

| Offset | Size | Field |
|--------|------|-------|
| 0 | 4 | `try_start` (PC) |
| 4 | 4 | `try_end` (PC) |
| 8 | 4 | `handler_pc` |
| 12 | 2 | `stack_depth` |
| 14 | 2 | `catch_slot` |

## Function Table (Section `0x02`)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  count: u32                    â”‚  Number of functions
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Function Entry 0              â”‚
â”‚    name: u32                   â”‚  String table index (0xFFFFFFFF = anonymous)
â”‚    arity: u16                  â”‚
â”‚    has_rest: u8                â”‚  0 or 1
â”‚    n_upvalue_descs: u16        â”‚
â”‚    upvalue_descs: [UpvalueDesc]â”‚
â”‚    chunk: [Chunk data]         â”‚  Same format as Main Chunk
â”‚    n_local_names: u16          â”‚
â”‚    local_names: [(u16 slot,    â”‚  Local variable debug info
â”‚                   u32 name)]   â”‚  (name = string table index)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Function Entry 1              â”‚
â”‚    ...                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Upvalue Descriptor (3 bytes each)

| Offset | Size | Field |
|--------|------|-------|
| 0 | 1 | `kind`: 0 = ParentLocal, 1 = ParentUpvalue |
| 1 | 2 | `index`: slot/upvalue index in parent |

## Serialized Values (Constant Pool)

Each constant is serialized as a **type tag** (1 byte) followed by type-specific payload.

| Tag | Type | Payload |
|-----|------|---------|
| `0x00` | Nil | â€” (0 bytes) |
| `0x01` | Bool | 1 byte: `0x00` = false, `0x01` = true |
| `0x02` | Int | 8 bytes: i64 little-endian |
| `0x03` | Float | 8 bytes: f64 little-endian (IEEE 754) |
| `0x04` | String | 4 bytes: string table index (u32) |
| `0x05` | Symbol | 4 bytes: string table index (u32) |
| `0x06` | Keyword | 4 bytes: string table index (u32) |
| `0x07` | Char | 4 bytes: Unicode code point (u32) |
| `0x08` | List | 2 bytes: count (u16), then `count` recursive SerializedValues |
| `0x09` | Vector | 2 bytes: count (u16), then `count` recursive SerializedValues |
| `0x0A` | Map | 2 bytes: n_pairs (u16), then `n_pairs Ã— 2` recursive SerializedValues (key, value alternating) |
| `0x0B` | HashMap | Same as Map (`0x0A`) â€” tag distinguishes sorted vs hash map |
| `0x0C` | Bytevector | 4 bytes: length (u32), then `length` raw bytes |

### Values That Cannot Appear in Bytecode

The following `ValueView` variants are **runtime-only** and must never appear in a `.semac` constant pool:

- `Lambda` / `Macro` â€” closures are constructed at runtime via `MakeClosure`
- `NativeFn` â€” registered by the runtime, not serializable
- `Prompt` / `Message` / `Conversation` â€” constructed via `__vm-prompt` / `__vm-message`
- `ToolDef` / `Agent` â€” constructed via `__vm-deftool` / `__vm-defagent`
- `Thunk` â€” created by `delay`
- `Record` â€” constructed by `define-record-type`

If the serializer encounters any of these in a constant pool, it should emit a compile error.

## Spur Remapping

Sema uses `lasso::Spur` (process-local interned string handles) for symbols, keywords, and global variable names. These handles are **not stable** across processes.

### In the bytecode stream

Global variable opcodes (`LoadGlobal`, `StoreGlobal`, `DefineGlobal`) encode Spur values as `u32`. On serialization:

1. The serializer collects all Spurs referenced in the bytecode (globals, function names, local names)
2. Each Spur's string is added to the string table, getting a file-local index
3. The bytecode is **rewritten**: Spur-encoded u32 operands are replaced with string table indices

On deserialization:

1. The string table is loaded and each string is interned â†’ new process-local Spurs
2. A remap table maps file-local indices to process-local Spurs
3. The bytecode is walked: `LoadGlobal`/`StoreGlobal`/`DefineGlobal` operands are rewritten with the new Spur u32 values

This is the same approach Lua uses for upvalue names, and Guile uses for its symbol table.

## Source Map (Section `0x10`)

::: info Future Feature
This section is defined but not yet implemented.
:::

The source map links bytecode PCs back to source file locations, enabling error messages with file/line info when running from `.semac` files.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  source_file: u32              â”‚  String table index of source file path
â”‚  source_hash: [u8; 32]        â”‚  SHA-256 of the original source
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  n_entries: u32                â”‚
â”‚  entries: [SourceMapEntry]     â”‚  Sorted by PC, delta-encoded
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Source Map Entry (delta-encoded, variable-length)

For compact representation, entries are delta-encoded from the previous entry:

| Field | Encoding | Description |
|-------|----------|-------------|
| `delta_pc` | LEB128 u32 | PC offset from previous entry |
| `delta_line` | LEB128 i32 | Line offset from previous entry |
| `delta_col` | LEB128 i32 | Column offset from previous entry |

The first entry uses absolute values (delta from 0).

## Debug Symbols (Section `0x11`)

::: info Future Feature
This section is defined but not yet implemented.
:::

Debug symbols provide local variable names and their scope ranges within each function, enabling meaningful debugger variable inspection.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  n_functions: u32              â”‚  Must match Function Table count
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Function 0 debug info         â”‚
â”‚    n_locals: u16               â”‚
â”‚    locals: [LocalDebugEntry]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Function 1 debug info         â”‚
â”‚    ...                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Local Debug Entry

| Offset | Size | Field |
|--------|------|-------|
| 0 | 4 | `name` â€” string table index |
| 4 | 2 | `slot` â€” local variable slot |
| 6 | 4 | `scope_start` â€” PC where variable comes into scope |
| 10 | 4 | `scope_end` â€” PC where variable goes out of scope |

## Breakpoints Section (Section `0x12`)

::: info Future Feature
This section is reserved for debugger integration. Format TBD.
:::

The breakpoints section will support:
- **Persistent breakpoints** â€” set breakpoints by source location; they survive recompilation
- **Conditional breakpoints** â€” attach Sema expressions as conditions
- **Source-mapped breakpoints** â€” store breakpoints as `(file, line)` pairs, resolved to PCs on load

Planned entry format:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  n_breakpoints: u32            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Breakpoint Entry              â”‚
â”‚    source_file: u32            â”‚  String table index
â”‚    line: u32                   â”‚
â”‚    col: u32                    â”‚  0 = any column
â”‚    condition_len: u16          â”‚  0 = unconditional
â”‚    condition: [u8]             â”‚  Sema source expression (UTF-8)
â”‚    flags: u8                   â”‚  0x01 = enabled, 0x02 = one-shot
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Debug Scopes Section (Section `0x13`)

::: info Future Feature
This section is reserved for lexical scope tracking. Format TBD.
:::

Debug scopes will map PC ranges to lexical scopes, enabling:
- Accurate "step over" / "step into" behavior
- Proper variable shadowing display in debuggers
- Scope-aware watch expressions

## Validation

When loading a `.semac` file, the loader performs these checks:

1. **Magic number** â€” must be `\x00SEM`
2. **Format version** â€” must be supported by this Sema version
3. **Section completeness** â€” all three required sections must be present
4. **String table bounds** â€” all string table indices in the file must be in range
5. **Function table bounds** â€” all `func_id` references in `MakeClosure` must be valid
6. **Constant pool types** â€” no runtime-only value types in the constant pool
7. **Bytecode well-formedness** â€” opcodes must be valid, operand sizes must be correct

If validation fails, the loader returns a `SemaError` with a descriptive message.

## Example

Given this source file:

```scheme
;; hello.sema
(define greeting "Hello, World!")
(println greeting)
```

The compiled `.semac` would contain:

**String Table**: `["", "greeting", "println", "Hello, World!"]`

**Main Chunk bytecode** (conceptual):
```
0000  CONST         0    ; "Hello, World!" (string constant)
0003  DEFINE_GLOBAL 1    ; greeting (string table index â†’ Spur)
0008  LOAD_GLOBAL   2    ; println
0013  LOAD_GLOBAL   1    ; greeting
0018  CALL          1
0021  RETURN
```

**Function Table**: (empty â€” no inner functions)

## Versioning Strategy

- `format_version` starts at `1` and increments on any breaking change to the binary format
- `sema_major`/`sema_minor`/`sema_patch` record the compiler version for diagnostics
- A newer Sema can refuse to load bytecode from an older format version with a clear error: `"Bytecode format v1 not supported by this Sema version (expected v2+). Recompile from source."`
- Within the same `format_version`, new section types can be added without breaking older loaders (unknown sections are skipped)

## Comparison with Other Languages

| Feature | Sema (`.semac`) | Lua (`luac.out`) | Python (`.pyc`) | Erlang (`.beam`) | Guile (`.go`) |
|---------|-----------------|------------------|-----------------|------------------|---------------|
| Format | Flat sections | Flat binary | Header + marshal | IFF chunks | ELF container |
| Portable | No (version-tied) | No (arch-tied) | No (version-tied) | Yes | Yes |
| Debug info | Optional sections | Optional (`-s` strips) | Included | Included | Included |
| Auto-detect | Magic `\x00SEM` | Magic `\033Lua` | Magic `\xNN\r\n` | Magic `FOR1` | ELF header |
| Cache invalidation | CRC-32 source hash | N/A | Timestamp or hash | N/A | N/A |
| Spur/symbol remap | String table + rewrite | Upvalue names | marshal interning | Atom table | Symbol table |

---

# Evaluator Internals

Sema's primary execution path is a tree-walking interpreter. A [bytecode VM](./bytecode-vm.md) is available as an alternative execution path (via the `--vm` CLI flag), but the tree-walker remains the default and serves as the macro expansion engine and `eval` fallback. This page documents the tree-walking evaluator. There is no JIT, no CPS transform â€” just an AST represented as `Value` nodes that get recursively evaluated. The key trick is a **trampoline** that turns tail calls into a loop, giving us tail-call optimization without growing the native Rust stack.

If you're familiar with the metacircular evaluator from [SICP](https://mitpress.mit.edu/9780262510875/structure-and-interpretation-of-computer-programs/) (Abelson & Sussman, 1996), Sema's evaluator is structurally similar â€” `eval` dispatches on expression type, `apply` handles function calls â€” but with two critical differences: the trampoline for TCO, and a mutable environment model instead of substitution.

## The Trampoline

The central abstraction is a two-variant enum:

```rust
// crates/sema-eval/src/eval.rs
pub enum Trampoline {
    Value(Value),       // done, here's the result
    Eval(Value, Env),   // tail call: evaluate this expr in this env
}
```

Every evaluation step returns a `Trampoline` instead of a `Value`. When a function wants to make a tail call â€” evaluate an expression as its final action â€” it returns `Trampoline::Eval(expr, env)` instead of recursing into `eval_value`. The caller's trampoline loop picks this up and continues iterating:

```rust
// crates/sema-eval/src/eval.rs â€” eval_value_inner
fn eval_value_inner(ctx: &EvalContext, expr: &Value, env: &Env) -> EvalResult {
    let entry_depth = ctx.call_stack_depth();
    let guard = CallStackGuard { ctx, entry_depth };

    // First iteration: use borrowed expr/env to avoid cloning
    match eval_step(ctx, expr, env) {
        Ok(Trampoline::Value(v)) => return Ok(v),
        Ok(Trampoline::Eval(next_expr, next_env)) => {
            // Need to continue â€” enter the trampoline loop with owned values
            let mut current_expr = next_expr;
            let mut current_env = next_env;
            // ... trim call stack for TCO ...
            loop {
                match eval_step(ctx, &current_expr, &current_env) {
                    Ok(Trampoline::Value(v)) => return Ok(v),
                    Ok(Trampoline::Eval(next_expr, next_env)) => {
                        // TCO: replace expr and env, continue loop
                        current_expr = next_expr;
                        current_env = next_env;
                    }
                    Err(e) => { /* attach stack trace if missing */ }
                }
            }
        }
        Err(e) => { /* attach stack trace if missing */ }
    }
}
```

The key optimization here is that `eval_value_inner` no longer clones `expr` and `env` unconditionally at entry. The first call to `eval_step` uses the borrowed references directly. Owned copies (`current_expr`, `current_env`) are only created when `eval_step` returns `Trampoline::Eval` â€” meaning a TCO continuation is needed. In the common case where the first `eval_step` returns `Trampoline::Value` (i.e., the expression doesn't involve a tail call), no cloning happens at all.

This is the same technique described in Guy Steele's ["Rabbit" compiler paper](https://dspace.mit.edu/handle/1721.1/6913) (1978), where he showed that tail calls in Scheme can be compiled as jumps. In a native-code compiler (like Chez Scheme), the tail call becomes an actual `jmp` instruction. In a tree-walking interpreter, we can't jump â€” but we can return a "please evaluate this next" token and loop. The trampoline bounces between returning tokens and evaluating them, hence the name.

### Concrete Example

Consider this tail-recursive loop:

```scheme
(define (loop n)
  (if (= n 0)
    "done"
    (loop (- n 1))))

(loop 1000000)
```

Without TCO, `(loop 1000000)` would push one million Rust stack frames and crash. With the trampoline:

1. `eval_step` sees `(loop 1000000)`, evaluates `loop` to a `Lambda`, evaluates `1000000`, calls `apply_lambda`
2. `apply_lambda` creates a new env with `n = 1000000`, evaluates the `if` body
3. The `if` special form tests `(= n 0)` â†’ false, so it returns `Trampoline::Eval((loop (- n 1)), env)` â€” **not** a recursive call
4. Back in `eval_value_inner`, the loop picks up `(loop 999999)` as the new `current_expr` and continues
5. This repeats 1,000,000 times in constant Rust stack space

The key insight: `if` is a special form that returns `Trampoline::Eval` for its branches, and `apply_lambda` returns `Trampoline::Eval` for its last body expression. These are the two main sources of tail calls.

### How This Differs From Other Approaches

- **CPS (Continuation-Passing Style):** Some Scheme compilers (such as earlier versions of Orbit and Rabbit) use CPS as an intermediate representation, making every call a tail call. This supports `call/cc` naturally but requires a whole-program transformation. Modern compilers like Chez Scheme use other strategies (nanopass compilation with explicit stack frames). Sema doesn't do CPS; only calls in tail position are optimized.
- **Bytecode VM:** CPython and Lua compile to bytecode and run a `switch`-dispatch loop. The VM's instruction pointer replaces the trampoline. Bytecode is faster (smaller dispatch overhead, better cache behavior) but more complex to implement. Sema now has its own bytecode VM in `sema-vm`, available via `--vm` â€” see [Bytecode VM](./bytecode-vm.md) for details.
- **Direct recursion:** The metacircular evaluator in SICP chapter 4 just calls `eval` recursively. Simple, but blows the stack on deep tail recursion. Sema started this way and migrated to the trampoline.

## eval_step: A Single Step

`eval_step` takes an expression and an environment, and returns one `Trampoline`:

```rust
// crates/sema-eval/src/eval.rs
fn eval_step(ctx: &EvalContext, expr: &Value, env: &Env) -> Result<Trampoline, SemaError> {
    match expr {
        // Self-evaluating forms
        Value::Nil | Value::Bool(_) | Value::Int(_) | Value::Float(_)
        | Value::String(_) | Value::Char(_) | Value::Keyword(_)
        | Value::Thunk(_) | Value::Bytevector(_) | Value::HashMap(_)
            => Ok(Trampoline::Value(expr.clone())),

        // Symbol lookup
        Value::Symbol(spur) => env.get(*spur)
            .map(Trampoline::Value)
            .ok_or_else(|| SemaError::Unbound(resolve(*spur))),

        // Vector/Map: evaluate elements recursively
        Value::Vector(items) => { /* eval each element */ }
        Value::Map(map)      => { /* eval each key and value */ }

        // List: special forms, then function application
        Value::List(items) => { /* see below */ }
    }
}
```

The dispatch order matters:

1. **Self-evaluating:** Numbers, strings, booleans, nil, keywords, etc. return themselves immediately. These are the leaves of every evaluation.
2. **Symbols:** Look up the binding in the environment chain. If not found, return `SemaError::Unbound`.
3. **Vectors and maps:** Evaluate each element/entry recursively (these are _not_ in tail position, so they call `eval_value` directly).
4. **Lists:** The interesting case â€” check for special forms first, then evaluate the head and dispatch on its type.

### List Evaluation

When `eval_step` encounters a list `(head arg1 arg2 ...)`:

```rust
// Check head for a special form (O(1) integer comparison)
if let Value::Symbol(spur) = head {
    if let Some(result) = special_forms::try_eval_special(*spur, args, env) {
        return result;
    }
}

// Not a special form â€” evaluate the head to get the callable
let func = eval_value(head, env)?;

// Dispatch on callable type
match &func {
    Value::NativeFn(native) => { /* evaluate args, call Rust fn */ }
    Value::Lambda(lambda)   => { /* evaluate args, apply_lambda */ }
    Value::Macro(mac)       => { /* pass unevaluated args, expand */ }
    Value::Keyword(spur)    => { /* keyword-as-function: (:key map) */ }
    other                   => Err("not callable")
}
```

Note: the head is checked for special forms _before_ it's evaluated. This is essential â€” `if`, `define`, `lambda`, etc. must not evaluate their arguments eagerly.

## Special Form Dispatch

Special form dispatch is the hottest path in the evaluator. Every list expression checks whether its head symbol is one of ~39 special forms. Sema optimizes this with pre-interned `Spur` constants:

```rust
// crates/sema-eval/src/special_forms.rs
struct SpecialFormSpurs {
    quote: Spur,
    if_: Spur,
    cond: Spur,
    define: Spur,
    lambda: Spur,
    // ... 34 more
}
```

These are initialized once and leaked into a `&'static` reference via `Box::leak`:

```rust
thread_local! {
    static SF: Cell<Option<&'static SpecialFormSpurs>> = const { Cell::new(None) };
}

fn special_forms() -> &'static SpecialFormSpurs {
    SF.with(|cell| match cell.get() {
        Some(sf) => sf,
        None => {
            let sf: &'static SpecialFormSpurs = Box::leak(Box::new(SpecialFormSpurs::init()));
            cell.set(Some(sf));
            sf
        }
    })
}
```

The `Box::leak` trick converts a heap allocation into a `&'static` reference that lives for the rest of the program. This is safe because the special form names never change. The result: `try_eval_special` is a chain of integer comparisons (`head_spur == sf.if_`), with no string resolution, no hashing, and no allocation.

```rust
pub fn try_eval_special(
    head_spur: Spur,
    args: &[Value],
    env: &Env,
) -> Option<Result<Trampoline, SemaError>> {
    let sf = special_forms();
    if head_spur == sf.quote {
        Some(eval_quote(args))
    } else if head_spur == sf.if_ {
        Some(eval_if(args, env))
    } else if head_spur == sf.define {
        Some(eval_define(args, env))
    }
    // ... 36 more branches
    else {
        None  // not a special form
    }
}
```

The function returns `Option<Result<...>>` â€” `None` means "not a special form, proceed with function application." This two-level return type avoids the need for a separate "is this a special form?" check.

**Literature:** This is essentially the same optimization that McCarthy's LISP 1.5 used in 1962 â€” special forms were identified by their atom pointer, not by string comparison. The `Spur` is Sema's version of the atom pointer.

## Function Application

There are four callable types, each handled differently:

### NativeFn

Native functions are Rust closures wrapped in `Value::NativeFn`. They receive evaluated arguments and return a `Value`:

```rust
Value::NativeFn(native) => {
    let mut eval_args = Vec::with_capacity(args.len());
    for arg in args {
        eval_args.push(eval_value(ctx, arg, env)?);
    }
    ctx.push_call_frame(CallFrame { name: native.name.to_string(), ... });
    match (native.func)(ctx, &eval_args) {
        Ok(v) => {
            ctx.truncate_call_stack(ctx.call_stack_depth().saturating_sub(1));
            Ok(Trampoline::Value(v))
        }
        Err(e) => Err(e),  // leave frame for stack trace
    }
}
```

Native functions always return `Trampoline::Value` â€” they don't participate in TCO because their API returns `Result<Value, SemaError>` rather than `Trampoline`, so they can't request a tail-eval step. The call frame is pushed before the call and popped on success; on error, it's left in place so the stack trace captures it.

### Lambda

Lambdas are the heart of TCO. After evaluating arguments, `apply_lambda` binds parameters and returns `Trampoline::Eval` for the last body expression:

```rust
// crates/sema-eval/src/eval.rs
fn apply_lambda(ctx: &EvalContext, lambda: &Lambda, args: &[Value]) -> Result<Trampoline, SemaError> {
    let new_env = Env::with_parent(Rc::new(lambda.env.clone()));

    // Bind parameters (with rest-param support)
    for (param, arg) in lambda.params.iter().zip(args.iter()) {
        new_env.set(sema_core::intern(param), arg.clone());
    }

    // Self-reference for recursion
    if let Some(ref name) = lambda.name {
        new_env.set(sema_core::intern(name), Value::Lambda(Rc::new(lambda.clone())));
    }

    // Evaluate all body exprs except the last
    for expr in &lambda.body[..lambda.body.len() - 1] {
        eval_value(ctx, expr, &new_env)?;
    }

    // TCO: return the last body expr for the trampoline to handle
    Ok(Trampoline::Eval(lambda.body.last().unwrap().clone(), new_env))
}
```

This is where TCO actually happens. The last expression is _not_ evaluated by `apply_lambda` â€” it's returned as `Trampoline::Eval` so the trampoline loop can evaluate it without growing the stack. Non-tail body expressions (everything except the last) are evaluated normally via `eval_value`.

Named lambdas bind themselves in the new environment, enabling direct recursion without requiring `letrec` or `Y-combinator` gymnastics.

### Macro

Macros receive unevaluated arguments, evaluate their body to produce an expansion, and then return `Trampoline::Eval` to evaluate the expansion in the caller's environment:

```rust
Value::Macro(mac) => {
    let expanded = apply_macro(mac, args, env)?;
    Ok(Trampoline::Eval(expanded, env.clone()))
}
```

This means macro expansion is always in tail position â€” the expanded code gets the full benefit of TCO. A macro that expands to a tail call will be optimized just like a direct tail call.

### Keyword-as-Function

Keywords can be used as functions for map lookup: `(:name person)` is equivalent to `(get person :name)`. This is syntactic sugar evaluated directly in `eval_step`, not a general callable mechanism.

## `call_value`: Calling Functions from Stdlib

The `call_value` function is the public API for calling any callable `Value` with pre-evaluated arguments. It's the entry point used by stdlib higher-order functions (`map`, `filter`, `fold`, etc.) when they need to invoke a user-supplied callback:

```rust
// crates/sema-eval/src/eval.rs
pub fn call_value(ctx: &EvalContext, func: &Value, args: &[Value]) -> EvalResult {
    match func {
        Value::NativeFn(native) => (native.func)(ctx, args),
        Value::Lambda(lambda) => {
            // Create env, bind params (with rest-param support), eval body
            let new_env = Env::with_parent(Rc::new(lambda.env.clone()));
            // ... parameter binding ...
            let mut result = Value::Nil;
            for expr in &lambda.body {
                result = eval_value(ctx, expr, &new_env)?;
            }
            Ok(result)
        }
        Value::Keyword(spur) => {
            // Keyword-as-function: (:key map) => map lookup
            // ...
        }
        other => Err(SemaError::eval("not callable")),
    }
}
```

Unlike `apply_lambda` (used by `eval_step` during normal evaluation), `call_value` does **not** use the trampoline â€” it evaluates the lambda body directly via `eval_value`, including the last expression. This is intentional: `call_value` is called from Rust code (stdlib native functions) that needs a `Value` result, not a `Trampoline`. The trade-off is that callbacks invoked through `call_value` don't get TCO on their own body â€” but in practice this doesn't matter, because stdlib HOFs like `map` and `filter` iterate externally rather than recursing.

### Callback Architecture

Stdlib functions live in `sema-stdlib`, which depends on `sema-core` but **not** on `sema-eval`. This means stdlib can't call `eval_value` or `call_value` directly. Instead, `sema-core` provides thread-local callback slots:

```rust
// sema-core: thread-local function pointers
sema_core::set_eval_callback(eval_value);   // registered by sema-eval at init
sema_core::set_call_callback(call_value);   // registered by sema-eval at init
```

When a stdlib HOF like `map` needs to call a user function, it calls `sema_core::call_callback(ctx, func, args)`, which dispatches to the registered `call_value`. This indirection preserves the dependency invariant (`core â† eval â† stdlib`) while giving stdlib full access to the evaluator.

## Stack Traces

Sema maintains a call stack in the `EvalContext` for error reporting:

```rust
// crates/sema-core/src/context.rs
pub struct EvalContext {
    // ... other fields
    pub call_stack: RefCell<Vec<CallFrame>>,
    // ...
}
```

Each `CallFrame` captures the function name, current file, and source span:

```rust
// crates/sema-core
pub struct CallFrame {
    pub name: String,
    pub file: Option<String>,
    pub span: Option<Span>,
}
```

### Source Span Tracking

Source spans are tracked using a pointer-identity trick. The reader stores `Span` information in a `HashMap<usize, Span>` keyed by the `Rc::as_ptr` address of each list's backing `Vec`:

```rust
fn span_of_expr(ctx: &EvalContext, expr: &Value) -> Option<Span> {
    match expr {
        Value::List(items) => {
            let ptr = Rc::as_ptr(items) as usize;
            ctx.lookup_span(ptr)
        }
        _ => None,
    }
}
```

This avoids storing spans inside `Value` (which would increase the size of every value). The trade-off: spans are only available for list expressions (and vectors, which the reader also registers). Spans remain valid across `Rc::clone()` calls since cloning an `Rc` preserves the inner pointer. They only become stale if a list is _rebuilt_ into a new `Rc<Vec<_>>` (e.g., by `map` or `filter` constructing a fresh vector). In practice this works well because error-producing expressions are typically the original parsed forms.

### RAII Stack Management

The call stack is managed with a guard struct that truncates on drop:

```rust
struct CallStackGuard<'a> {
    ctx: &'a EvalContext,
    entry_depth: usize,
}

impl Drop for CallStackGuard<'_> {
    fn drop(&mut self) {
        self.ctx.truncate_call_stack(self.entry_depth);
    }
}
```

This ensures the call stack is cleaned up even if evaluation panics or returns early via `?`. The guard is created at the top of `eval_value_inner` and persists for the duration of the trampoline loop.

### Tail Call Frame Trimming

When the trampoline handles a tail call (`Trampoline::Eval`), it trims accumulated call frames above the entry depth, keeping only the most recent one:

```rust
Ok(Trampoline::Eval(next_expr, next_env)) => {
    {
        let mut stack = ctx.call_stack.borrow_mut();
        if stack.len() > entry_depth + 1 {
            let top = stack.last().cloned();
            stack.truncate(entry_depth);
            if let Some(frame) = top {
                stack.push(frame);
            }
        }
    }
    current_expr = next_expr;
    current_env = next_env;
}
```

Without this trimming, a tail-recursive loop of 1M iterations would accumulate 1M call frames â€” the stack trace wouldn't overflow the Rust stack, but it would consume unbounded memory. The trim keeps exactly one frame for the current function, which is all you need to know where execution is.

## Guardrails

### MAX_EVAL_DEPTH (1024)

The evaluator tracks nesting depth via the `eval_depth` field in `EvalContext`, incremented on every `eval_value` call and decremented on return. However, `eval_value` has a **fast path** at the top that short-circuits self-evaluating forms and symbol lookups _before_ any depth tracking or step counting:

```rust
const MAX_EVAL_DEPTH: usize = 1024;

pub fn eval_value(ctx: &EvalContext, expr: &Value, env: &Env) -> EvalResult {
    // Fast path: self-evaluating forms skip depth/step tracking entirely.
    match expr {
        Value::Nil | Value::Bool(_) | Value::Int(_) | Value::Float(_)
        | Value::String(_) | Value::Char(_) | Value::Keyword(_)
        | Value::Thunk(_) | Value::Bytevector(_) | Value::NativeFn(_)
        | Value::Lambda(_) | Value::HashMap(_) => return Ok(expr.clone()),
        Value::Symbol(spur) => {
            if let Some(val) = env.get(*spur) {
                return Ok(val);
            }
            return Err(SemaError::Unbound(resolve(*spur)));
        }
        _ => {}
    }

    // Only non-trivial expressions (lists, vectors, maps) reach here
    let depth = ctx.eval_depth.get();
    ctx.eval_depth.set(depth + 1);
    if depth > MAX_EVAL_DEPTH {
        ctx.eval_depth.set(ctx.eval_depth.get().saturating_sub(1));
        return Err(SemaError::eval("maximum eval depth exceeded (1024)"));
    }
    // ...
}
```

This fast path is a significant optimization: self-evaluating forms (numbers, strings, booleans, nil, keywords, lambdas, native functions, etc.) and symbol lookups are the most common expressions, and they never need depth tracking because they can't recurse. By returning immediately, they avoid the overhead of incrementing/decrementing the depth counter and checking the step limit. Only compound expressions â€” lists, vectors, and maps â€” fall through to the depth-tracked path.

This protects against non-tail recursion that the trampoline can't help with â€” for example, `(f (f (f ...)))` nests `eval_value` calls for each argument evaluation. The limit of 1024 is generous enough for real programs but prevents native stack overflow.

Note that tail-recursive loops do _not_ increase the depth counter, because each iteration returns from `eval_value_inner` via the trampoline loop rather than nesting a new `eval_value` call.

### EVAL_STEP_LIMIT (Fuzzing)

For fuzz testing, an optional step counter limits the total number of trampoline iterations:

```rust
// Fields in EvalContext (crates/sema-core/src/context.rs)
pub eval_step_limit: Cell<usize>,
pub eval_steps: Cell<usize>,
```

When the limit is non-zero, every trampoline step increments `ctx.eval_steps` and checks against the limit. This catches infinite loops that the depth limit can't â€” a tail-recursive `(define (f) (f))` uses O(1) stack depth but infinite steps. The step counter is reset at each top-level `eval_value` call (when `ctx.eval_depth` is 0).

## Environment Model

Sema uses a linked-list scope chain, where each scope is a `BTreeMap` keyed by `Spur`:

```rust
// crates/sema-core/src/value.rs
pub struct Env {
    pub bindings: Rc<RefCell<BTreeMap<Spur, Value>>>,
    pub parent: Option<Rc<Env>>,
}
```

`Rc<RefCell<...>>` makes each scope mutable and reference-counted. `BTreeMap<Spur, Value>` provides deterministic ordering (important for printing and testing) and is faster than `HashMap` for the very small maps (1â€“5 entries) typical of `let` and `lambda` scopes â€” at that size, a few integer comparisons in the B-tree node are cheaper than computing a hash (see the [Performance Internals](performance.md#rejected-optimizations) page for the benchmark).

### Operations

| Method                    | Behavior                                                      |
| ------------------------- | ------------------------------------------------------------- |
| `get(spur)`               | Walk the parent chain, return first match                     |
| `set(spur, val)`          | Insert into the current (innermost) scope                     |
| `set_existing(spur, val)` | Walk the chain, update where found (for `set!`)               |
| `take(spur)`              | Remove from current scope only (for COW optimization)         |
| `take_anywhere(spur)`     | Remove from any scope in the chain                            |
| `update(spur, val)`       | Overwrite in current scope without re-hashing (for hot loops) |

The `take` method is critical for the copy-on-write map optimization described in the Performance page â€” by removing a value from the environment before passing it to a function, the `Rc` reference count drops to 1, enabling in-place mutation.

**Literature:** This is the standard lexical environment model described in _Lisp in Small Pieces_ (Queinnec, 1996, Chapter 6) â€” a chain of frames linked by static (lexical) pointers. The alternative for lexical scoping â€” flat closures that copy all free variables into each closure â€” is faster for lookup but uses more memory when closures share large environments. Sema uses the chained model because closures are pervasive and lookup cost is dominated by the `Spur` integer comparison, not chain traversal.

## Adding a Special Form

If you need to add a new special form to Sema:

1. **Add a `Spur` field** to `SpecialFormSpurs` in `crates/sema-eval/src/special_forms.rs` and initialize it in `init()` with `intern("your-form-name")`
2. **Add a match arm** in `try_eval_special()` â€” return `Some(eval_your_form(args, env))`
3. **Implement `eval_your_form`** â€” it receives `args: &[Value]` (unevaluated), `env: &Env`, and `ctx: &EvalContext`, and must return `Result<Trampoline, SemaError>`. If the form has a natural tail position (like `if`'s branches), return `Trampoline::Eval` for TCO; otherwise return `Trampoline::Value`
4. **Add an integration test** in `crates/sema/tests/integration_test.rs`
5. **Document the form** in `website/docs/language/special-forms.md`

## Further Reading

- Christian Queinnec, [_Lisp in Small Pieces_](https://www.cambridge.org/core/books/lisp-in-small-pieces/66FD2BE3EDDDC68588A4605F14A4D2A4) (Cambridge, 1996) â€” the canonical deep-dive into Lisp interpreter and compiler implementation, covering environment models, continuations, and compilation strategies
- Guy Lewis Steele Jr., ["Rabbit: A Compiler for Scheme"](https://dspace.mit.edu/handle/1721.1/6913) (MIT AI Memo 474, 1978) â€” introduces the trampoline concept and proves that tail calls can be implemented as jumps
- Abelson & Sussman, [_Structure and Interpretation of Computer Programs_](https://mitpress.mit.edu/9780262510875/structure-and-interpretation-of-computer-programs/) (MIT Press, 1996) â€” Chapter 4's metacircular evaluator is the template for Sema's `eval_step`/`apply_lambda` split; Chapter 5 shows how to compile to a register machine
- R. Kent Dybvig, ["Three Implementation Models for Scheme"](https://www.cs.indiana.edu/~dyb/pubs/3imp.pdf) (PhD thesis, 1987) â€” compares heap-based, stack-based, and string-based models; Sema uses heap-based (Rc+RefCell scopes)

---

# Reader Internals

Sema's reader is a two-phase pipeline: a lexer tokenizes source text into `SpannedToken`s, then a recursive descent parser produces `Value` nodes directly â€” there is no intermediate AST. Source locations are tracked per-token and attached to compound values via an `Rc::as_ptr` trick that avoids bloating the `Value` enum.

This page documents the lexer, parser, token types, quote desugaring, span tracking, and how the evaluator recovers source positions for error reporting.

## The Lexer

The lexer in `crates/sema-reader/src/lexer.rs` is a single-pass tokenizer that walks a `Vec<char>` with a manual index `i` and tracks `line`/`col` for span information.

Character-level dispatch drives the lexer. Each iteration inspects the current character and branches:

- **Whitespace** â€” skipped, advances `line`/`col`
- **`;`** â€” comment, skip to end of line
- **`(`/`)`/`[`/`]`/`{`/`}`** â€” emit the corresponding bracket token
- **`'`** â€” emit `Token::Quote`
- **`` ` ``** â€” emit `Token::Quasiquote`
- **`,`** â€” peek ahead: `,@` emits `Token::UnquoteSplice`, otherwise `Token::Unquote`
- **`"`** â€” enter string mode, handle escape sequences
- **`#`** â€” dispatch on next char: `#t`/`#f` for booleans, `#\` for character literals, `#u8(` for bytevector start
- **`:`** â€” keyword (Clojure-style `:foo`)
- **Digit or `-` followed by digit** â€” number (integer or float)
- **Otherwise** â€” symbol character, accumulate until delimiter

Every token is wrapped in a `SpannedToken` that records the `Span { line, col }` where it began. This is the only place source positions enter the system â€” everything downstream inherits or discards them.

```rust
// crates/sema-reader/src/lexer.rs
pub struct SpannedToken {
    pub token: Token,
    pub span: Span,
}

pub struct Span {
    pub line: usize,
    pub col: usize,
}
```

## Token Zoo

The full `Token` enum:

| Token                   | Syntax           | Example                 |
| ----------------------- | ---------------- | ----------------------- |
| `LParen` / `RParen`     | `(` `)`          | `(+ 1 2)`               |
| `LBracket` / `RBracket` | `[` `]`          | `[1 2 3]`               |
| `LBrace` / `RBrace`     | `{` `}`          | `{:a 1 :b 2}`           |
| `Quote`                 | `'`              | `'foo`                  |
| `Quasiquote`            | `` ` ``          | `` `(a ,b) ``           |
| `Unquote`               | `,`              | `,x`                    |
| `UnquoteSplice`         | `,@`             | `,@xs`                  |
| `Int(i64)`              | digits           | `42`, `-7`              |
| `Float(f64)`            | digits with `.`  | `3.14`, `-0.5`          |
| `String(String)`        | `"..."`          | `"hello"`               |
| `Symbol(String)`        | identifier       | `define`, `string/trim` |
| `Keyword(String)`       | `:` + name       | `:key`, `:name`         |
| `Bool(bool)`            | `#t` / `#f`      | `#t`                    |
| `Char(char)`            | `#\` + char/name | `#\a`, `#\space`        |
| `BytevectorStart`       | `#u8(`           | `#u8(1 2 3)`            |
| `Dot`                   | `.`              | `(a . b)`               |

Symbol characters include alphanumeric plus `+ - * / ! ? < > = _ & % ^ ~ .` â€” a superset of Scheme's identifier syntax that allows operators and predicates like `nil?` or `string->number` as plain symbols.

Booleans accept both `#t`/`#f` (R7RS) and `true`/`false` (as symbol aliases resolved during tokenization).

## The Parser

The parser in `crates/sema-reader/src/reader.rs` is a recursive descent parser that consumes the `Vec<SpannedToken>` produced by the lexer. It's structured as a `Parser` struct with a position index, dispatching on the current token type:

```
parse_expr
  â”œâ”€â”€ LParen    â†’ parse_list     â†’ Value::List
  â”œâ”€â”€ LBracket  â†’ parse_vector   â†’ Value::Vector
  â”œâ”€â”€ LBrace    â†’ parse_map      â†’ Value::Map
  â”œâ”€â”€ Quote     â†’ desugar        â†’ Value::List [quote, x]
  â”œâ”€â”€ Quasiquoteâ†’ desugar        â†’ Value::List [quasiquote, x]
  â”œâ”€â”€ Unquote   â†’ desugar        â†’ Value::List [unquote, x]
  â”œâ”€â”€ UnquoteSplice â†’ desugar    â†’ Value::List [unquote-splicing, x]
  â”œâ”€â”€ BytevectorStart â†’ parse_bytevector â†’ Value::Bytevector
  â”œâ”€â”€ Int       â†’ Value::Int
  â”œâ”€â”€ Float     â†’ Value::Float
  â”œâ”€â”€ String    â†’ Value::String
  â”œâ”€â”€ Symbol    â†’ Value::Symbol
  â”œâ”€â”€ Keyword   â†’ Value::Keyword
  â”œâ”€â”€ Bool      â†’ Value::Bool
  â””â”€â”€ Char      â†’ Value::Char
```

Each compound form has its own parsing method:

- **`parse_list`** â€” collects expressions until `)`, handling dotted pairs (see below)
- **`parse_vector`** â€” collects expressions until `]`, wraps in `Value::Vector(Rc::new(vec![...]))`
- **`parse_map`** â€” collects key-value pairs until `}`, wraps in `Value::Map(Rc::new(BTreeMap::from(...)))`. Odd element count is a parse error
- **`parse_bytevector`** â€” collects integers until `)`, validates each is 0â€“255, wraps in `Value::Bytevector(Rc::new(vec![...]))`

The parser produces `Value` nodes directly. There is no separate AST type â€” the same `Value` enum used at runtime is the representation of parsed code. This is the Lisp tradition: code is data, and the reader produces data.

> **Comparison:** Racket's reader is configurable with [readtables](https://docs.racket-lang.org/reference/readtables.html) â€” user code can define new reader syntax. Common Lisp goes further with [reader macros](http://www.lispworks.com/documentation/HyperSpec/Body/02_d.htm) that can override any character's parsing behavior. Sema has neither â€” quote sugar is hardcoded in the lexer, and there's no mechanism for user-defined reader extensions. This is a deliberate simplicity trade-off: the reader is predictable, the implementation is ~300 lines, and all syntax is documented in one place. See Nystrom's [_Crafting Interpreters_](https://craftinginterpreters.com/parsing-expressions.html) for a thorough treatment of recursive descent parsing, or Aho et al., _Compilers: Principles, Techniques, and Tools_ (the Dragon Book), Â§4.4 for the theory.

## Quote Desugaring

The reader desugars quote syntax into real lists _before the evaluator ever sees them_. This is important: `'x` is not a special syntactic form that the evaluator handles â€” it's reader sugar that produces a `(quote x)` list.

| Syntax   | Desugars to            | Reader token           |
| -------- | ---------------------- | ---------------------- |
| `'x`     | `(quote x)`            | `Token::Quote`         |
| `` `x `` | `(quasiquote x)`       | `Token::Quasiquote`    |
| `,x`     | `(unquote x)`          | `Token::Unquote`       |
| `,@x`    | `(unquote-splicing x)` | `Token::UnquoteSplice` |

When the parser encounters a `Quote` token, it:

1. Consumes the next expression (recursive `parse_expr` call)
2. Wraps it: `Value::List(Rc::new(vec![Value::symbol("quote"), expr]))`
3. Attaches the quote token's span to the resulting list

The evaluator then sees `(quote x)` as a normal list whose `car` is the symbol `quote` â€” which it handles as a special form. The same applies to `quasiquote`, which the evaluator expands recursively (handling nested `unquote` and `unquote-splicing` within templates).

The key distinction: the _syntax_ (`` ` , ,@ ' ``) is reader-level, but the _semantics_ (what `quasiquote` does with its template) is evaluator-level. The reader's job is just to produce the list structure.

## Dotted Pairs

Sema supports dotted pair notation `(a . b)` for compatibility with Scheme's cons-cell tradition, but the representation is unconventional. Since `Value::List` wraps a `Vec<Value>` (not a linked list of cons cells), dotted pairs are represented using a marker symbol:

```scheme
(a . b)    ;; parses as a list of three elements: [a, ".", b]
(1 2 . 3)  ;; parses as: [1, 2, ".", 3]
```

The parser's `parse_list` method detects `Token::Dot` and inserts `Value::symbol(".")` into the element list. The evaluator and printer check for this marker when they need to distinguish `(a b c)` from `(a b . c)`.

This is a pragmatic compromise. Real Scheme implementations use linked cons cells where `(a . b)` is `cons(a, b)` â€” the dot is the _absence_ of a list, not a marker within one. Sema's Vec-based representation can't express improper lists natively, so the dot marker serves as an escape hatch for the few places that need it (mostly association lists and Scheme compatibility).

## String Escapes

The lexer handles common R7RS escape sequences plus Unicode extensions:

| Escape       | Character       | Notes                                       |
| ------------ | --------------- | ------------------------------------------- |
| `\n`         | newline         |                                             |
| `\t`         | tab             |                                             |
| `\r`         | carriage return |                                             |
| `\\`         | backslash       |                                             |
| `\"`         | double quote    |                                             |
| `\0`         | null            |                                             |
| `\x41;`      | `A` (hex 0x41)  | R7RS â€” note the trailing semicolon          |
| `\u0041`     | `A`             | 4-digit Unicode escape                      |
| `\U00000041` | `A`             | 8-digit Unicode escape (full Unicode range) |

The R7RS hex escape `\x<hex>;` uses a semicolon terminator, which is unusual â€” most languages use a fixed digit count. This allows variable-length hex sequences: `\x41;` and `\x041;` are both valid and produce the same character. The semicolon disambiguates where the hex digits end.

The `\uNNNN` and `\UNNNNNNNN` forms follow the C/Java/Rust convention of fixed-width escapes. These are Sema extensions not found in R7RS.

Character literals follow a similar pattern:

| Literal     | Character         |
| ----------- | ----------------- |
| `#\a`       | the character `a` |
| `#\space`   | space             |
| `#\newline` | newline           |
| `#\tab`     | tab               |
| `#\return`  | carriage return   |
| `#\nul`     | null              |

## Span Tracking

This is the most architecturally interesting part of the reader. The problem: error messages need source locations ("line 12, column 5"), but storing a `Span` in every `Value` would bloat the enum. Most values are small â€” `Value::Int(42)` is 16 bytes â€” and adding a `Span` field would double the size of every value in the system, including runtime values that were never parsed from source.

**The solution:** spans are stored in a side table keyed by `Rc` pointer addresses.

```rust
// crates/sema-reader/src/reader.rs
fn make_list_with_span(&mut self, items: Vec<Value>, span: Span) -> Result<Value, SemaError> {
    let rc = Rc::new(items);
    let ptr = Rc::as_ptr(&rc) as usize;
    self.span_map.insert(ptr, span);
    Ok(Value::List(rc))
}
```

The `SpanMap` is a `HashMap<usize, Span>` â€” it maps `Rc::as_ptr()` cast to `usize` to the source span. This works because:

1. **`Rc::as_ptr` is stable** â€” for a given `Rc`, the inner pointer doesn't change as long as the `Rc` (or any clone of it) is alive
2. **Clones share the pointer** â€” `Rc::clone()` increments the refcount but doesn't change the underlying pointer, so a cloned list still maps to the same span
3. **No cost to non-compound values** â€” atoms (integers, strings, symbols) don't get spans. Both `Value::List` and `Value::Vector` participate in span tracking â€” the reader inserts their `Rc::as_ptr()` addresses into the span map. However, the evaluator's `span_of_expr` currently only recovers spans from `Value::List`; vector spans are tracked by the reader but not used during error reporting

**The trade-off:** when the `Rc` is deallocated, its pointer address could be reused by a new allocation, producing a stale span lookup. In practice this is a minor diagnostic risk rather than a correctness issue â€” a wrong span in an error message is better than no span. The span table accumulates entries across parsed inputs; in long-running processes (REPL, embedding), stale entries could theoretically produce misleading source locations, though this has not been observed in practice. Also, only list-shaped values get spans. An error in evaluating an atom like `undefined-var` won't have a direct span â€” the evaluator must use the span of the enclosing list expression instead.

### Span Recovery in the Evaluator

The span table is a field in `EvalContext`, populated when source is parsed via `ctx.merge_span_table(spans)`:

```rust
// crates/sema-eval/src/eval.rs
fn span_of_expr(ctx: &EvalContext, expr: &Value) -> Option<Span> {
    match expr {
        Value::List(items) => {
            let ptr = Rc::as_ptr(items) as usize;
            ctx.lookup_span(ptr)
        }
        _ => None,
    }
}
```

The evaluator calls `span_of_expr` when constructing error messages, attaching the source position of the failing expression to the `SemaError`. This flows through the call stack and ultimately appears in error output like:

```
Error at line 12, col 5: undefined variable 'foo'
```

## Error Reporting

Errors flow through two mechanisms:

1. **`SemaError::Reader`** â€” carries a `Span` directly for parse-time errors (unmatched brackets, invalid escape sequences, unexpected tokens). These are produced by the lexer and parser before evaluation begins.

2. **`CallFrame` + span table** â€” for runtime errors, the evaluator maintains a call stack of `CallFrame`s. When an error occurs, it walks the stack, using `span_of_expr` to find source positions for each frame. This produces stack traces with source locations even though `Value` itself carries no span.

The combination means parse errors report exact positions (the lexer knows where every token starts), while runtime errors report the position of the enclosing list expression (the best available approximation from the span table).

## Public API

The reader exposes three entry points:

```rust
// crates/sema-reader/src/reader.rs

/// Parse a single expression from input
pub fn read(input: &str) -> Result<Value, SemaError>

/// Parse all expressions from input
pub fn read_many(input: &str) -> Result<Vec<Value>, SemaError>

/// Parse all expressions and return the span map for error reporting
pub fn read_many_with_spans(input: &str) -> Result<(Vec<Value>, SpanMap), SemaError>
```

`read_many_with_spans` is what the evaluator uses â€” it needs the span map to populate the `EvalContext`'s span table. The simpler `read` and `read_many` are convenience wrappers for contexts where error positions aren't needed (tests, REPL one-liners).

## Pipeline Summary

```
Source text
  â”‚
  â–¼
tokenize()          crates/sema-reader/src/lexer.rs
  â”‚                 "single-pass"
  â”‚                 "produces Vec<SpannedToken>"
  â–¼
Parser::parse()     crates/sema-reader/src/reader.rs
  â”‚                 "recursive descent"
  â”‚                 "produces Vec<Value> + SpanMap"
  â–¼
ctx.merge_span_table()  crates/sema-eval/src/eval.rs
  â”‚                 "populates EvalContext span table"
  â–¼
eval()              crates/sema-eval/src/eval.rs
  â”‚                 "trampoline-based TCO evaluator"
  â”‚                 "recovers spans via Rc::as_ptr lookup"
  â–¼
Value               result
```

---

# Performance Internals

Sema's default execution path is a tree-walking interpreter. A bytecode VM is available via `--vm` (see [Bytecode VM](./bytecode-vm.md)) and is significantly faster. Early optimizations brought the [1 Billion Row Challenge](https://github.com/gunnarmorling/1brc) benchmark from **~25s to ~9.6s** on 10M rows using a "mini-eval" â€” a minimal evaluator inlined in the stdlib that bypassed the full trampoline. The mini-eval was later **removed** for architectural reasons (semantic drift from the real evaluator, and blocking the path to a bytecode VM). Fast-path optimizations in the real evaluator partially recovered performance, bringing the tree-walker benchmark to **~2,900ms on 1M rows** (vs ~960ms with the mini-eval). The bytecode VM (`--vm`) now achieves **~1,700ms on 1M rows** and **~17,100ms on 10M rows**, recovering much of the mini-eval's performance through compilation rather than inlining. This page documents each optimization, its history, and measured impact.

All benchmarks were run on Apple Silicon (M-series), processing the 1BRC dataset (semicolon-delimited weather station readings, one per line).

## Benchmark Summary

| Stage              | 1M rows       | 10M rows       | Technique                          | Status                   |
| ------------------ | ------------- | -------------- | ---------------------------------- | ------------------------ |
| Baseline           | 2,501 ms      | ~25,000 ms     | Naive implementation               | â€”                        |
| + COW assoc        | 1,800 ms      | ~18,000 ms     | In-place map mutation              | âœ… Active                |
| + Env reuse        | 1,626 ms      | 16,059 ms      | Lambda env recycling (mini-eval)   | âŒ Removed               |
| + Mini-eval        | ~960 ms       | ~9,600 ms      | Inlined builtins, custom parser    | âŒ Removed               |
| + String interning | â€”             | â€”              | Spur-based dispatch                | âœ… Active                |
| + hashbrown        | â€”             | â€”              | Amortized O(1) accumulator         | âœ… Active                |
| **Post-removal**   | **~2,900 ms** | **~29,600 ms** | Callback architecture + fast paths | âœ… Current (tree-walker) |
| **Bytecode VM**    | **~1,700 ms** | **~17,100 ms** | Bytecode VM (`--vm`)               | âœ… Active                |

> **Note:** The mini-eval and its associated optimizations (env reuse, inlined builtins, custom number parser, SIMD split fast path) were removed to unblock the bytecode VM, which is now implemented and available via `--vm`. The bytecode VM provides a ~1.7Ã— speedup over the tree-walker (~1,700ms vs ~2,900ms on 1M rows), recovering much of the mini-eval's performance through compilation. The tree-walker remains the default; the current architecture uses `sema_core::call_callback` to route stdlib â†’ real evaluator. Fast-path optimizations (self-evaluating short-circuit, inline NativeFn dispatch, thread-local EvalContext, deferred cloning) partially recovered performance.

## 1. Copy-on-Write Map Mutation

**Problem:** Every `(assoc map key val)` call cloned the entire `BTreeMap`, even when no other reference existed. For the 1BRC accumulator (~400 weather stations), this was O(400) per row Ã— millions of rows.

**Solution:** Use `Rc::try_unwrap` to check if the reference count is 1. If so, take ownership and mutate in place. Otherwise, clone.

```rust
// crates/sema-stdlib/src/map.rs
match Rc::try_unwrap(m) {
    Ok(map) => map,       // refcount == 1: we own it, mutate in place
    Err(m) => m.as_ref().clone(),  // shared: must clone
}
```

The key insight is pairing this with `Env::take()` â€” by _removing_ the accumulator from the environment before passing it to `assoc`, the refcount drops to 1, enabling the in-place path. User code looks like:

```scheme
(file/fold-lines "data.csv"
  (lambda (acc line)
    (let ((parts (string/split line ";")))
      (assoc acc (first parts) (second parts))))
  {})
```

The `fold-lines` implementation moves (not clones) `acc` into the lambda env on each iteration, keeping the refcount at 1.

**Impact:** ~30% of the total speedup. Eliminated the O(n) full-map clone, leaving only the O(log n) BTreeMap insert per row.

**Literature:**

- This is the same copy-on-write strategy used by Swift's value types. (Clojure's persistent data structures solve a related problem â€” avoiding full copies â€” but via structural sharing rather than refcount-based COW.)
- Phil Bagwell, ["Ideal Hash Trees"](https://infoscience.epfl.ch/entities/publication/64410) (2001) â€” the paper behind Clojure/Scala persistent collections
- Rust's `Rc::make_mut` provides the same semantics with less ceremony

## 2. Lambda Environment Reuse _(removed)_

> **Status:** This optimization was part of the mini-eval's hot path in `io.rs`. It was removed when the mini-eval was deleted. The current `file/fold-lines` uses `sema_core::call_callback`, which routes through the real evaluator â€” each call creates a fresh `Env` via the standard `apply_lambda` path.

**What it was:** For simple lambdas (known arity, no rest params), the mini-eval created the lambda environment _once_ and reused it across all iterations, overwriting bindings in place. Combined with a reusable `line_buf`, this eliminated per-iteration allocations for `Env`, string interning, and line buffers.

**Why it was removed:** The env reuse logic was tightly coupled to the mini-eval's direct lambda dispatch. The callback architecture routes through the real evaluator's `apply_lambda`, which always creates a fresh child `Env` â€” this is correct and avoids subtle bugs from env mutation leaking across calls.

**Impact when active:** ~15% speedup (2,501ms â†’ 1,626ms combined with COW assoc).

**What remains:** The reusable `line_buf` (`String::with_capacity(64)` cleared each iteration) is still present in `file/fold-lines` â€” only the env reuse was lost.

## 3. Evaluator Callback Architecture _(replacing Mini-Eval)_

> **Status:** The mini-eval was deleted and replaced with a callback architecture. Stdlib now calls the real evaluator via `sema_core::call_callback`.

**What the mini-eval was:** `sema-stdlib` previously contained its own minimal evaluator (`sema_eval_value`) that handled common forms via direct recursive calls, inlining builtins like `+`, `=`, `assoc`, `string/split`, and `string->number` to skip `Env` lookup and `NativeFn` dispatch entirely.

**Why it was removed:**

1. **Semantic drift:** The mini-eval diverged from the real evaluator â€” new special forms, error handling, and features had to be duplicated or were silently missing.
2. **Blocking bytecode VM:** A bytecode compiler can't target two evaluators. Removing the mini-eval ensures a single evaluation path that the VM can replace.

**The callback architecture:** `sema-stdlib` cannot depend on `sema-eval` (circular dependency). Instead, `sema-eval` registers a thread-local callback (`set_call_callback`) at startup, and stdlib functions call `sema_core::call_callback` to invoke the real evaluator. A thread-local `EvalContext` (`with_stdlib_ctx`) is shared across calls to avoid per-call context allocation.

```rust
// crates/sema-stdlib/src/io.rs â€” file/fold-lines via callback
sema_core::with_stdlib_ctx(|ctx| {
    let mut line_buf = String::with_capacity(64);
    loop {
        line_buf.clear();
        let n = reader.read_line(&mut line_buf)?;
        if n == 0 { break; }
        // Calls the real evaluator (eval_value) via thread-local callback
        acc = sema_core::call_callback(ctx, &func, &[acc, Value::string(&line_buf)])?;
    }
    Ok(acc)
})
```

**Performance trade-off:** ~960ms â†’ ~2,900ms on 1M rows (~3Ã— regression). The overhead comes from the full trampoline evaluator: call stack management, span tracking, and `Trampoline` dispatch on every sub-expression.

**Fast-path optimizations that partially recovered performance:**

1. **Self-evaluating fast path:** `eval_value` short-circuits for integers, floats, strings, keywords, and symbols â€” skipping depth tracking and step limits for the most common forms.
2. **Inline NativeFn dispatch:** When the evaluator sees a `Value::NativeFn` in call position, it calls the function pointer directly without going through `call_callback` indirection.
3. **Thread-local shared EvalContext:** `with_stdlib_ctx` reuses a single `EvalContext` across all stdlib â†’ evaluator callbacks, avoiding per-call allocation of `RefCell`/`Cell` fields.
4. **Deferred cloning:** `eval_value_inner` avoids cloning the expression and environment on the first trampoline iteration, only cloning if a tail call (`Trampoline::Eval`) is returned.

**Remaining gap:** The ~3Ã— regression cannot be fully closed within the tree-walking architecture. The bytecode VM (`--vm`) â€” the reason the mini-eval was removed â€” reduces this to ~1.8Ã— vs the mini-eval (~1,700ms vs ~960ms) and is ~1.7Ã— faster than the tree-walker.

**Literature:**

- Inline caching, pioneered by Smalltalk-80 and refined in V8's hidden classes, solves the same dispatch overhead problem but at a different architectural level
- Most production Lisps (SBCL, Chez Scheme) compile to native code, making dispatch overhead negligible â€” Sema's callback overhead is inherent to tree-walking interpreters
- Lua 5.x's bytecode VM inlines common operations (`OP_ADD`, `OP_GETTABLE`) into the dispatch loop â€” this is the approach Sema's bytecode VM (`sema-vm`) takes

## 4. String Interning (lasso)

**Problem:** Symbol/keyword equality was O(n) string comparison. Environment lookups keyed by `String` required comparing the full string on each `BTreeMap` node visit. Special form dispatch compared against 30+ string literals on every list evaluation.

**Solution:** Replace `Rc<String>` in `Value::Symbol` and `Value::Keyword` with `Spur` â€” a `u32` handle from the [lasso](https://crates.io/crates/lasso) string interner. Environment bindings keyed by `Spur` for direct integer lookup.

```rust
// Before: O(n) string comparison
Value::Symbol(Rc<String>)
env: BTreeMap<String, Value>

// After: O(1) integer comparison
Value::Symbol(Spur)  // u32
env: BTreeMap<Spur, Value>
```

Special form dispatch uses pre-cached `Spur` constants:

```rust
// crates/sema-eval/src/special_forms.rs
struct SpecialFormSpurs {
    quote: Spur,
    if_: Spur,
    define: Spur,
    // ... 30 more
}

// Dispatch: integer comparison, no string resolution
if head_spur == sf.if_ {
    return Some(eval_if(args, env));
}
```

**Caveat:** The initial implementation was actually _slower_ (2,518ms vs 1,580ms baseline) because `resolve()` was allocating a new `String` on every symbol lookup. Fixed by adding `with_resolved(spur, |s| ...)` which provides a borrowed `&str` without allocation, and switching `Env` to use `Spur` keys directly.

**Impact:** 1,580ms â†’ 1,400ms (11% faster) after fixing the allocation issue.

**Literature:**

- String interning is as old as Lisp itself â€” McCarthy's original LISP 1.5 (1962) interned atoms in the "object list" (oblist)
- Java interns all string literals and provides `String.intern()`. The JVM's `invokedynamic` uses interned method names for O(1) dispatch
- The [string-interner](https://crates.io/crates/string-interner) and [lasso](https://crates.io/crates/lasso) crates are the two main Rust options; lasso was chosen for its `Rodeo` thread-local interner which fits Sema's single-threaded architecture

## 5. hashbrown HashMap

**Problem:** The 1BRC accumulator uses a map keyed by weather station name (~400 entries). `BTreeMap` provides O(log n) lookup, but the accumulator is accessed on every row. With 10M rows, the logâ‚‚(400) â‰ˆ 9 comparisons per lookup adds up.

**Solution:** Added a `Value::HashMap` variant backed by [hashbrown](https://crates.io/crates/hashbrown) (the same hash map used inside Rust's `std::collections::HashMap`, but exposed directly for `no_std` compatibility and raw API access).

```scheme
;; User code: opt into HashMap for the accumulator
(file/fold-lines "data.csv"
  (lambda (acc line) ...)
  (hashmap/new))  ; amortized O(1) vs O(log n)

;; Convert back to sorted BTreeMap for output
(hashmap/to-map acc)
```

`BTreeMap` remains the default for `{}` map literals because deterministic ordering matters for equality, printing, and test assertions. `hashbrown` is opt-in for performance-critical paths.

**Impact:** 1,400ms â†’ 1,340ms (4% faster). Modest because BTreeMap with 400 entries and short string keys is already fast.

**Literature:**

- hashbrown uses SwissTable, designed by Google for their C++ `absl::flat_hash_map`. See [CppCon 2017: Matt Kulukundis "Designing a Fast, Efficient, Cache-friendly Hash Table"](https://www.youtube.com/watch?v=ncHmEUmJZf4)
- Clojure's `{:key val}` maps use HAMTs (hash array mapped tries) which provide O(~1) lookup with structural sharing. Sema's approach is simpler: full COW on the `Rc<HashMap>` rather than structural sharing, which is viable because the refcount-1 fast path almost always hits

## 6. SIMD Byte Search (memchr) _(removed)_

> **Status:** The memchr-based two-part split fast path was part of the mini-eval's inlined `string/split` and was removed with it. The current `string/split` in `sema-stdlib/src/string.rs` uses Rust's standard `str::split()` followed by `map` and `collect`. The `memchr` crate remains a dependency of `sema-stdlib` but is no longer used in the split hot path.

**What it was:** A SIMD-accelerated (SSE2/AVX2/NEON) byte search via the [memchr](https://crates.io/crates/memchr) crate, combined with a two-part split fast path that avoided `Vec` allocation when splitting on a single-byte separator with exactly one occurrence (the common case in 1BRC: `"Berlin;12.3"` â†’ `["Berlin", "12.3"]`).

**Impact when active:** Negligible for SIMD specifically (1BRC strings are 10â€“30 bytes), but the two-part fast path avoided iterator/Vec overhead.

**Literature:**

- memchr is maintained by Andrew Gallant (BurntSushi), author of ripgrep. It uses the [generic SIMD](https://github.com/BurntSushi/memchr/blob/master/src/arch/all/memchr/mod.rs) framework to dispatch to the best available instruction set at runtime

## 7. Custom Number Parser _(removed)_

> **Status:** This was part of the mini-eval's inlined `string->number` and was removed with it. The current `string->number` in `sema-stdlib/src/string.rs` uses Rust's standard `str::parse::<i64>()` with fallback to `str::parse::<f64>()`.

**What it was:** A hand-rolled decimal parser that handled only `[-]digits[.digits]`, using a precomputed powers-of-10 lookup table for 1â€“4 fractional digits. It returned `None` for complex cases (scientific notation, infinity, NaN), falling back to the standard parser.

**Impact when active:** Part of the combined mini-eval speedup. Difficult to isolate, but avoided the overhead of Rust's [dec2flt](https://github.com/rust-lang/rust/tree/master/library/core/src/num/dec2flt) algorithm.

**Literature:**

- Rust's float parser is based on the [Eisel-Lemire algorithm](https://nigeltao.github.io/blog/2020/eisel-lemire.html) (2020), which is fast for a general-purpose parser but still does more work than necessary for simple decimals
- Daniel Lemire's [fast_float](https://github.com/fastfloat/fast_float) C++ library (and its Rust port) takes a similar "fast path for common cases" approach

## 8. Enlarged I/O Buffer

**Problem:** `BufReader`'s default 8KB buffer means frequent syscalls for large files.

**Solution:** 256KB buffer for `file/fold-lines`.

```rust
let mut reader = std::io::BufReader::with_capacity(256 * 1024, file);
```

**Impact:** Minor. CPU was the bottleneck, not I/O. But it's a free win â€” larger buffers amortize syscall overhead and improve sequential read throughput on modern SSDs.

## Rejected Optimizations

Not everything we tried worked:

| Approach                                  | Result       | Why                                                                                                                                                                                 |
| ----------------------------------------- | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **HashMap for Env**                       | Slower       | `BTreeMap` is faster for the very small maps (1â€“3 entries) typical of `let` scopes. HashMap's hashing overhead exceeds BTreeMap's few integer comparisons at that size.             |
| **im-rc / rpds (persistent collections)** | Slower       | Structural sharing fights the COW optimization â€” the whole point is to _avoid_ sharing and mutate in place when refcount is 1.                                                      |
| **bumpalo / typed-arena**                 | Incompatible | Values need to escape the arena (returned from functions, stored in environments). Arena allocation only works for temporaries.                                                     |
| **compact_str / smol_str**                | Redundant    | Once symbols/keywords are interned as `Spur`, small-string optimization for them is pointless. String _values_ are still `Rc<String>` but they're not in the hot path for dispatch. |

> **Note:** "Full evaluator callback" was previously listed here as rejected (4x slower than mini-eval). It is now the **current architecture** â€” the ~2.7Ã— overhead vs the mini-eval is accepted as the cost of architectural correctness. The bytecode VM (`--vm`) is the path to eliminate this overhead entirely.

## Architecture Diagram

The hot path for `file/fold-lines` with the current callback architecture (tree-walker):

```
file/fold-lines
  â”œâ”€â”€ BufReader (256KB buffer, reused line_buf)
  â””â”€â”€ Per-line loop:
        â”œâ”€â”€ read_line â†’ reused buffer (no alloc)
        â”œâ”€â”€ call_callback â†’ real evaluator (eval_value)
        â”‚     â”œâ”€â”€ self-evaluating fast path (ints, floats, strings skip depth tracking)
        â”‚     â”œâ”€â”€ NativeFn inline dispatch (direct call, no callback indirection)
        â”‚     â”œâ”€â”€ apply_lambda â†’ fresh Env per call (no env reuse)
        â”‚     â”œâ”€â”€ string/split â†’ std str::split (no SIMD fast path)
        â”‚     â”œâ”€â”€ string->number â†’ std parse::<i64> / parse::<f64>
        â”‚     â””â”€â”€ assoc â†’ COW in-place mutation (Rc refcount == 1)
        â”œâ”€â”€ thread-local EvalContext (shared, not per-call)
        â””â”€â”€ acc moved, not cloned â†’ preserves refcount == 1
```

When `--vm` is used, the bytecode VM bypasses the tree-walker entirely. Instead of `call_callback â†’ eval_value â†’ trampoline`, the VM compiles the lambda body to bytecode once and executes it in a tight instruction dispatch loop, eliminating trampoline overhead, per-call span tracking, and repeated AST traversal.

---

# Lisp Dialect Benchmark

How does Sema compare to other Lisp dialects on a real-world I/O-heavy workload? We benchmarked fifteen implementations on the [1 Billion Row Challenge](https://github.com/gunnarmorling/1brc) â€” a data processing task that reads weather station measurements and computes min/mean/max per station. This is not a synthetic micro-benchmark; it exercises I/O, string parsing, hash table accumulation, and numeric aggregation in a tight loop.

## Results (Optimized)

**10 million rows (1.2 GB), best of 3 runs, single-threaded, Docker (linux/amd64):**

| Dialect           | Implementation           | Time (ms) | Relative | Category     |
| ----------------- | ------------------------ | --------- | -------- | ------------ |
| **SBCL**          | Native compiler          | 2,115     | 1.0x     | Compiled     |
| **Chez Scheme**   | Native compiler          | 2,873     | 1.4x     | Compiled     |
| **Fennel/LuaJIT** | JIT compiler             | 3,330     | 1.6x     | JIT-compiled |
| **Clojure**       | JVM (JIT)                | 5,487     | 2.6x     | JIT-compiled |
| **Gambit**        | Native compiler (gsc)    | 5,553     | 2.6x     | Compiled     |
| **Chicken**       | Native compiler (csc)    | 7,605     | 3.6x     | Compiled     |
| **PicoLisp**      | Interpreter              | 9,780     | 4.6x     | Interpreted  |
| **newLISP**       | Interpreter              | 12,330    | 5.8x     | Interpreted  |
| **Emacs Lisp**    | Bytecode VM              | 13,807    | 6.5x     | Interpreted  |
| **Janet**         | Bytecode VM              | 14,192    | 6.7x     | Interpreted  |
| **ECL**           | Native compiler          | 14,974    | 7.1x     | Compiled     |
| **Guile**         | Bytecode VM              | 15,487    | 7.3x     | Interpreted  |
| **Kawa**          | JVM (JIT)                | 16,611    | 7.9x     | JIT-compiled |
| **Gauche**        | Bytecode VM              | 23,252    | 11.0x    | Interpreted  |
| **Sema**          | Tree-walking interpreter | 48,042    | 22.7x    | Interpreted  |

Racket was excluded â€” both the CS (Chez Scheme) and BC (bytecode) backends crash under x86-64 emulation on Apple Silicon. This is a Docker/emulation issue, not a Racket performance issue; Racket CS would likely land between Chez and Clojure.

::: info Compiled mode
Gambit, Chicken, and ECL are now benchmarked in compiled mode (compiling to native code via C), not interpreter mode. Previous versions of this benchmark ran them as interpreters, which was 3â€“6x slower. Guile now runs with bytecode auto-compilation enabled.
:::

::: info Native performance
Sema runs significantly faster natively on Apple Silicon: ~29.6s (tree-walker) and ~17.1s (VM mode with `--vm`) on 10M rows, compared to 48.0s under x86-64 emulation. NaN-boxing (introduced in v1.5.0) adds overhead to the tree-walker that is amplified by x86-64 emulation. All dialects in this table were measured under the same Docker/emulation environment for a fair comparison.
:::

## Why SBCL Wins

SBCL compiles Common Lisp to native machine code. There is no interpreter loop, no bytecode dispatch â€” `(+ x y)` compiles to an `ADD` instruction. Combined with `(declare (optimize (speed 3) (safety 0)))`, the benchmark's inner loop runs at near-C speed:

- **Block I/O:** Reads 1MB chunks via `read-sequence`, parsing lines from a buffer â€” no per-line syscall overhead
- **Custom integer parser:** Parses temperatures as integers (Ã—10), avoiding float parsing entirely until the final division
- **Hash table with `equal` test:** SBCL's hash table implementation is highly optimized with type-specialized hashing
- **In-place struct mutation:** `station` structs are updated via `setf` with no allocation per row

SBCL's compiler has had 25+ years of optimization work (descended from CMUCL, which traces back to the 1980s). When you tell it `(safety 0)`, it trusts your type declarations and removes all runtime checks â€” a trade-off most interpreted languages can't make.

## Chez Scheme: The Other Native Compiler

Chez Scheme compiles to native code via a [nanopass compiler framework](https://nanopass.org/). It's 1.4x behind SBCL here, which is consistent with typical benchmarks â€” Chez tends to be slightly slower than SBCL on I/O-heavy workloads but competitive on computation.

The implementation uses:

- `get-line` for line reading (one syscall per line, no block I/O optimization)
- Custom character-by-character temperature parser
- Mutable vectors in a `make-hashtable` with `string-hash`

The gap to SBCL is likely explained by the per-line I/O â€” `get-line` allocates a fresh string per call, while SBCL's block read amortizes this.

## Fennel/LuaJIT: The JIT Surprise

Fennel compiling to LuaJIT at 1.7x is the biggest surprise â€” faster than both Clojure and compiled Gambit. LuaJIT's tracing JIT compiler generates native code for the hot loop after a few iterations, and Lua's table implementation (used for both hash maps and arrays) is famously efficient. The implementation is straightforward Fennel: `string.find` for semicolons, `tonumber` for parsing, Lua tables for accumulation. No special optimization tricks â€” LuaJIT's JIT does the heavy lifting.

## Clojure: JVM Tax + Warmup

Clojure's 2.7x result includes JVM startup and JIT warmup. The actual steady-state throughput after warmup is faster than the wall-clock time suggests, but for a single-shot script, the JVM overhead is real:

- **Startup:** ~1â€“2 seconds just to load the Clojure runtime
- **`line-seq` + `reduce`:** Lazy line reading with a transient map for accumulation â€” idiomatic but not zero-cost
- **`Double/parseDouble`:** JVM's float parser handles the full spec (scientific notation, hex floats), more work than a hand-rolled decimal parser
- **GC pauses:** The JVM's garbage collector adds latency variance

Clojure's strength is that this code is _15 lines_ â€” the most concise implementation in the benchmark. It trades raw speed for developer productivity.

## PicoLisp: Integer Arithmetic Pays Off

PicoLisp's 4.7x result is impressive for a pure interpreter with no bytecode compilation. PicoLisp has no native floating-point â€” all arithmetic is integer-based. The benchmark uses temperatures multiplied by 10 (e.g., "12.3" â†’ 123), avoiding float parsing entirely. PicoLisp's idx trees (balanced binary trees) provide O(log n) lookup and keep results sorted for free. The lack of float overhead gives it a significant edge over implementations that parse and accumulate floats on every row.

## newLISP: Simple but Effective

newLISP at 5.9x is surprisingly competitive. Its association-list-based accumulation has O(n) lookup per station, but with only 40 stations, the list stays small enough that linear search is fast. newLISP's `read-line`/`current-line` idiom and `find`/`slice` string operations are efficient C implementations. The language's simplicity â€” no complex type system, no numeric tower â€” means less overhead per operation.

## Gambit: Compiled Scheme via C

Gambit at 2.7x â€” virtually tied with Clojure â€” is the standout result among Scheme compilers. `gsc` compiles Scheme to C, then compiles C to a native binary. The result is competitive with Chez Scheme's native compiler, especially impressive given that Gambit's built-in `sort` crashes under x86-64 emulation (requiring a manual merge sort in the benchmark).

## Chicken: Compiled Scheme, I/O Bound

Chicken at 3.6x compiles Scheme to C via `csc -O3`. The optimized implementation uses a hand-rolled integerÃ—10 temperature parser that avoids float parsing entirely â€” without it, Chicken drops to 13.6s (1.8x slower). The remaining gap to SBCL/Chez is due to per-line I/O allocation and Chicken's compilation strategy (continuation-passing style C), which produces correct but not maximally optimized code for this I/O-heavy workload.

## Janet: A Fair Comparison

Janet is the most architecturally comparable to Sema â€” both are:

- Embeddable scripting languages written in C/Rust
- Single-threaded with reference counting (Janet) / `Rc` (Sema)
- Focused on practical scripting rather than language theory
- No JIT, no native compilation

Janet compiles to bytecode and runs on a register-based VM, which should be faster than tree-walking. Under the same Docker environment, Janet is ~3.4x faster than Sema's tree-walker (14.2s vs 48.0s). However, Sema's bytecode VM mode (`--vm`) at ~17.1s natively is competitive with Janet's 14.2s under emulation.

Janet's implementation is straightforward: `file/read :line` in a loop, `string/find` + `string/slice` for parsing, mutable tables for accumulation. No special optimizations.

## Guile and Gauche: Scheme Bytecode VMs

Guile (7.2x) and Gauche (10.9x) are both R7RS-compliant Scheme implementations with bytecode VMs. Guile runs with bytecode auto-compilation enabled, which compiles source to bytecode on first execution and caches it for subsequent runs. Guile's optimized implementation uses a hand-rolled integerÃ—10 parser, saving ~7% vs `string->number`. Gauche uses `string->number` in both versions â€” a hand-rolled char-by-char parser is actually _slower_ in Gauche because `string-ref` has O(n) cost in its internal UTF-32 representation, while `string->number` is implemented in C.

## Sema: The Interpreter Tax

Sema's 22.7x result (48.0s under emulation, ~29.6s native tree-walker, ~17.1s native VM) reflects the fundamental cost of tree-walking interpretation, amplified by NaN-boxing overhead under x86-64 emulation. Every operation â€” reading a line, splitting a string, parsing a number, updating a map â€” is a function call through the evaluator, with environment lookup, `Rc` reference counting, and trampoline dispatch.

The 22.7x relative result reflects tree-walking + NaN-boxing overhead amplified by x86-64 emulation on Apple Silicon. Natively, the tree-walker runs at ~29.6s, and the bytecode VM (`--vm`, available since v1.5.0) brings this down to ~17.1s â€” which would be competitive with Janet (14.2s Docker) and Guile (15.5s Docker).

Key optimizations that remain in the runtime:

- **`file/fold-lines`:** Reuses the lambda environment across iterations (no allocation per line)
- **COW map mutation:** `assoc` mutates in-place when the `Rc` refcount is 1 (which `file/fold-lines` ensures by moving, not cloning, the accumulator)
- **`hashmap/new`:** Amortized O(1) lookup via `hashbrown` instead of O(log n) `BTreeMap`
- **Bytecode VM:** The `--vm` flag compiles to bytecode before execution, eliminating tree-walking overhead and significantly improving performance

See the [Performance Internals](./performance.md) page for the optimization journey.

## Kawa: JVM Scheme, Slower Than Expected

Kawa at 8.1x is slower than Clojure despite both running on the JVM. Kawa compiles Scheme to JVM bytecode, but its `string->number` implementation handles the full Scheme numeric tower (exact rationals, complex numbers), which is more expensive than Clojure's `Double/parseDouble`. The `java.util.HashMap` usage should be fast, but Kawa's compilation model introduces overhead for Scheme-specific features like tail-call optimization and continuations that the JVM doesn't natively support.

## ECL: Common Lisp via C

ECL at 7.1x compiles Common Lisp to C via `compile-file`, producing a native FASL. The optimized implementation uses a hand-rolled integerÃ—10 parser; without it (using `read-from-string` instead), ECL drops to 21.5s â€” a 1.4x slowdown. The remaining gap to SBCL is due to ECL's less aggressive native code generation compared to SBCL's mature optimizer.

## Emacs Lisp: Buffer-Based I/O

Emacs Lisp at 6.4x loads the entire file into a buffer with `insert-file-contents-literally`, then parses temperatures using a manual integerÃ—10 parser that reads characters directly from the buffer without extracting substrings. Without this optimization (using `string-to-number` on extracted substrings instead), Emacs drops to 22.2s â€” a 1.6x slowdown. The in-buffer parsing avoids both string allocation and float overhead, which matters over 10 million rows.

## Results (Simple/Idiomatic)

To measure raw language runtime speed â€” independent of implementation tricks â€” we also benchmarked "simple" versions of each implementation. These use the language's built-in number parser (`string->number`, `string-to-number`, `tonumber`, etc.), per-line I/O, and standard data structures. No custom integer parsers, no block reads, no `(safety 0)`, no SIMD.

**10 million rows (1.2 GB), best of 3 runs, single-threaded, Docker (linux/amd64):**

| Dialect           | Implementation           | Time (ms) | Relative | vs Optimized |
| ----------------- | ------------------------ | --------- | -------- | ------------ |
| **Fennel/LuaJIT** | JIT compiler             | 3,640     | 1.0x     | 1.1x slower  |
| **Chez Scheme**   | Native compiler          | 4,320     | 1.2x     | 1.5x slower  |
| **Gambit**        | Native compiler (gsc)    | 5,714     | 1.6x     | ~same        |
| **Clojure**       | JVM (JIT)                | 5,913     | 1.6x     | ~same        |
| **SBCL**          | Native compiler          | 7,404     | 2.0x     | 3.5x slower  |
| **PicoLisp**      | Interpreter              | 9,839     | 2.7x     | ~same        |
| **newLISP**       | Interpreter              | 12,320    | 3.4x     | ~same        |
| **Chicken**       | Native compiler (csc)    | 13,371    | 3.7x     | 1.8x slower  |
| **Janet**         | Bytecode VM              | 14,406    | 4.0x     | ~same        |
| **Guile**         | Bytecode VM              | 16,628    | 4.6x     | 1.1x slower  |
| **Kawa**          | JVM (JIT)                | 16,874    | 4.6x     | ~same        |
| **ECL**           | Native compiler          | 22,961    | 6.3x     | 1.5x slower  |
| **Gauche**        | Bytecode VM              | 23,019    | 6.3x     | ~same        |
| **Emacs Lisp**    | Bytecode VM              | 24,293    | 6.7x     | 1.8x slower  |
| **Sema**          | Tree-walking interpreter | 52,060    | 14.3x    | 1.1x slower  |

The simple results are normalized to Fennel (the fastest simple implementation) rather than SBCL, since SBCL benefits the most from its optimizations.

## What the Simple Benchmarks Reveal

Comparing simple vs optimized times shows where optimization effort pays off and where the language runtime does the heavy lifting:

| Dialect      | Optimized | Simple | Slowdown | What the Optimized Version Does                                  |
| ------------ | --------- | ------ | -------- | ---------------------------------------------------------------- |
| **SBCL**     | 2,115     | 7,404  | **3.5x** | Block I/O, `(safety 0)`, custom intÃ—10 parser, typed structs     |
| **Chicken**  | 7,605     | 13,371 | **1.8x** | Custom intÃ—10 parser avoids `string->number` numeric tower       |
| **Emacs**    | 13,807    | 24,293 | **1.8x** | In-buffer intÃ—10 parser avoids string extraction + float parsing |
| **Chez**     | 2,873     | 4,320  | **1.5x** | Custom char-by-char parser avoids `string->number`               |
| **ECL**      | 14,974    | 22,961 | **1.5x** | Custom intÃ—10 parser avoids `read-from-string` (full CL reader)  |
| **Guile**    | 15,487    | 16,628 | **1.1x** | Custom intÃ—10 parser, modest improvement                         |
| **Fennel**   | 3,330     | 3,640  | **1.1x** | Already simple â€” LuaJIT's JIT optimizes it                       |
| **Sema**     | 48,042    | 52,060 | **1.1x** | `string->float` + hashmap vs `string->number` + sorted map       |
| **Gambit**   | 5,553     | 5,714  | ~same    | Already uses `string->number`                                    |
| **Clojure**  | 5,487     | 5,913  | ~same    | Only transientâ†’persistent map optimization                       |
| **Janet**    | 14,192    | 14,406 | ~same    | Already simple                                                   |
| **Kawa**     | 16,611    | 16,874 | ~same    | `Double/parseDouble` â†’ `string->number` (similar cost)           |
| **PicoLisp** | 9,780     | 9,839  | ~same    | No floats â€” intÃ—10 is the only option                            |
| **newLISP**  | 12,330    | 12,320 | ~same    | Already simple                                                   |
| **Gauche**   | 23,252    | 23,019 | ~same    | `string->number` (C impl) is faster than hand-rolled Scheme      |

**Key takeaways:**

- **SBCL's 3.5x optimization gain is the largest** â€” block I/O + `(safety 0)` + type declarations transform it from 2.0x to 1.0x relative. Without its optimizations, SBCL would rank 5th, behind Fennel, Chez, Gambit, and Clojure.
- **Number parsing is the dominant optimization** â€” every dialect that benefits from optimization does so primarily by replacing the language's built-in number parser with a hand-rolled integerÃ—10 parser. This avoids the overhead of handling the full numeric tower, scientific notation, and float precision.
- **Fennel/LuaJIT is the fastest with zero optimization effort.** The simple and optimized versions are nearly identical â€” LuaJIT's tracing JIT does all the work. This makes Fennel the clear winner in "performance per line of code."
- **Gauche's `string-ref` is O(n)** â€” a hand-rolled char-by-char parser is actually _slower_ than `string->number` (C implementation) because Gauche uses a UTF-32 internal representation where `string-ref` must scan from the beginning.
- **Sema's optimization gain is very small** (48.0s vs 52.1s = 1.1x), because `file/fold-lines` and COW mutation work in both versions. The difference is just `string->float` + hashmap vs `string->number` + sorted map.

## What This Benchmark Doesn't Show

This is one workload. Different benchmarks would produce different orderings:

- **CPU-bound computation** (fibonacci, sorting): SBCL and Chez would dominate even more; the I/O amortizes some of the interpreter gap
- **Startup time:** Janet and Sema start in <10ms; Clojure takes 1â€“2s; SBCL takes ~50ms
- **Memory usage:** Janet and Sema use minimal memory (tens of MB); Clojure's JVM baseline is ~100MB+
- **Multi-threaded:** Clojure (on the JVM) and SBCL (with `lparallel`) can parallelize; Sema, Janet, and Guile are single-threaded
- **Developer experience:** Clojure's REPL, Racket's IDE (DrRacket), and SBCL's SLIME/Sly integration are far more mature than Sema's
- **Compilation flags:** SBCL's `(safety 0)` and Chicken's `-O3` are used; other compilers may have additional optimization flags not explored here

## Methodology

- **Dataset:** 10,000,000 rows, 40 weather stations, generated from the [1BRC specification](https://github.com/gunnarmorling/1brc) with fixed station statistics
- **Environment:** Docker container (`debian:bookworm-slim`, linux/amd64), running on Apple Silicon via Rosetta/QEMU
- **Measurement:** Wall-clock time via `date +%s%N`, best of 3 consecutive runs per dialect
- **Verification:** All implementations produce identical output (sorted station results, 1 decimal place rounding)
- **Code style:** Each implementation is idiomatic for its dialect â€” no artificial handicaps, but no heroic micro-optimization either (except SBCL's `(safety 0)` declarations, which are standard practice)
- **Compilation:** Gambit (`gsc -exe`), Chicken (`csc -O3`), and ECL (`compile-file`) are compiled to native code before benchmarking. Guile uses bytecode auto-compilation. All other dialects run in their default mode.

### Versions

| Dialect     | Version | Package                                                |
| ----------- | ------- | ------------------------------------------------------ |
| SBCL        | 2.2.9   | `sbcl` (Debian bookworm)                               |
| Chez Scheme | 9.5.8   | `chezscheme` (Debian bookworm)                         |
| Fennel      | 1.5.1   | Downloaded binary                                      |
| LuaJIT      | 2.1.0   | `luajit` (Debian bookworm)                             |
| Clojure     | 1.12.0  | CLI tools                                              |
| PicoLisp    | 23.2    | `picolisp` (Debian bookworm)                           |
| newLISP     | 10.7.5  | `newlisp` (Debian bookworm)                            |
| Sema        | 1.5.0   | Built from source (Docker)                             |
| Janet       | 1.37.1  | Built from source                                      |
| Kawa        | 3.1.1   | JAR from Maven Central                                 |
| Gauche      | 0.9.15  | Built from source                                      |
| Guile       | 3.0.8   | `guile-3.0` (Debian bookworm)                          |
| Emacs       | 28.2    | `emacs-nox` (Debian bookworm)                          |
| Gambit      | 4.9.3   | `gambc` compiled via `gsc -exe` (Debian bookworm)      |
| ECL         | 21.2.1  | `ecl` compiled via `compile-file` (Debian bookworm)    |
| Chicken     | 5.3.0   | `chicken-bin` compiled via `csc -O3` (Debian bookworm) |

### Reproducing

```bash
cd benchmarks/1brc

# Generate test data (or use existing bench-10m.txt)
python3 generate-test-data.py 10000000 measurements.txt

# Build Docker image with all runtimes
docker build --platform linux/amd64 -t sema-1brc-bench .

# Run optimized benchmarks
docker run --platform linux/amd64 --rm \
  -v $(pwd)/../../bench-10m.txt:/data/measurements.txt:ro \
  -v $(pwd)/results:/results \
  sema-1brc-bench /data/measurements.txt

# Run simple/idiomatic benchmarks
docker run ... sema-1brc-bench --simple /data/measurements.txt

# Run both
docker run ... sema-1brc-bench --all /data/measurements.txt

# Run Sema natively for comparison
cargo run --release -- --no-llm examples/benchmarks/1brc.sema -- bench-10m.txt
```

Source code for all implementations is in [`benchmarks/1brc/`](https://github.com/HelgeSverre/sema/tree/main/benchmarks/1brc) (optimized) and [`benchmarks/1brc/simple/`](https://github.com/HelgeSverre/sema/tree/main/benchmarks/1brc/simple) (simple/idiomatic).

<script setup>
import { onMounted } from 'vue'

onMounted(() => {
  document.querySelectorAll('table tr').forEach(row => {
    const firstCell = row.querySelector('td:first-child')
    if (firstCell && firstCell.textContent.trim() === 'Sema') {
      row.classList.add('sema-row')
    }
  })
})
</script>

<style>
.sema-row {
  background: linear-gradient(90deg, rgba(245, 158, 11, 0.18), rgba(245, 158, 11, 0.06)) !important;
}
.sema-row td {
  font-weight: 600;
}
.sema-row td:first-child {
  border-left: 3px solid #f59e0b !important;
}
</style>

