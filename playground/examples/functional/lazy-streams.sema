;;; Lazy sequences (streams) via closures
;;; Infinite data structures using thunks (SICP-style)

(define stream-empty nil)
(define (stream-empty? s) (nil? s))
(define (stream-cons head tail-thunk) (list head tail-thunk))
(define (stream-car s) (car s))
(define (stream-cdr s) ((cadr s)))

(define (stream-take n s)
  (let loop ((i n) (s s) (acc '()))
    (if (or (= i 0) (stream-empty? s))
      (reverse acc)
      (loop (- i 1) (stream-cdr s) (cons (stream-car s) acc)))))

(define (stream-drop n s)
  (let loop ((i n) (s s))
    (if (or (= i 0) (stream-empty? s)) s
      (loop (- i 1) (stream-cdr s)))))

(define (stream-ref s n) (stream-car (stream-drop n s)))

(define (stream-map f s)
  (if (stream-empty? s) stream-empty
    (stream-cons (f (stream-car s))
                 (fn () (stream-map f (stream-cdr s))))))

(define (stream-filter pred s)
  (cond
    ((stream-empty? s) stream-empty)
    ((pred (stream-car s))
     (stream-cons (stream-car s)
                  (fn () (stream-filter pred (stream-cdr s)))))
    (else (stream-filter pred (stream-cdr s)))))

(define (stream-from n)
  (stream-cons n (fn () (stream-from (+ n 1)))))

(define (stream-iterate f seed)
  (stream-cons seed (fn () (stream-iterate f (f seed)))))

(println "=== Lazy Sequences (Streams) ===\n")

(define naturals (stream-from 1))
(println (format "First 15 naturals: ~a" (stream-take 15 naturals)))

(define squares (stream-map (fn (x) (* x x)) naturals))
(println (format "First 10 squares:  ~a" (stream-take 10 squares)))

(define evens (stream-filter even? naturals))
(println (format "First 10 evens:    ~a" (stream-take 10 evens)))

(define powers-of-2 (stream-iterate (fn (x) (* x 2)) 1))
(println (format "First 12 powers of 2: ~a" (stream-take 12 powers-of-2)))

;; Fibonacci
(define fibs
  (let ()
    (define (fib-gen a b) (stream-cons a (fn () (fib-gen b (+ a b)))))
    (fib-gen 0 1)))
(println (format "\nFirst 20 Fibonacci: ~a" (stream-take 20 fibs)))
(println (format "50th Fibonacci: ~a" (stream-ref fibs 50)))

;; Sieve of Eratosthenes
(define (sieve s)
  (let ((p (stream-car s)))
    (stream-cons p
      (fn () (sieve (stream-filter
                      (fn (n) (not (= 0 (math/remainder n p))))
                      (stream-cdr s)))))))

(define primes (sieve (stream-from 2)))
(println (format "\nFirst 25 primes: ~a" (stream-take 25 primes)))
(println (format "100th prime: ~a" (stream-ref primes 99)))

;; Collatz streams
(define (collatz-stream n)
  (stream-cons n
    (fn () (if (= n 1) stream-empty
      (collatz-stream (if (even? n) (/ n 2) (+ (* 3 n) 1)))))))

(println (format "\nCollatz(27): ~a" (stream-take 30 (collatz-stream 27))))

;; First 10 primes > 1000
(define big-primes (stream-filter (fn (p) (> p 1000)) primes))
(println (format "\nFirst 10 primes > 1000: ~a" (stream-take 10 big-primes)))
