;; L-system string rewriting

(println "=== L-System String Rewriting ===\n")

(define (apply-char rules ch)
  (let ((r (get rules (string/to-keyword (char/to-string ch)))))
    (if (nil? r) (char/to-string ch) r)))

(define (apply-rules str rules)
  (string/join (map (fn (ch) (apply-char rules ch)) (string/chars str)) ""))

(define (iterate-lsystem axiom rules n)
  (let loop ((current axiom) (i 0) (history (list axiom)))
    (if (= i n) history
      (let ((next (apply-rules current rules)))
        (loop next (+ i 1) (append history (list next)))))))

(define (show-lsystem name axiom rules n)
  (println (format "--- ~a ---" name))
  (let ((gens (iterate-lsystem axiom rules n)))
    (for-each (fn (i)
      (let ((gen (nth gens i)))
        (if (<= (string/length gen) 55)
          (println (format "  ~a: ~a" i gen))
          (println (format "  ~a: [~a chars] ~a..." i (string/length gen) (string/slice gen 0 50))))))
      (range (+ n 1))))
  (println ""))

;; Algae: A→AB, B→A
(show-lsystem "Algae (A→AB, B→A)" "A" {:A "AB" :B "A"} 7)

;; Binary tree: 1→11, 0→1[0]0
(show-lsystem "Binary Tree" "0" {:1 "11" :0 "1[0]0"} 4)

;; Sierpinski: A→B-A-B, B→A+B+A
(show-lsystem "Sierpinski" "A" {:A "B-A-B" :B "A+B+A"} 5)

;; Dragon curve
(show-lsystem "Dragon Curve" "FX" {:X "X+YF+" :Y "-FX-Y"} 7)

;; Growth statistics
(println "=== Growth Stats ===\n")
(define (show-growth name axiom rules n)
  (let ((gens (iterate-lsystem axiom rules n)))
    (println (format "~a:" name))
    (for-each (fn (i)
      (let ((len (string/length (nth gens i))))
        (println (format "  Gen ~a: ~a chars ~a"
          (string/pad-left (str i) 2)
          (string/pad-left (str len) 6)
          (string/repeat "█" (min 30 (int (/ len 10))))))))
      (range (+ n 1)))))

(show-growth "Algae" "A" {:A "AB" :B "A"} 10)
