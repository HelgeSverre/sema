export const examples = [
  { category: "Getting Started", files: [
    { id: "getting-started/advent-of-code.sema", name: "advent-of-code.sema", code: ";; AoC-style puzzles solved in Sema\n\n;; === Puzzle 1: Calorie Counting ===\n(println \"=== Puzzle 1: Calorie Counting ===\\n\")\n\n(define elf-calories\n  '((1000 2000 3000) (4000) (5000 6000)\n    (7000 8000 9000) (10000)))\n\n(define totals (map (fn (elf) (foldl + 0 elf)) elf-calories))\n(define sorted-totals (sort totals (fn (a b) (- b a))))\n\n(println (format \"Elf totals: ~a\" totals))\n(println (format \"Max single elf: ~a\" (first sorted-totals)))\n(println (format \"Top 3 combined: ~a\" (foldl + 0 (take 3 sorted-totals))))\n\n;; === Puzzle 2: Rock Paper Scissors ===\n(println \"\\n=== Puzzle 2: Rock Paper Scissors ===\\n\")\n\n(define rounds '((\"A\" \"Y\") (\"B\" \"X\") (\"C\" \"Z\") (\"A\" \"X\") (\"B\" \"Z\") (\"C\" \"Y\")))\n(define shape-score {:X 1 :Y 2 :Z 3})\n(define outcome-map\n  {:AX 3 :BY 3 :CZ 3 :AY 6 :BZ 6 :CX 6 :AZ 0 :BX 0 :CY 0})\n\n(define (score-round round)\n  (let ((opp (first round)) (you (nth round 1)))\n    (+ (get shape-score (string->keyword you))\n       (get outcome-map (string->keyword (string-append opp you))))))\n\n(define round-scores (map score-round rounds))\n(for-each (fn (i)\n  (let ((r (nth rounds i)) (s (nth round-scores i)))\n    (println (format \"  ~a vs ~a â†’ ~a pts\" (first r) (nth r 1) s))))\n  (range (length rounds)))\n(println (format \"Total: ~a\" (foldl + 0 round-scores)))\n\n;; === Puzzle 3: Pangram Checker ===\n(println \"\\n=== Puzzle 3: Pangram Checker ===\\n\")\n\n(define (pangram? text)\n  (let ((lower (string/lower text)))\n    (every (fn (ch) (string/contains? lower (char->string ch)))\n           (string/chars \"abcdefghijklmnopqrstuvwxyz\"))))\n\n(for-each (fn (s)\n  (println (format \"  ~a â†’ ~a\"\n    (if (> (string-length s) 40) (string-append (substring s 0 37) \"...\") s)\n    (if (pangram? s) \"âœ“ pangram\" \"âœ— not\"))))\n  (list \"The quick brown fox jumps over the lazy dog\"\n        \"Hello World\"\n        \"Pack my box with five dozen liquor jugs\"))\n\n;; === Puzzle 4: Number Word Sum ===\n(println \"\\n=== Puzzle 4: Number Word Sum ===\\n\")\n\n(define number-words {:one 1 :two 2 :three 3 :four 4 :five 5\n                      :six 6 :seven 7 :eight 8 :nine 9 :ten 10})\n(define words-input '(\"three\" \"cats\" \"ate\" \"five\" \"fish\" \"and\" \"two\" \"pies\" \"plus\" \"one\"))\n(define found (filter (fn (v) (not (nil? v)))\n  (map (fn (w) (get number-words (string->keyword w))) words-input)))\n\n(println (format \"Input: ~a\" (string/join words-input \" \")))\n(println (format \"Found: ~a\" found))\n(println (format \"Sum:   ~a\" (foldl + 0 found)))\n" },
    { id: "getting-started/fibonacci.sema", name: "fibonacci.sema", code: ";; Fibonacci with tail-call optimization\n(define (fib n)\n  (define (go a b i)\n    (if (= i 0) a\n        (go b (+ a b) (- i 1))))\n  (go 0 1 n))\n\n(map fib (range 1 16))\n" },
    { id: "getting-started/fizzbuzz.sema", name: "fizzbuzz.sema", code: ";; Classic FizzBuzz\n(define (fizzbuzz n)\n  (cond\n    ((= 0 (mod n 15)) \"FizzBuzz\")\n    ((= 0 (mod n 3))  \"Fizz\")\n    ((= 0 (mod n 5))  \"Buzz\")\n    (else              n)))\n\n(map fizzbuzz (range 1 21))\n" },
    { id: "getting-started/hello.sema", name: "hello.sema", code: ";; Hello World\n(define (greet name)\n  (format \"Hello, ~a!\" name))\n\n(greet \"world\")\n" },
    { id: "getting-started/quicksort.sema", name: "quicksort.sema", code: ";; Quicksort\n(define (qsort lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let ((pivot (car lst))\n            (rest  (cdr lst)))\n        (append\n          (qsort (filter (fn (x) (< x pivot)) rest))\n          (list pivot)\n          (qsort (filter (fn (x) (>= x pivot)) rest))))))\n\n(qsort '(38 27 43 3 9 82 10 1))\n" },
    { id: "getting-started/roman-numerals.sema", name: "roman-numerals.sema", code: ";; Roman numeral converter\n\n(println \"=== Roman Numeral Converter ===\\n\")\n\n(define roman-table\n  (list (list 1000 \"M\")  (list 900 \"CM\") (list 500 \"D\")  (list 400 \"CD\")\n        (list 100  \"C\")  (list 90  \"XC\") (list 50  \"L\")  (list 40  \"XL\")\n        (list 10   \"X\")  (list 9   \"IX\") (list 5   \"V\")  (list 4   \"IV\")\n        (list 1    \"I\")))\n\n(define (int->roman n)\n  (let loop ((n n) (table roman-table) (acc \"\"))\n    (if (or (null? table) (= n 0)) acc\n      (let ((value (first (first table)))\n            (symbol (nth (first table) 1)))\n        (if (>= n value)\n          (loop (- n value) table (string-append acc symbol))\n          (loop n (rest table) acc))))))\n\n(define roman-chars\n  (hash-map :I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000))\n\n(define (roman-char-value ch)\n  (get roman-chars (string->keyword (string/upper (char->string ch)))))\n\n(define (roman->int s)\n  (let ((chars (string/chars s)))\n    (let loop ((chars chars) (total 0))\n      (if (null? chars) total\n        (let ((current (roman-char-value (first chars)))\n              (next (if (null? (rest chars)) 0 (roman-char-value (first (rest chars))))))\n          (if (< current next)\n            (loop (rest chars) (- total current))\n            (loop (rest chars) (+ total current))))))))\n\n(define test-numbers (list 1 4 9 42 99 399 1776 1999 2024 3999))\n\n(println (format \"  ~a  ~a  ~a\"\n  (string/pad-right \"Integer\" 9) (string/pad-right \"Roman\" 16) \"Back\"))\n(println (format \"  ~a  ~a  ~a\"\n  (string/repeat \"â”€\" 9) (string/repeat \"â”€\" 16) (string/repeat \"â”€\" 7)))\n\n(for-each (fn (n)\n  (let* ((roman (int->roman n)) (back (roman->int roman)))\n    (println (format \"  ~a  ~a  ~a\"\n      (string/pad-right (str n) 9) (string/pad-right roman 16) back))))\n  test-numbers)\n\n(define all-pass (every (fn (n) (= n (roman->int (int->roman n)))) test-numbers))\n(println (format \"\\nRoundtrip: ~a\" (if all-pass \"ALL PASS âœ“\" \"FAIL âœ—\")))\n" },
    { id: "getting-started/towers-of-hanoi.sema", name: "towers-of-hanoi.sema", code: ";; Towers of Hanoi with ASCII visualization\n\n(println \"=== Towers of Hanoi ===\\n\")\n\n(define num-disks 4)\n(define move-counter (list 0))\n\n(define (make-towers n)\n  (hash-map :A (range 1 (+ n 1)) :B (list) :C (list)))\n\n(define (move-disk towers from to)\n  (let* ((from-stack (get towers from))\n         (to-stack   (get towers to))\n         (disk       (car from-stack))\n         (new-from   (cdr from-stack))\n         (new-to     (cons disk to-stack)))\n    (assoc (assoc towers from new-from) to new-to)))\n\n(define (render-disk disk width)\n  (if (= disk 0)\n    (string-append (string/pad-left \"|\" width) (string/repeat \" \" (- width 1)))\n    (let* ((arm (string/repeat \"â–ˆ\" disk))\n           (line (string-append arm \"|\" arm))\n           (pad-left (string/pad-left line width))\n           (total-width (- (* 2 width) 1)))\n      (string/pad-right pad-left total-width))))\n\n(define (display-towers towers)\n  (let* ((col-width (+ num-disks 1))\n         (total-col (- (* 2 col-width) 1))\n         (a (get towers :A))\n         (b (get towers :B))\n         (c (get towers :C))\n         (pad-a (append (map (lambda (_) 0) (range 0 (- num-disks (length a)))) a))\n         (pad-b (append (map (lambda (_) 0) (range 0 (- num-disks (length b)))) b))\n         (pad-c (append (map (lambda (_) 0) (range 0 (- num-disks (length c)))) c)))\n    (for-each (lambda (i)\n      (let ((da (nth pad-a i)) (db (nth pad-b i)) (dc (nth pad-c i)))\n        (println (format \"  ~a ~a ~a\"\n          (render-disk da col-width) (render-disk db col-width) (render-disk dc col-width)))))\n      (range 0 num-disks))\n    (println (format \"  ~a ~a ~a\"\n      (string/pad-right (string/pad-left \"A\" col-width) total-col)\n      (string/pad-right (string/pad-left \"B\" col-width) total-col)\n      (string/pad-right (string/pad-left \"C\" col-width) total-col)))\n    (println \"\")))\n\n(define (solve n from to aux towers)\n  (if (= n 0) towers\n    (let* ((towers1 (solve (- n 1) from aux to towers))\n           (disk    (car (get towers1 from)))\n           (towers2 (move-disk towers1 from to))\n           (move-num (+ 1 (car move-counter))))\n      (set! move-counter (list move-num))\n      (println (format \"--- Move ~a: Disk ~a from ~a â†’ ~a ---\"\n        move-num disk (keyword->string from) (keyword->string to)))\n      (display-towers towers2)\n      (solve (- n 1) aux to from towers2))))\n\n(println (format \"Solving for ~a disks...\\n\" num-disks))\n(define initial (make-towers num-disks))\n(println \"--- Initial State ---\")\n(display-towers initial)\n(define final-state (solve num-disks :A :C :B initial))\n(println \"=== Complete! ===\")\n(println (format \"Total moves: ~a (optimal = ~a)\" (car move-counter) (- (pow 2 num-disks) 1)))\n" }
  ]},
  { category: "Functional", files: [
    { id: "functional/closures.sema", name: "closures.sema", code: ";; Closures and higher-order functions\n(define (make-counter start)\n  (let ((n start))\n    (lambda ()\n      (set! n (+ n 1))\n      n)))\n\n(define counter (make-counter 0))\n(println (counter))  ; 1\n(println (counter))  ; 2\n(println (counter))  ; 3\n\n;; Compose functions\n(define (compose f g)\n  (lambda (x) (f (g x))))\n\n(define add1-then-double\n  (compose (fn (x) (* x 2))\n           (fn (x) (+ x 1))))\n\n(map add1-then-double (range 1 6))\n" },
    { id: "functional/comprehensions.sema", name: "comprehensions.sema", code: ";;; List and map comprehensions via macros\n;;;\n;;; Implements Python/Haskell-style comprehensions:\n;;;   (for/list ((x xs) (y ys)) body)\n;;;   (for/list ((x xs) (:when pred)) body)\n\n;; Simple list comprehension\n(defmacro for/list (bindings body)\n  (define (expand bs)\n    (if (null? bs)\n      `(list ,body)\n      (let ((clause (car bs))\n            (rest (cdr bs)))\n        (if (and (list? clause) (= (car clause) :when))\n          `(let ((__result ,(expand rest)))\n             (if ,(cadr clause) __result '()))\n          (let ((var (car clause))\n                (seq (cadr clause)))\n            `(apply append\n               (map (fn (,var) ,(expand rest)) ,seq)))))))\n  (expand bindings))\n\n(defmacro for/sum (bindings body)\n  `(foldl + 0 (for/list ,bindings ,body)))\n\n(defmacro for/string (bindings body)\n  `(string/join (for/list ,bindings ,body) \"\"))\n\n(defmacro for/every? (bindings body)\n  `(null? (filter (fn (x) (not x)) (for/list ,bindings ,body))))\n\n(println \"=== Comprehensions ===\\n\")\n\n;; Squares of 1..10\n(println (format \"Squares: ~a\"\n  (for/list ((x (range 1 11))) (* x x))))\n\n;; Cartesian product\n(println (format \"Pairs: ~a\"\n  (for/list ((x (list 1 2 3))\n             (y (list \"a\" \"b\")))\n    (list x y))))\n\n;; Even squares with filter\n(println (format \"Even squares: ~a\"\n  (for/list ((x (range 1 21))\n             (:when (even? x)))\n    (* x x))))\n\n;; Pythagorean triples\n(define triples\n  (for/list ((a (range 1 21))\n             (b (range a 21))\n             (:when (let ((c (sqrt (+ (* a a) (* b b)))))\n                      (= c (floor c)))))\n    (list a b (int (sqrt (+ (* a a) (* b b)))))))\n(println (format \"\\nPythagorean triples: ~a\" triples))\n\n;; Sum of cubes\n(println (format \"\\nSum of cubes 1..10: ~a\"\n  (for/sum ((n (range 1 11))) (* n n n))))\n\n;; Matrix transpose\n(define matrix (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))\n(define transposed\n  (for/list ((col (range 3)))\n    (map (fn (row) (nth row col)) matrix)))\n(println (format \"\\nMatrix:     ~a\" matrix))\n(println (format \"Transposed: ~a\" transposed))\n" },
    { id: "functional/huffman-coding.sema", name: "huffman-coding.sema", code: ";; Huffman coding: build tree, encode, decode\n\n(println \"=== Huffman Coding ===\\n\")\n\n(define message \"she sells sea shells by the sea shore\")\n(println (format \"Message: \\\"~a\\\"\" message))\n\n(define (char-frequencies s)\n  (foldl (fn (acc ch)\n    (map/update acc (char->string ch) (fn (v) (if (nil? v) 1 (+ v 1)))))\n    {} (string/chars s)))\n\n(define freqs (char-frequencies message))\n\n;; Tree nodes: leaf = (:leaf char freq), branch = (:branch left right freq)\n(define (make-leaf ch freq) (list :leaf ch freq))\n(define (make-branch left right)\n  (list :branch left right (+ (node-freq left) (node-freq right))))\n(define (node-freq node) (nth node (- (length node) 1)))\n(define (leaf? node) (eq? (first node) :leaf))\n\n(define (build-leaves freqs)\n  (sort (map (fn (e) (make-leaf (first e) (nth e 1))) (map/entries freqs))\n    (fn (a b) (- (node-freq a) (node-freq b)))))\n\n(define (insert-sorted queue node)\n  (if (null? queue) (list node)\n    (if (<= (node-freq node) (node-freq (first queue)))\n      (cons node queue)\n      (cons (first queue) (insert-sorted (rest queue) node)))))\n\n(define (build-tree queue)\n  (if (<= (length queue) 1) (first queue)\n    (let* ((left (first queue)) (right (nth queue 1))\n           (branch (make-branch left right)))\n      (build-tree (insert-sorted (drop 2 queue) branch)))))\n\n(define tree (build-tree (build-leaves freqs)))\n\n(define (generate-codes node prefix)\n  (if (leaf? node) (list (list (nth node 1) prefix))\n    (append (generate-codes (nth node 1) (string-append prefix \"0\"))\n            (generate-codes (nth node 2) (string-append prefix \"1\")))))\n\n(define codes (generate-codes tree \"\"))\n(define code-map (foldl (fn (acc e) (assoc acc (first e) (nth e 1))) {} codes))\n\n(println \"\\nCode table:\")\n(for-each (fn (e)\n  (let ((ch (first e)) (code (nth e 1)))\n    (println (format \"  ~a  ~a\" (string/pad-right (if (= ch \" \") \"SPC\" (format \"'~a'\" ch)) 5) code))))\n  (sort codes (fn (a b) (- (string-length (nth a 1)) (string-length (nth b 1))))))\n\n;; Encode\n(define (encode msg cm)\n  (string/join (map (fn (ch) (get cm (char->string ch))) (string/chars msg)) \"\"))\n\n(define encoded (encode message code-map))\n(println (format \"\\nEncoded: ~a...\" (substring encoded 0 (min 50 (string-length encoded)))))\n\n;; Decode\n(define (decode bits tree)\n  (let loop ((bits (string/chars bits)) (node tree) (result \"\"))\n    (if (null? bits)\n      (if (leaf? node) (string-append result (nth node 1)) result)\n      (let ((next (if (= (char->string (first bits)) \"0\") (nth node 1) (nth node 2))))\n        (if (leaf? next)\n          (loop (rest bits) tree (string-append result (nth next 1)))\n          (loop (rest bits) next result))))))\n\n(define decoded (decode encoded tree))\n(println (format \"Decoded: \\\"~a\\\"\" decoded))\n\n(define orig-bits (* (string-length message) 8))\n(println (format \"\\nCompression: ~a â†’ ~a bits (~a% saved)\"\n  orig-bits (string-length encoded)\n  (round (* 100 (- 1.0 (/ (float (string-length encoded)) orig-bits))))))\n(println (format \"Roundtrip OK: ~a\" (if (= message decoded) \"YES âœ“\" \"NO âœ—\")))\n" },
    { id: "functional/lazy-streams.sema", name: "lazy-streams.sema", code: ";;; Lazy sequences (streams) via closures\n;;; Infinite data structures using thunks (SICP-style)\n\n(define stream-empty nil)\n(define (stream-empty? s) (nil? s))\n(define (stream-cons head tail-thunk) (list head tail-thunk))\n(define (stream-car s) (car s))\n(define (stream-cdr s) ((cadr s)))\n\n(define (stream-take n s)\n  (let loop ((i n) (s s) (acc '()))\n    (if (or (= i 0) (stream-empty? s))\n      (reverse acc)\n      (loop (- i 1) (stream-cdr s) (cons (stream-car s) acc)))))\n\n(define (stream-drop n s)\n  (let loop ((i n) (s s))\n    (if (or (= i 0) (stream-empty? s)) s\n      (loop (- i 1) (stream-cdr s)))))\n\n(define (stream-ref s n) (stream-car (stream-drop n s)))\n\n(define (stream-map f s)\n  (if (stream-empty? s) stream-empty\n    (stream-cons (f (stream-car s))\n                 (fn () (stream-map f (stream-cdr s))))))\n\n(define (stream-filter pred s)\n  (cond\n    ((stream-empty? s) stream-empty)\n    ((pred (stream-car s))\n     (stream-cons (stream-car s)\n                  (fn () (stream-filter pred (stream-cdr s)))))\n    (else (stream-filter pred (stream-cdr s)))))\n\n(define (stream-from n)\n  (stream-cons n (fn () (stream-from (+ n 1)))))\n\n(define (stream-iterate f seed)\n  (stream-cons seed (fn () (stream-iterate f (f seed)))))\n\n(println \"=== Lazy Sequences (Streams) ===\\n\")\n\n(define naturals (stream-from 1))\n(println (format \"First 15 naturals: ~a\" (stream-take 15 naturals)))\n\n(define squares (stream-map (fn (x) (* x x)) naturals))\n(println (format \"First 10 squares:  ~a\" (stream-take 10 squares)))\n\n(define evens (stream-filter even? naturals))\n(println (format \"First 10 evens:    ~a\" (stream-take 10 evens)))\n\n(define powers-of-2 (stream-iterate (fn (x) (* x 2)) 1))\n(println (format \"First 12 powers of 2: ~a\" (stream-take 12 powers-of-2)))\n\n;; Fibonacci\n(define fibs\n  (let ()\n    (define (fib-gen a b) (stream-cons a (fn () (fib-gen b (+ a b)))))\n    (fib-gen 0 1)))\n(println (format \"\\nFirst 20 Fibonacci: ~a\" (stream-take 20 fibs)))\n(println (format \"50th Fibonacci: ~a\" (stream-ref fibs 50)))\n\n;; Sieve of Eratosthenes\n(define (sieve s)\n  (let ((p (stream-car s)))\n    (stream-cons p\n      (fn () (sieve (stream-filter\n                      (fn (n) (not (= 0 (math/remainder n p))))\n                      (stream-cdr s)))))))\n\n(define primes (sieve (stream-from 2)))\n(println (format \"\\nFirst 25 primes: ~a\" (stream-take 25 primes)))\n(println (format \"100th prime: ~a\" (stream-ref primes 99)))\n\n;; Collatz streams\n(define (collatz-stream n)\n  (stream-cons n\n    (fn () (if (= n 1) stream-empty\n      (collatz-stream (if (even? n) (/ n 2) (+ (* 3 n) 1)))))))\n\n(println (format \"\\nCollatz(27): ~a\" (stream-take 30 (collatz-stream 27))))\n\n;; First 10 primes > 1000\n(define big-primes (stream-filter (fn (p) (> p 1000)) primes))\n(println (format \"\\nFirst 10 primes > 1000: ~a\" (stream-take 10 big-primes)))\n" },
    { id: "functional/map-filter.sema", name: "map-filter.sema", code: ";; Functional data processing\n(define people\n  [{:name \"Ada\" :age 36}\n   {:name \"Bob\" :age 28}\n   {:name \"Cat\" :age 42}\n   {:name \"Dan\" :age 31}])\n\n(println \"Names:\" (map (fn (p) (:name p)) people))\n\n(println \"Over 30:\"\n  (filter (fn (p) (> (:age p) 30)) people))\n\n(println \"Avg age:\"\n  (/ (apply + (map (fn (p) (:age p)) people))\n     (length people)))\n" },
    { id: "functional/threading.sema", name: "threading.sema", code: ";;; Threading macros for pipeline-style code\n;;; Clojure-style -> (thread-first), ->> (thread-last),\n;;; as-> (thread-as), some-> (nil-safe)\n\n(defmacro -> (val . forms)\n  (if (null? forms) val\n    (let ((form (car forms)) (rest (cdr forms)))\n      (if (list? form)\n        `(-> (,(car form) ,val ,@(cdr form)) ,@rest)\n        `(-> (,form ,val) ,@rest)))))\n\n(defmacro ->> (val . forms)\n  (if (null? forms) val\n    (let ((form (car forms)) (rest (cdr forms)))\n      (if (list? form)\n        `(->> (,(car form) ,@(cdr form) ,val) ,@rest)\n        `(->> (,form ,val) ,@rest)))))\n\n(defmacro as-> (val name . forms)\n  (if (null? forms) val\n    (let ((form (car forms)) (rest (cdr forms)))\n      `(let ((,name ,val))\n         (as-> ,form ,name ,@rest)))))\n\n(defmacro some-> (val . forms)\n  (if (null? forms) val\n    (let ((form (car forms)) (rest (cdr forms)))\n      (if (list? form)\n        `(let ((__v ,val))\n           (if (nil? __v) nil (some-> (,(car form) __v ,@(cdr form)) ,@rest)))\n        `(let ((__v ,val))\n           (if (nil? __v) nil (some-> (,form __v) ,@rest)))))))\n\n(println \"=== Threading Macros ===\\n\")\n\n(println \"--- Thread-first (->) ---\")\n(println (format \"  (-> 5 (+ 3) (* 2))           = ~a\" (-> 5 (+ 3) (* 2))))\n(println (format \"  (-> \\\"hello\\\" string-length)    = ~a\" (-> \"hello\" string-length)))\n\n(println \"\\n--- Thread-last (->>) ---\")\n(println (format \"  (->> (range 10) (filter odd?)) = ~a\" (->> (range 10) (filter odd?))))\n(println (format \"  (->> (range 1 11) (filter even?) (foldl + 0)) = ~a\"\n  (->> (range 1 11) (filter even?) (foldl + 0))))\n\n(println \"\\n--- Thread-as (as->) ---\")\n(println (format \"  (as-> 5 x (+ x 3) (* x x) (- x 1)) = ~a\"\n  (as-> 5 x (+ x 3) (* x x) (- x 1))))\n\n(println \"\\n--- Nil-safe threading (some->) ---\")\n(define people {:alice {:age 30 :address {:city \"Paris\"}}\n                :bob {:age 25 :address nil}})\n(println (format \"  alice's city: ~a\"\n  (some-> (get people :alice) (get :address) (get :city))))\n(println (format \"  bob's city:   ~a\"\n  (some-> (get people :bob) (get :address) (get :city))))\n\n;; Practical: word frequency pipeline\n(println \"\\n--- Word frequency pipeline ---\")\n(define text \"the quick brown fox jumps over the lazy brown fox the fox\")\n(define top-words\n  (sort\n    (->> (string/split text \" \")\n         (foldl (fn (acc w)\n                  (map/update acc (string->keyword w) (fn (v) (if (nil? v) 1 (+ v 1)))))\n                {})\n         (map/entries))\n    (fn (a b) (- (cadr b) (cadr a)))))\n\n(for-each\n  (fn (entry) (println (format \"  ~a: ~a\" (car entry) (cadr entry))))\n  top-words)\n" }
  ]},
  { category: "Data & Text", files: [
    { id: "data/data-pipeline.sema", name: "data-pipeline.sema", code: ";; CSV processing, data transformation, and analysis\n\n(define csv-data \"name,age,score,city\nAlice,32,95,Berlin\nBob,28,82,London\nCharlie,35,91,Berlin\nDiana,24,78,Paris\nEve,31,99,London\nFrank,29,85,Berlin\nGrace,27,73,Paris\nHenry,33,88,London\")\n\n(define records (csv/parse-maps csv-data))\n(println (format \"Loaded ~a records\" (length records)))\n\n(define typed-records\n  (map (fn (r)\n    (assoc r :age (int (get r :age)) :score (int (get r :score))))\n    records))\n\n;; Statistics\n(define ages (map (fn (r) (get r :age)) typed-records))\n(define scores (map (fn (r) (get r :score)) typed-records))\n(println (format \"Average age: ~a\" (round (/ (foldl + 0 ages) (float (length ages))))))\n(println (format \"Average score: ~a\" (round (/ (foldl + 0 scores) (float (length scores))))))\n(println (format \"Score range: ~a - ~a\" (apply min scores) (apply max scores)))\n\n;; Group by city\n(define by-city (list/group-by (fn (r) (get r :city)) typed-records))\n(println \"\\nPer-city breakdown:\")\n(for-each\n  (fn (entry)\n    (let ((city (first entry)) (people (nth entry 1)))\n      (let* ((city-scores (map (fn (r) (get r :score)) people))\n             (city-avg (/ (foldl + 0 city-scores) (float (length city-scores)))))\n        (println (format \"  ~a: ~a people, avg score ~a\" city (length people) (round city-avg))))))\n  (map/entries by-city))\n\n;; Ranking\n(define ranked (sort typed-records (fn (a b) (- (get b :score) (get a :score)))))\n(println \"\\nRanking:\")\n(for-each\n  (fn (r)\n    (println (format \"  ~a. ~a â€” ~a pts\"\n      (string/pad-left (str (+ 1 (list/index-of ranked r))) 2)\n      (string/pad-right (get r :name) 8)\n      (get r :score))))\n  ranked)\n\n;; Export as CSV\n(define export-rows\n  (cons '(\"name\" \"score\" \"grade\")\n    (map (fn (r)\n      (let ((score (get r :score)))\n        (list (get r :name) (str score)\n              (cond ((>= score 90) \"A\") ((>= score 80) \"B\")\n                    ((>= score 70) \"C\") (else \"D\")))))\n      ranked)))\n(println \"\\nExported CSV:\")\n(println (csv/encode export-rows))\n" },
    { id: "data/emoji.sema", name: "emoji.sema", code: ";; ðŸ”¬ Emoji Lab: Unicode Under the Hood\n\n(println \"ðŸ”¬ Emoji Lab: Unicode Under the Hood\")\n(println (string/repeat \"â”€\" 40))\n\n;; Helpers\n(define hex-digits \"0123456789ABCDEF\")\n(define (int->hex n)\n  (define (digit k) (substring hex-digits k (+ k 1)))\n  (define (go x acc)\n    (if (< x 16) (string-append (digit x) acc)\n        (go (math/quotient x 16) (string-append (digit (mod x 16)) acc))))\n  (if (= n 0) \"0\" (go n \"\")))\n(define (u+ cp) (string-append \"U+\" (string/pad-left (int->hex cp) 4 \"0\")))\n(define (cp->str cp) (string/from-codepoints (list cp)))\n\n(define (inspect label s)\n  (println (format \"\\nâ”€â”€ ~a â”€â”€\" label))\n  (println (format \"  Glyph: ~a  codepoints=~a  bytes=~a\" s (string-length s) (string/byte-length s)))\n  (for-each (fn (cp)\n    (println (format \"    ~a  (~a bytes)  ~a\" (string/pad-right (u+ cp) 10) (string/byte-length (cp->str cp)) (cp->str cp))))\n    (string/codepoints s)))\n\n;; ðŸ“ Single vs multi-codepoint emoji\n(inspect \"Grinning face\" \"ðŸ˜€\")\n(inspect \"Heart + VS16\" (string/from-codepoints (list 10084 65039)))\n(inspect \"Family (ZWJ)\" (string/from-codepoints (list 128104 8205 128105 8205 128103)))\n\n;; ðŸŽ¨ Skin tone modifiers\n(println \"\\n\\nðŸŽ¨ Skin Tone Modifiers\")\n(define wave 128075)\n(for-each (fn (pair)\n  (let ((tone (first pair)) (name (nth pair 1)))\n    (println (format \"  ~a = ~a + ~a  (~a)\"\n      (string/from-codepoints (list wave tone)) (u+ wave) (u+ tone) name))))\n  (zip (list 127995 127996 127997 127998 127999)\n       (list \"Light\" \"Med-Light\" \"Medium\" \"Med-Dark\" \"Dark\")))\n\n;; ðŸ Flags from country codes\n(println \"\\nðŸ Flags from ISO Codes\")\n(define RI-A 127462)\n(define (flag iso)\n  (string/from-codepoints\n    (list (+ RI-A (- (char->integer (string-ref iso 0)) 65))\n          (+ RI-A (- (char->integer (string-ref iso 1)) 65)))))\n(for-each (fn (e) (println (format \"  ~a  ~a\" (flag (first e)) (nth e 1))))\n  (list (list \"NO\" \"Norway\") (list \"US\" \"United States\") (list \"JP\" \"Japan\")\n        (list \"BR\" \"Brazil\") (list \"GB\" \"United Kingdom\")))\n\n;; ðŸ§¬ Emoji Combinatorics: build emoji with ZWJ\n(println \"\\nðŸ§¬ Emoji Combinatorics\")\n(define ZWJ 8205)\n(define (zwj-join . emojis)\n  (string/from-codepoints\n    (foldl (fn (acc e) (if (null? acc) (string/codepoints e)\n      (append acc (list ZWJ) (string/codepoints e)))) (list) emojis)))\n(define man (cp->str 128104))\n(define woman (cp->str 128105))\n\n;; Families\n(println \"  ðŸ‘ª Families:\")\n(for-each (fn (e) (println (format \"    ~a  =  ~a\" (first e) (nth e 1))))\n  (list (list (zwj-join man woman (cp->str 128102)) \"ðŸ‘¨+ðŸ‘©+ðŸ‘¦\")\n        (list (zwj-join man woman (cp->str 128103) (cp->str 128102)) \"ðŸ‘¨+ðŸ‘©+ðŸ‘§+ðŸ‘¦\")\n        (list (zwj-join woman woman (cp->str 128102)) \"ðŸ‘©+ðŸ‘©+ðŸ‘¦\")\n        (list (zwj-join man man (cp->str 128103)) \"ðŸ‘¨+ðŸ‘¨+ðŸ‘§\")))\n\n;; Professions\n(println \"  ðŸ‘©â€ðŸ³ Professions:\")\n(for-each (fn (e)\n  (let ((tool (first e)) (icon (nth e 1)) (title (nth e 2)))\n    (println (format \"    ~a ~a  = ðŸ‘¨/ðŸ‘© + ~a  (~a)\"\n      (zwj-join man tool) (zwj-join woman tool) icon title))))\n  (list (list (cp->str 128187) \"ðŸ’»\" \"technologist\")\n        (list (cp->str 127859) \"ðŸ³\" \"cook\")\n        (list (cp->str 128300) \"ðŸ”¬\" \"scientist\")\n        (list (cp->str 128640) \"ðŸš€\" \"astronaut\")))\n\n;; Skin tones on professions\n(println \"  ðŸŽ¨ Woman astronaut in all tones:\")\n(println (format \"    ~a\"\n  (string/join (map (fn (t)\n    (string/from-codepoints (append (string/codepoints woman) (list t ZWJ) (string/codepoints (cp->str 128640)))))\n    (list 127995 127996 127997 127998 127999)) \" \")))\n\n;; ðŸ“Š Byte size heatmap\n(println \"\\nðŸ“Š Byte Size Heatmap\")\n(define specimens (list\n  (list \"A\" \"Latin A\") (list \"Ã©\" \"Accented\") (list \"â˜•\" \"Coffee\") (list \"ðŸ˜€\" \"Grin\")\n  (list (string/from-codepoints (list wave 127997)) \"Wave+skin\")\n  (list (flag \"NO\") \"Flag\") (list (string/from-codepoints (list 128104 8205 128105 8205 128103)) \"Family\")))\n(for-each (fn (e)\n  (let* ((g (first e)) (n (nth e 1)) (b (string/byte-length g)) (bl (min b 20)))\n    (println (format \"  ~a ~a ~a bytes â€” ~a\"\n      (string/pad-right g 4)\n      (string-append (string/repeat \"â–ˆ\" bl) (string/repeat \"â–‘\" (- 20 bl)))\n      b n))))\n  specimens)\n\n;; ðŸ” Emoji cipher\n(println \"\\nðŸ” Emoji Face Cipher\")\n(define faces-start 128512)\n(define faces-count 80)\n(define (shift-face cp shift)\n  (if (and (>= cp faces-start) (<= cp (+ faces-start faces-count -1)))\n    (+ faces-start (mod (+ (- cp faces-start) shift) faces-count)) cp))\n(define (emoji-cipher s shift)\n  (string/from-codepoints (map (fn (cp) (shift-face cp shift)) (string/codepoints s))))\n(define msg \"ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£\")\n(println (format \"  Original:  ~a\" msg))\n(println (format \"  Shift +13: ~a\" (emoji-cipher msg 13)))\n(println (format \"  Decoded:   ~a\" (emoji-cipher (emoji-cipher msg 13) (- faces-count 13))))\n(println \"\\nðŸŽ‰ Done!\")\n" },
    { id: "data/hashmap-demo.sema", name: "hashmap-demo.sema", code: ";; HashMap vs Map comparison and map operations\n\n(println \"=== Ordered Map vs HashMap ===\\n\")\n\n;; Ordered Map â€” keys sorted\n(define colors (hash-map :red \"#FF0000\" :green \"#00FF00\" :blue \"#0000FF\"))\n(println (format \"Ordered map: ~a\" colors))\n(println (format \"Keys (sorted): ~a\" (keys colors)))\n\n;; HashMap â€” unordered\n(define hm (hashmap/new :apple 3 :banana 5 :cherry 2))\n(println (format \"\\nHashMap: ~a\" hm))\n(println (format \"Get :banana â†’ ~a\" (hashmap/get hm :banana)))\n(define hm2 (hashmap/assoc hm :date 7))\n(println (format \"As ordered: ~a\" (hashmap/to-map hm2)))\n\n(println \"\\n=== Map Transformations ===\\n\")\n\n(define inventory (hash-map :widgets 100 :gadgets 50 :gizmos 75 :doohickeys 30))\n(println (format \"Inventory: ~a\" inventory))\n(println (format \"Doubled: ~a\" (map/map-vals (fn (v) (* v 2)) inventory)))\n(println (format \"Stock â‰¥50: ~a\" (map/filter (fn (k v) (>= v 50)) inventory)))\n(println (format \"Selected: ~a\" (map/select-keys inventory (list :widgets :gizmos))))\n\n;; Merge\n(define defaults (hash-map :color \"blue\" :size \"M\" :count 1))\n(define overrides (hash-map :color \"red\" :count 5))\n(println (format \"\\nMerged: ~a\" (merge defaults overrides)))\n\n(println \"\\n=== Word Frequency ===\\n\")\n\n(define sentence \"the cat sat on the mat the cat ate the rat\")\n(define freq\n  (foldl (fn (acc w)\n    (assoc acc (string->keyword w) (+ 1 (get acc (string->keyword w) 0))))\n    (hash-map) (string/split sentence \" \")))\n\n(for-each (fn (e)\n  (println (format \"  ~a â†’ ~a\" (string/pad-right (str (first e)) 6) (nth e 1))))\n  (sort (map/entries freq) (fn (a b) (- (nth b 1) (nth a 1)))))\n\n(println \"\\n=== Phone Book CRUD ===\\n\")\n\n(define (pb-add pb name phone) (assoc pb (string->keyword name) (hash-map :name name :phone phone)))\n(define pb (pb-add (pb-add (pb-add (hash-map) \"alice\" \"555-0101\") \"bob\" \"555-0202\") \"carol\" \"555-0303\"))\n(println (format \"~a contacts\" (count pb)))\n(define pb (dissoc pb :bob))\n(println (format \"After removing bob: ~a contacts\" (count pb)))\n(for-each (fn (e) (println (format \"  ~a: ~a\" (get (nth e 1) :name) (get (nth e 1) :phone)))) (map/entries pb))\n" },
    { id: "data/json-api.sema", name: "json-api.sema", code: ";; JSON processing and API response building\n\n(println \"=== JSON Processing ===\\n\")\n\n(define user\n  (hash-map \"name\" \"Alice\" \"age\" 30 \"email\" \"alice@example.com\"\n            \"tags\" (list \"admin\" \"verified\")\n            \"address\" (hash-map \"city\" \"Oslo\" \"country\" \"Norway\")))\n\n(println \"Pretty JSON:\")\n(println (json/encode-pretty user))\n\n;; Decode JSON\n(define json-str \"{\\\"id\\\":42,\\\"title\\\":\\\"Hello World\\\",\\\"published\\\":true,\\\"scores\\\":[95,87,92]}\")\n(define parsed (json/decode json-str))\n(println (format \"\\nTitle: ~a\" (get parsed :title)))\n(println (format \"Avg score: ~a\" (/ (list/sum (get parsed :scores)) (length (get parsed :scores)))))\n\n;; Roundtrip\n(define original (hash-map \"x\" 1 \"y\" (list 2 3) \"z\" (hash-map \"nested\" true)))\n(define rt (json/decode (json/encode original)))\n(println (format \"\\nRoundtrip match: ~a\" (equal? (json/encode original) (json/encode rt))))\n\n;; Query & transform\n(define products (json/decode\n  \"[{\\\"name\\\":\\\"Laptop\\\",\\\"price\\\":999,\\\"cat\\\":\\\"tech\\\"},{\\\"name\\\":\\\"Book\\\",\\\"price\\\":15,\\\"cat\\\":\\\"media\\\"},{\\\"name\\\":\\\"Phone\\\",\\\"price\\\":699,\\\"cat\\\":\\\"tech\\\"},{\\\"name\\\":\\\"Album\\\",\\\"price\\\":10,\\\"cat\\\":\\\"media\\\"}]\"))\n\n(define tech (filter (fn (p) (equal? (get p :cat) \"tech\")) products))\n(println (format \"\\nTech items: ~a\" (map (fn (p) (get p :name)) tech)))\n(println (format \"Tech total: $~a\" (list/sum (map (fn (p) (get p :price)) tech))))\n\n;; API response builder\n(define (api-ok data) (hash-map \"status\" 200 \"ok\" true \"data\" data))\n(define (api-error code msg) (hash-map \"status\" code \"ok\" false \"error\" msg))\n\n(println \"\\nAPI responses:\")\n(println (json/encode-pretty (api-ok (hash-map \"user\" \"Alice\" \"role\" \"admin\"))))\n(println (json/encode-pretty (api-error 404 \"Not found\")))\n" },
    { id: "data/regex-toolkit.sema", name: "regex-toolkit.sema", code: ";; Regex operations showcase\n\n(println \"=== Email Validation ===\\n\")\n\n(define emails (list \"alice@example.com\" \"bob AT mail\" \"charlie@dev.org\" \"not-an-email\"))\n(for-each (lambda (e)\n  (if (regex/match? \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\" e)\n    (println (format \"  âœ“ ~a\" e))\n    (println (format \"  âœ— ~a (invalid)\" e))))\n  emails)\n\n(println \"\\n=== URL Extraction ===\\n\")\n\n(define text-with-urls\n  \"Check out https://example.com and http://docs.sema-lang.org for info.\")\n(define urls (regex/find-all \"https?://[a-zA-Z0-9._~:/?#@!$&'()*+,;=-]+\" text-with-urls))\n(println (format \"Found ~a URL(s):\" (length urls)))\n(for-each (lambda (u) (println (format \"  â†’ ~a\" u))) urls)\n\n(println \"\\n=== Log Parser ===\\n\")\n\n(define log-lines (list\n  \"2026-02-14 08:23:01 [INFO] Server started on port 3000\"\n  \"2026-02-14 08:23:05 [WARN] Slow query (1230ms)\"\n  \"2026-02-14 08:24:12 [ERROR] Connection refused\"))\n\n(for-each (lambda (line)\n  (let ((m (regex/match \"^(\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}) \\\\[(\\\\w+)\\\\] (.+)$\" line)))\n    (if m\n      (let* ((groups (get m :groups))\n             (level (nth groups 1))\n             (icon (cond ((equal? level \"ERROR\") \"ðŸ”´\") ((equal? level \"WARN\") \"ðŸŸ¡\") (else \"ðŸŸ¢\"))))\n        (println (format \"  ~a ~a | ~a | ~a\" icon (nth groups 0) level (nth groups 2))))\n      (println (format \"  ?? ~a\" line)))))\n  log-lines)\n\n(println \"\\n=== Markdown Stripper ===\\n\")\n\n(define md \"# Hello\\nThis is **bold** and *italic* with `code` and [a link](http://x.com).\")\n(define stripped\n  (let* ((s (regex/replace-all \"^#{1,6}\\\\s+\" \"\" md))\n         (s (regex/replace-all \"\\\\*{1,3}([^*]+)\\\\*{1,3}\" \"$1\" s))\n         (s (regex/replace-all \"`([^`]+)`\" \"$1\" s))\n         (s (regex/replace-all \"\\\\[([^\\\\]]+)\\\\]\\\\([^)]+\\\\)\" \"$1\" s)))\n    s))\n(println (format \"Before: ~a\" md))\n(println (format \"After:  ~a\" stripped))\n\n(println \"\\n=== CamelCase Splitter ===\\n\")\n(define camel \"parseHTMLResponseCode\")\n(println (format \"~a â†’ ~a\" camel (regex/find-all \"[A-Z]?[a-z]+|[A-Z]+\" camel)))\n" },
    { id: "data/sets.sema", name: "sets.sema", code: ";;; Set data structure built on maps\n\n(define (set . elems) (foldl (fn (s e) (assoc s e #t)) {} elems))\n(define (list->set lst) (foldl (fn (s e) (assoc s e #t)) {} lst))\n(define (set->list s) (keys s))\n(define empty-set {})\n(define (set/size s) (length (keys s)))\n(define (set/member? s elem) (not (nil? (get s elem))))\n(define (set/add s elem) (assoc s elem #t))\n(define (set/remove s elem) (dissoc s elem))\n\n(define (set/union s1 s2)\n  (foldl (fn (s e) (assoc s e #t)) s1 (keys s2)))\n(define (set/intersection s1 s2)\n  (foldl (fn (s e) (if (set/member? s2 e) (assoc s e #t) s)) {} (keys s1)))\n(define (set/difference s1 s2)\n  (foldl (fn (s e) (if (set/member? s2 e) s (assoc s e #t))) {} (keys s1)))\n(define (set/subset? s1 s2)\n  (foldl (fn (acc e) (and acc (set/member? s2 e))) #t (keys s1)))\n(define (set/filter pred s)\n  (foldl (fn (acc e) (if (pred e) (assoc acc e #t) acc)) {} (keys s)))\n(define (set/map f s) (list->set (map f (keys s))))\n(define (set/fold f init s) (foldl f init (keys s)))\n(define (set/display s) (str \"#{\" (string/join (map str (set->list s)) \" \") \"}\"))\n\n(define (set/power-set s)\n  (let ((elems (set->list s)))\n    (foldl (fn (subsets elem)\n             (append subsets (map (fn (sub) (set/add sub elem)) subsets)))\n           (list empty-set) elems)))\n\n(println \"=== Sets ===\\n\")\n\n(define s1 (set 1 2 3 4 5))\n(define s2 (set 3 4 5 6 7))\n(define s3 (set 1 2 3))\n\n(println (format \"s1 = ~a\" (set/display s1)))\n(println (format \"s2 = ~a\" (set/display s2)))\n(println (format \"\\ns1 âˆª s2  = ~a\" (set/display (set/union s1 s2))))\n(println (format \"s1 âˆ© s2  = ~a\" (set/display (set/intersection s1 s2))))\n(println (format \"s1 \\\\ s2  = ~a\" (set/display (set/difference s1 s2))))\n(println (format \"\\ns3 âŠ† s1? ~a\" (set/subset? s3 s1)))\n(println (format \"evens:   ~a\" (set/display (set/filter even? s1))))\n(println (format \"doubled: ~a\" (set/display (set/map (fn (x) (* x 2)) s1))))\n(println (format \"sum:     ~a\" (set/fold + 0 s1)))\n\n(println (format \"\\nPower set of ~a:\" (set/display (set 1 2 3))))\n(for-each (fn (sub) (println (format \"  ~a\" (set/display sub))))\n  (set/power-set (set 1 2 3)))\n" },
    { id: "data/strings.sema", name: "strings.sema", code: ";; String operations\n(define text \"Hello, Sema World!\")\n\n(println \"Upper:\" (string/upper text))\n(println \"Lower:\" (string/lower text))\n(println \"Words:\" (string/split text \" \"))\n(println \"Length:\" (string-length text))\n(println \"Reversed:\" (string/reverse text))\n(println \"Contains 'Sema':\" (string/contains? text \"Sema\"))\n\n;; String formatting\n(define name \"Sema\")\n(define version \"1.0.1\")\n(format \"~a v~a â€” A Lisp with LLM primitives\" name version)\n" },
    { id: "data/text-processing.sema", name: "text-processing.sema", code: ";; String manipulation, regex, and text analysis\n\n(define sample-text\n  \"The quick brown fox jumps over the lazy dog. The dog barked at the fox.\n   Foxes are clever animals. Dogs are loyal companions.\n   The quick brown fox ran quickly through the forest.\")\n\n;; Word frequency analysis\n(define words (map string/lower (regex/find-all \"[A-Za-z]+\" sample-text)))\n(println (format \"Total words: ~a\" (length words)))\n(println (format \"Unique words: ~a\" (length (list/unique words))))\n\n(define freq\n  (foldl (fn (acc word)\n    (map/update acc (string->keyword word) (fn (v) (if (nil? v) 1 (+ v 1)))))\n    {} words))\n\n(define sorted-freq\n  (sort (map/entries freq) (fn (a b) (- (nth b 1) (nth a 1)))))\n\n(println \"\\nTop 10 most frequent words:\")\n(for-each\n  (fn (entry)\n    (println (format \"  ~a: ~a\"\n      (string/pad-right (keyword->string (first entry)) 12)\n      (string/repeat \"#\" (nth entry 1)))))\n  (take 10 sorted-freq))\n\n;; Sentence extraction\n(define sentences\n  (filter (fn (s) (> (string-length (string/trim s)) 0))\n    (regex/split \"[.!?]+\" sample-text)))\n(println (format \"\\n~a sentences found:\" (length sentences)))\n(for-each (fn (s) (println (format \"  - ~a\" (string/trim s)))) sentences)\n\n;; Caesar cipher\n(define (caesar-encrypt text shift)\n  (list->string\n    (map (fn (ch)\n      (if (char-alphabetic? ch)\n        (let ((base (if (char-upper-case? ch) 65 97))\n              (code (char->integer ch)))\n          (integer->char (+ base (math/remainder (- (+ code shift) base) 26))))\n        ch))\n      (string/chars text))))\n\n(define original \"Hello World\")\n(define encrypted (caesar-encrypt original 3))\n(define decrypted (caesar-encrypt encrypted 23))\n(println (format \"\\nCaesar cipher (shift 3):\"))\n(println (format \"  Original:  ~a\" original))\n(println (format \"  Encrypted: ~a\" encrypted))\n(println (format \"  Decrypted: ~a\" decrypted))\n" },
    { id: "data/text-tools.sema", name: "text-tools.sema", code: ";; text-tools.sema â€” Text processing and prompt template utilities\n;; No API key required â€” all functions run locally.\n;;\n;; Demonstrates: text chunking, sentence splitting, text cleaning,\n;;               and prompt templates.\n\n;; --- 1. Text Chunking ---\n(println \"=== 1. Text Chunking ===\")\n\n(define article\n  \"Sema is a Lisp with first-class LLM primitives. It combines a Scheme core with Clojure-style keywords and map literals. Prompts are s-expressions, conversations are persistent data structures, and LLM calls are just another form of evaluation.\n\nThe language includes 350+ built-in functions across 19 modules. It supports tail-call optimization, macros, modules, error handling, HTTP, file I/O, regex, JSON, and much more.\n\nSema runs on all major platforms. The interpreter is implemented in Rust, providing fast startup times and low memory usage. A WebAssembly build powers the browser-based playground at sema.run.\")\n\n;; Chunk with custom size\n(define chunks (text/chunk article {:size 200 :overlap 0}))\n(println (format \"Chunks (200 chars, no overlap): ~a chunks\" (length chunks)))\n(for-each\n  (lambda (c) (println (format \"  [~a chars] ~a\" (string-length c) (text/truncate c 60))))\n  chunks)\n\n;; Chunk with overlap\n(define chunks-ov (text/chunk article {:size 200 :overlap 50}))\n(println (format \"\\nChunks (200 chars, 50 overlap): ~a chunks\" (length chunks-ov)))\n\n;; Default chunking (1000 chars, 200 overlap)\n(define chunks-default (text/chunk article))\n(println (format \"Default chunking: ~a chunk(s)\" (length chunks-default)))\n\n;; --- 2. Chunk by Separator ---\n(println \"\\n=== 2. Chunk by Separator ===\")\n(define csv-like \"alice,bob,charlie,diana\")\n(define parts (text/chunk-by-separator csv-like \",\"))\n(println (format \"Split by comma: ~a\" parts))\n\n(define paragraphs (text/chunk-by-separator article \"\\n\\n\"))\n(println (format \"Paragraphs: ~a\" (length paragraphs)))\n\n;; --- 3. Sentence Splitting ---\n(println \"\\n=== 3. Sentence Splitting ===\")\n(define text \"Hello world. How are you? I'm fine! This is great.\")\n(define sentences (text/split-sentences text))\n(println (format \"Sentences: ~a\" sentences))\n(println (format \"Count: ~a\" (length sentences)))\n\n;; --- 4. Text Cleaning ---\n(println \"\\n=== 4. Text Cleaning ===\")\n\n;; Clean whitespace\n(define messy \"  Hello    world   from    Sema  \")\n(println (format \"Clean whitespace: '~a' => '~a'\"\n  messy (text/clean-whitespace messy)))\n\n;; Strip HTML\n(define html \"<h1>Title</h1><p>Hello &amp; welcome to <b>Sema</b>!</p>\")\n(println (format \"Strip HTML: ~a => ~a\" html (text/strip-html html)))\n\n;; Truncate\n(define long-text \"This is a very long string that should be truncated\")\n(println (format \"Truncate (20): ~a\" (text/truncate long-text 20)))\n(println (format \"Truncate (20, 'â€¦'): ~a\" (text/truncate long-text 20 \"â€¦\")))\n(println (format \"Truncate (100): ~a\" (text/truncate long-text 100))) ;; no change\n\n;; Word count\n(println (format \"Word count: ~a\" (text/word-count article)))\n(println (format \"Word count (empty): ~a\" (text/word-count \"\")))\n\n;; Trim indent\n(define indented \"    line one\\n    line two\\n      line three\")\n(println (format \"Trim indent:\\n~a\" (text/trim-indent indented)))\n\n;; --- 5. Prompt Templates ---\n(println \"\\n=== 5. Prompt Templates ===\")\n\n(define tmpl (prompt/template \"Hello {{name}}, you are a {{role}}.\"))\n(println (format \"Template: ~a\" tmpl))\n\n(define rendered (prompt/render tmpl {:name \"Alice\" :role \"developer\"}))\n(println (format \"Rendered: ~a\" rendered))\n\n;; Missing variable stays as-is\n(define partial (prompt/render \"Hi {{name}}, your score is {{score}}\" {:name \"Bob\"}))\n(println (format \"Partial: ~a\" partial))\n\n;; Numbers in templates\n(define with-num (prompt/render \"Count: {{n}}\" {:n 42}))\n(println (format \"With number: ~a\" with-num))\n\n(println \"\\nText tools demo complete!\")\n" },
    { id: "data/unicode.sema", name: "unicode.sema", code: ";; Unicode-aware string operations\n\n;; Byte length vs character length\n(define samples (list \"hello\" \"hÃ©llo\" \"æ—¥æœ¬èªž\" \"ðŸŽ‰ðŸŽŠ\"))\n(println \"=== Byte Length vs Character Length ===\")\n(for-each\n  (fn (s)\n    (println (format \"  ~a  chars=~a  bytes=~a\"\n      (string/pad-right (string-append \"\\\"\" s \"\\\"\") 12)\n      (string-length s)\n      (string/byte-length s))))\n  samples)\n\n;; Codepoints roundtrip\n(println \"\\n=== Codepoints ===\")\n(define text \"CafÃ© â˜•\")\n(define cps (string/codepoints text))\n(println (format \"  String:     ~a\" text))\n(println (format \"  Codepoints: ~a\" cps))\n(println (format \"  Roundtrip:  ~a\" (string/from-codepoints cps)))\n\n;; Build from known codepoints (Greek: Î“ÎµÎ¹Î±)\n(println (format \"  Greek hello: ~a\"\n  (string/from-codepoints (list 915 949 953 945))))\n\n;; Unicode normalization\n(println \"\\n=== Normalization ===\")\n(define decomposed (string-append \"e\" \"\\u0301\"))\n(define composed (string/normalize decomposed :nfc))\n(println (format \"  Decomposed: ~a (length=~a)\" decomposed (string-length decomposed)))\n(println (format \"  NFC:        ~a (length=~a)\" composed (string-length composed)))\n(println (format \"  NFKC of ï¬:  ~a\" (string/normalize \"\\uFB01\" :nfkc)))\n\n;; Case folding\n(println \"\\n=== Case Folding ===\")\n(for-each\n  (fn (w)\n    (println (format \"  ~a â†’ ~a\" (string/pad-right w 10) (string/foldcase w))))\n  (list \"HELLO\" \"World\" \"StraÃŸe\" \"Î©ÎœÎ•Î“Î‘\"))\n\n;; Case-insensitive comparison\n(println \"\\n=== Case-Insensitive Comparison ===\")\n(println (format \"  (string-ci=? \\\"Hello\\\" \\\"hello\\\") => ~a\" (string-ci=? \"Hello\" \"hello\")))\n(println (format \"  (string-ci=? \\\"CAFÃ‰\\\" \\\"cafÃ©\\\")   => ~a\" (string-ci=? \"CAFÃ‰\" \"cafÃ©\")))\n(println (format \"  (string-ci=? \\\"hello\\\" \\\"world\\\") => ~a\" (string-ci=? \"hello\" \"world\")))\n" }
  ]},
  { category: "Filesystem", files: [
    { id: "filesystem/delete-rename.sema", name: "delete-rename.sema", code: ";; Deleting and renaming files\n\n(println \"=== Delete & Rename ===\\n\")\n\n;; Create some files\n(file/write \"draft.txt\" \"Work in progress...\")\n(file/write \"old-name.txt\" \"I will be renamed!\")\n(file/write \"temp.txt\" \"Delete me!\")\n\n(println \"Before:\")\n(for-each\n  (lambda (f) (println (format \"  ~a\" f)))\n  (file/list \"/\"))\n\n;; Delete a file\n(file/delete \"temp.txt\")\n(println (format \"\\ntemp.txt exists after delete? ~a\" (file/exists? \"temp.txt\")))\n\n;; Rename a file\n(file/rename \"old-name.txt\" \"new-name.txt\")\n(println (format \"old-name.txt exists? ~a\" (file/exists? \"old-name.txt\")))\n(println (format \"new-name.txt exists? ~a\" (file/exists? \"new-name.txt\")))\n(println (format \"new-name.txt content: ~a\" (file/read \"new-name.txt\")))\n\n(println \"\\nAfter:\")\n(for-each\n  (lambda (f) (println (format \"  ~a\" f)))\n  (file/list \"/\"))\n" },
    { id: "filesystem/directories.sema", name: "directories.sema", code: ";; Creating and navigating directories\n\n(println \"=== Directories ===\\n\")\n\n;; Create nested directories\n(file/mkdir \"project\")\n(file/mkdir \"project/src\")\n(file/mkdir \"project/docs\")\n(file/mkdir \"project/tests\")\n\n;; Write files into the structure\n(file/write \"project/README.md\" \"# My Project\\nA demo project in the VFS.\")\n(file/write \"project/src/main.sema\" \"(println \\\"hello\\\")\")\n(file/write \"project/src/utils.sema\" \"(define (add a b) (+ a b))\")\n(file/write \"project/docs/guide.md\" \"# User Guide\\nGetting started...\")\n(file/write \"project/tests/test1.sema\" \"(assert (= 2 (+ 1 1)))\")\n\n;; Check types\n(println (format \"project/ is directory? ~a\" (file/is-directory? \"project\")))\n(println (format \"project/README.md is file? ~a\" (file/is-file? \"project/README.md\")))\n(println (format \"project/src is directory? ~a\" (file/is-directory? \"project/src\")))\n\n;; List directory contents\n(for-each\n  (lambda (dir)\n    (let ((items (file/list dir)))\n      (println (format \"\\n~a/ (~a items)\" dir (length items)))\n      (for-each (lambda (f) (println (format \"  ~a\" f))) items)))\n  (list \"project\" \"project/src\" \"project/docs\" \"project/tests\"))\n" },
    { id: "filesystem/maze-generator.sema", name: "maze-generator.sema", code: ";; Maze Generator â€” writes maze data to VFS files\n;; Run this first, then run maze-solver.sema!\n\n(define width 12)\n(define height 8)\n\n(define (pos x y) (str x \",\" y))\n\n(define (shuffle lst)\n  (if (<= (length lst) 1) lst\n    (let* ((i (math/random-int 0 (- (length lst) 1)))\n           (picked (nth lst i))\n           (rest (append (take i lst) (drop (+ i 1) lst))))\n      (cons picked (shuffle rest)))))\n\n(define directions (list (list 0 -1) (list 0 1) (list -1 0) (list 1 0)))\n\n(define (unvisited-neighbors grid cx cy)\n  (filter\n    (fn (entry)\n      (let ((nx (car entry)) (ny (cadr entry)))\n        (and (>= nx 0) (< nx width)\n             (>= ny 0) (< ny height)\n             (not (get grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #f)))))\n    (map (fn (dir)\n           (list (+ cx (car dir)) (+ cy (cadr dir)) (car dir) (cadr dir)))\n         (shuffle directions))))\n\n(define (generate-maze)\n  (let loop ((stack (list (list 0 0)))\n             (grid (assoc {} (pos 1 1) #t)))\n    (if (null? stack) grid\n      (let* ((cell (car stack))\n             (cx (car cell)) (cy (cadr cell))\n             (neighbors (unvisited-neighbors grid cx cy)))\n        (if (null? neighbors)\n          (loop (cdr stack) grid)\n          (let* ((next (car neighbors))\n                 (nx (car next)) (ny (cadr next))\n                 (dx (nth next 2)) (dy (nth next 3))\n                 (grid (assoc grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #t))\n                 (grid (assoc grid (pos (+ (* cx 2) 1 dx) (+ (* cy 2) 1 dy)) #t)))\n            (loop (cons (list nx ny) stack) grid)))))))\n\n(define grid-w (+ (* 2 width) 1))\n(define grid-h (+ (* 2 height) 1))\n\n(define (wall? grid x y)\n  (and (>= x 0) (< x grid-w) (>= y 0) (< y grid-h)\n       (not (get grid (pos x y) #f))))\n\n(define (box-char grid x y)\n  (let* ((u (wall? grid x (- y 1)))\n         (d (wall? grid x (+ y 1)))\n         (l (wall? grid (- x 1) y))\n         (r (wall? grid (+ x 1) y))\n         (bits (+ (if u 1 0) (if d 2 0) (if l 4 0) (if r 8 0))))\n    (cond\n      ((= bits 15) \"â”¼â”€\")  ((= bits 14) \"â”¬â”€\")  ((= bits 13) \"â”´â”€\")\n      ((= bits 11) \"â”œâ”€\")  ((= bits  7) \"â”¤ \")  ((= bits  6) \"â” \")\n      ((= bits 10) \"â”Œâ”€\")  ((= bits  5) \"â”˜ \")  ((= bits  9) \"â””â”€\")\n      ((= bits 12) \"â”€â”€\")  ((= bits  3) \"â”‚ \")  ((= bits  1) \"â”‚ \")\n      ((= bits  2) \"â”‚ \")  ((= bits  4) \"â”€ \")  ((= bits  8) \"â”€â”€\")\n      (else \"Â· \"))))\n\n(define (render grid)\n  (string/join\n    (map (fn (y)\n      (string/join\n        (map (fn (x)\n               (if (get grid (pos x y) #f) \"  \" (box-char grid x y)))\n             (range grid-w)) \"\"))\n    (range grid-h)) \"\\n\"))\n\n;; Generate and save\n(define grid (generate-maze))\n(define maze-text (render grid))\n\n(file/mkdir \"mazes\")\n\n;; Save the grid as a serialized map (passable cells)\n(define passable-cells\n  (filter (fn (key) (get grid key #f))\n    (apply append\n      (map (fn (y)\n        (map (fn (x) (pos x y)) (range grid-w)))\n        (range grid-h)))))\n\n(file/write \"mazes/grid-data.txt\"\n  (string-append\n    (str grid-w) \"\\n\"\n    (str grid-h) \"\\n\"\n    (string/join passable-cells \"\\n\")))\n\n(file/write \"mazes/maze.txt\" maze-text)\n\n(println \"=== Maze Generator ===\\n\")\n(println maze-text)\n(println \"\\nðŸ“ Saved to VFS:\")\n(println \"   mazes/maze.txt      â€” ASCII rendering\")\n(println \"   mazes/grid-data.txt â€” grid data for solver\")\n(println \"\\nðŸ’¡ Now run maze-solver.sema to solve it!\")\n" },
    { id: "filesystem/maze-solver.sema", name: "maze-solver.sema", code: ";; Maze Solver â€” reads maze from VFS, solves with BFS\n;; Run maze-generator.sema first to create the maze files!\n\n(println \"=== Maze Solver ===\\n\")\n\n;; Check if maze data exists\n(if (not (file/exists? \"mazes/grid-data.txt\"))\n  (begin\n    (println \"âš ï¸  No maze found! Generating one first...\\n\")\n    (for-each eval (load \"maze-generator.sema\"))\n    (println \"\\n--- Now solving ---\\n\")))\n\n;; Read grid data\n(define raw (file/read \"mazes/grid-data.txt\"))\n(define lines (string-split raw \"\\n\"))\n(define grid-w (int (first lines)))\n(define grid-h (int (nth lines 1)))\n\n;; Rebuild grid map from passable cells\n(define grid\n  (foldl (fn (g cell) (assoc g cell #t))\n    {} (drop 2 lines)))\n\n(define directions (list (list 0 1) (list 0 -1) (list 1 0) (list -1 0)))\n(define (pos x y) (str x \",\" y))\n\n;; BFS solver\n(define (reconstruct-path parent start-key end-key)\n  (let loop ((key end-key)\n             (path (assoc {} end-key #t)))\n    (if (equal? key start-key) path\n      (let ((prev (get parent key #f)))\n        (if prev\n          (loop prev (assoc path prev #t))\n          path)))))\n\n(define (solve start-x start-y end-x end-y)\n  (let ((start-key (pos start-x start-y))\n        (end-key (pos end-x end-y)))\n    (let bfs ((queue (list (list start-x start-y)))\n              (visited (assoc {} start-key #t))\n              (parent {}))\n      (if (null? queue) {}\n        (let* ((current (car queue))\n               (rest-queue (cdr queue))\n               (cx (car current)) (cy (cadr current)))\n          (if (and (= cx end-x) (= cy end-y))\n            (reconstruct-path parent start-key end-key)\n            (let* ((nbrs (filter\n                           (fn (n)\n                             (let ((nx (car n)) (ny (cadr n)))\n                               (and (>= nx 0) (< nx grid-w)\n                                    (>= ny 0) (< ny grid-h)\n                                    (get grid (pos nx ny) #f)\n                                    (not (get visited (pos nx ny) #f)))))\n                           (map (fn (d) (list (+ cx (car d)) (+ cy (cadr d))))\n                                directions)))\n                   (state (foldl\n                            (fn (acc n)\n                              (let ((nkey (pos (car n) (cadr n))))\n                                (list (append (car acc) (list n))\n                                      (assoc (cadr acc) nkey #t)\n                                      (assoc (nth acc 2) nkey (pos cx cy)))))\n                            (list rest-queue visited parent)\n                            nbrs)))\n              (bfs (car state) (cadr state) (nth state 2)))))))))\n\n;; Box drawing for walls\n(define (wall? x y)\n  (and (>= x 0) (< x grid-w) (>= y 0) (< y grid-h)\n       (not (get grid (pos x y) #f))))\n\n(define (box-char x y)\n  (let* ((u (wall? x (- y 1)))\n         (d (wall? x (+ y 1)))\n         (l (wall? (- x 1) y))\n         (r (wall? (+ x 1) y))\n         (bits (+ (if u 1 0) (if d 2 0) (if l 4 0) (if r 8 0))))\n    (cond\n      ((= bits 15) \"â”¼â”€\")  ((= bits 14) \"â”¬â”€\")  ((= bits 13) \"â”´â”€\")\n      ((= bits 11) \"â”œâ”€\")  ((= bits  7) \"â”¤ \")  ((= bits  6) \"â” \")\n      ((= bits 10) \"â”Œâ”€\")  ((= bits  5) \"â”˜ \")  ((= bits  9) \"â””â”€\")\n      ((= bits 12) \"â”€â”€\")  ((= bits  3) \"â”‚ \")  ((= bits  1) \"â”‚ \")\n      ((= bits  2) \"â”‚ \")  ((= bits  4) \"â”€ \")  ((= bits  8) \"â”€â”€\")\n      (else \"Â· \"))))\n\n;; Render with solution path\n(define (render-solved path)\n  (string/join\n    (map (fn (y)\n      (string/join\n        (map (fn (x)\n               (if (get grid (pos x y) #f)\n                 (if (get path (pos x y) #f) \"Â· \" \"  \")\n                 (box-char x y)))\n             (range grid-w)) \"\"))\n    (range grid-h)) \"\\n\"))\n\n;; Solve from top-left to bottom-right\n(define path (solve 1 1 (- grid-w 2) (- grid-h 2)))\n(define solved-text (render-solved path))\n\n(file/write \"mazes/solved.txt\" solved-text)\n\n(println solved-text)\n(println (format \"\\nðŸ“ Solution saved to mazes/solved.txt\"))\n(println \"ðŸ’¡ Switch to the Files tab to browse all maze files!\")\n" },
    { id: "filesystem/read-write.sema", name: "read-write.sema", code: ";; Reading and writing files in the VFS\n\n(println \"=== File Read & Write ===\\n\")\n\n;; Write a file\n(file/write \"hello.txt\" \"Hello from the Virtual Filesystem!\")\n(println \"Wrote hello.txt\")\n\n;; Read it back\n(define content (file/read \"hello.txt\"))\n(println (format \"Read back: ~a\" content))\n\n;; Overwrite with new content\n(file/write \"hello.txt\" \"Updated content!\")\n(println (format \"After update: ~a\" (file/read \"hello.txt\")))\n\n;; Append to a file\n(file/write \"log.txt\" \"Line 1\\n\")\n(file/append \"log.txt\" \"Line 2\\n\")\n(file/append \"log.txt\" \"Line 3\\n\")\n(println (format \"\\nLog contents:\\n~a\" (file/read \"log.txt\")))\n" },
    { id: "filesystem/static-site.sema", name: "static-site.sema", code: ";; Mini static site generator using the VFS\n\n(println \"=== Static Site Generator ===\\n\")\n\n;; Scaffold\n(file/mkdir \"site\")\n(file/mkdir \"site/src\")\n(file/mkdir \"site/dist\")\n\n;; Write source pages\n(file/write \"site/src/index.md\"\n  \"# Welcome\\nThis site was built entirely in the VFS!\")\n\n(file/write \"site/src/about.md\"\n  \"# About\\nPowered by Sema running in WebAssembly.\")\n\n;; HTML template\n(define (wrap-html title body)\n  (string-append\n    \"<!doctype html>\\n<html>\\n<head><title>\" title \"</title>\\n\"\n    \"<style>body{font:16px/1.6 system-ui;max-width:640px;margin:2rem auto;color:#333}\"\n    \"h1{color:#c8a855}a{color:#7aacb8}nav{margin-bottom:2rem}</style>\\n\"\n    \"</head>\\n<body>\\n\"\n    \"<nav><a href=\\\"index.html\\\">Home</a> Â· <a href=\\\"about.html\\\">About</a></nav>\\n\"\n    \"<pre>\" body \"</pre>\\n\"\n    \"</body>\\n</html>\\n\"))\n\n;; Build pages\n(define pages '((\"index\" \"Welcome\") (\"about\" \"About\")))\n\n(for-each\n  (lambda (page)\n    (let* ((slug (car page))\n           (title (cadr page))\n           (src (file/read (format \"site/src/~a.md\" slug)))\n           (html (wrap-html title src)))\n      (file/write (format \"site/dist/~a.html\" slug) html)\n      (println (format \"  Built site/dist/~a.html\" slug))))\n  pages)\n\n;; Build log\n(file/write \"site/build.log\" \"Build complete!\\n\")\n(for-each\n  (lambda (p) (file/append \"site/build.log\" (format \"  - ~a.html\\n\" (car p))))\n  pages)\n\n(println (format \"\\n~a\" (file/read \"site/build.log\")))\n(println \"Click files in the Files tab to view the generated HTML!\")\n" },
    { id: "filesystem/word-count.sema", name: "word-count.sema", code: ";; Word frequency counter â€” works great with uploaded files!\n;; Upload a .txt file to /uploads/ then change the path below.\n\n(println \"=== Word Frequency Counter ===\\n\")\n\n;; Create a sample text file to analyze\n(file/write \"sample.txt\"\n  \"the quick brown fox jumps over the lazy dog\nthe dog barked at the fox and the fox ran away\nthe quick fox was too quick for the lazy dog\")\n\n(define text (file/read \"sample.txt\"))\n\n;; Split into words and count\n(define words\n  (map string/downcase\n    (filter (lambda (w) (> (string-length w) 0))\n      (string-split text \" \\n\\t\"))))\n\n(define counts\n  (foldl (lambda (acc word)\n    (assoc acc word (+ 1 (or (map-get acc word) 0))))\n    {} words))\n\n;; Sort by frequency (descending)\n(define sorted\n  (sort (map->list counts)\n    (lambda (a b) (> (cdr a) (cdr b)))))\n\n(println (format \"Total words: ~a\" (length words)))\n(println (format \"Unique words: ~a\\n\" (length sorted)))\n\n(println \"Top words:\")\n(for-each\n  (lambda (pair)\n    (println (format \"  ~a: ~a\" (car pair) (cdr pair))))\n  (take sorted 10))\n" }
  ]},
  { category: "HTTP & APIs", files: [
    { id: "http/dad-jokes.sema", name: "dad-jokes.sema", code: ";; Fetch random dad jokes from icanhazdadjoke.com\n;;\n;; This API returns a random joke on each request.\n;; CORS-enabled, no API key needed.\n\n(println \"=== Dad Joke Machine ðŸ¤£ ===\\n\")\n\n(define (get-joke)\n  (let ((resp (http/get \"https://icanhazdadjoke.com/\"\n                {:headers {:Accept \"application/json\"}})))\n    (if (= (:status resp) 200)\n      (get (json/decode (:body resp)) :joke)\n      \"(couldn't fetch a joke)\")))\n\n;; Due to the replay-cache strategy, each http/get with the\n;; same URL+headers returns the same cached response within\n;; one evaluation. So we get one joke per run.\n(define joke (get-joke))\n(println (format \"  ~a\" joke))\n(println \"\\n  (Press Run again for a new joke!)\")\n" },
    { id: "http/exchange-rates.sema", name: "exchange-rates.sema", code: ";; Fetch live currency exchange rates\n;;\n;; Uses the ExchangeRate API (no key, CORS-enabled)\n\n(println \"=== Currency Exchange Dashboard ===\\n\")\n\n(define currencies (list \"EUR\" \"GBP\" \"JPY\" \"CHF\" \"CAD\" \"AUD\" \"NOK\" \"SEK\" \"CNY\" \"KRW\"))\n\n(let* ((resp (http/get \"https://open.er-api.com/v6/latest/USD\"))\n       (data (json/decode (:body resp)))\n       (rates (get data :rates)))\n\n  (println (format \"  Base: USD â€” ~a\\n\" (get data :time_last_update_utc)))\n\n  (println (format \"  ~a  ~a  ~a\"\n    (string/pad-right \"Currency\" 10)\n    (string/pad-right \"Rate\" 14)\n    \"Inverse (per USD)\"))\n  (println (format \"  ~a  ~a  ~a\"\n    (string/repeat \"â”€\" 10)\n    (string/repeat \"â”€\" 14)\n    (string/repeat \"â”€\" 18)))\n\n  (for-each (fn (cur)\n    (let* ((rate (get rates (string->keyword cur)))\n           (inverse (if (and rate (> rate 0))\n                      (/ (round (* (/ 1 rate) 10000)) 10000)\n                      0))\n           (rate-str (str rate)))\n      (println (format \"  ~a  ~a  ~a\"\n        (string/pad-right cur 10)\n        (string/pad-right rate-str 14)\n        inverse))))\n    currencies))\n" },
    { id: "http/fetch-basics.sema", name: "fetch-basics.sema", code: ";; HTTP basics â€” fetching data from public APIs\n;;\n;; Note: CORS restrictions apply in the browser.\n;; These examples use APIs that allow cross-origin requests.\n\n(println \"=== HTTP in the Playground ===\\n\")\n\n;; Simple GET request\n(define resp (http/get \"https://httpbin.org/get\"))\n(println (format \"Status: ~a\" (:status resp)))\n(println (format \"Body is string? ~a\" (string? (:body resp))))\n(println (format \"Headers: ~a keys\" (length (keys (:headers resp)))))\n\n;; Parse the JSON body\n(define data (json/decode (:body resp)))\n(println (format \"\\nOrigin IP: ~a\" (get data :origin)))\n(println (format \"URL: ~a\" (get data :url)))\n\n;; POST with a JSON body\n(println \"\\n--- POST Request ---\\n\")\n(define post-resp\n  (http/post \"https://httpbin.org/post\" {:name \"Sema\" :version \"1.5\"}))\n(println (format \"Status: ~a\" (:status post-resp)))\n(define post-data (json/decode (:body post-resp)))\n(println (format \"Echoed JSON: ~a\" (get post-data :data)))\n\n;; Custom headers\n(println \"\\n--- Custom Headers ---\\n\")\n(define header-resp\n  (http/get \"https://httpbin.org/headers\"\n    {:headers {:X-Custom \"hello-from-sema\" :Accept \"application/json\"}}))\n(define header-data (json/decode (:body header-resp)))\n(println (format \"Server saw headers: ~a\" (get header-data :headers)))\n" },
    { id: "http/ip-lookup.sema", name: "ip-lookup.sema", code: ";; Look up your public IP and geolocation\n;;\n;; Uses ip-api.com (free, no key, CORS-enabled)\n\n(println \"=== IP Geolocation ===\\n\")\n\n(define resp (http/get \"http://ip-api.com/json/?fields=query,country,regionName,city,timezone,isp,org\"))\n\n(if (= (:status resp) 200)\n  (let ((info (json/decode (:body resp))))\n    (println (format \"  IP:       ~a\" (get info :query)))\n    (println (format \"  Location: ~a, ~a, ~a\" (get info :city) (get info :regionName) (get info :country)))\n    (println (format \"  Timezone: ~a\" (get info :timezone)))\n    (println (format \"  ISP:      ~a\" (get info :isp)))\n    (println (format \"  Org:      ~a\" (get info :org))))\n  (println (format \"Request failed with status ~a\" (:status resp))))\n" },
    { id: "http/random-user.sema", name: "random-user.sema", code: ";; Generate random user profiles from randomuser.me\n;;\n;; randomuser.me is a free API that generates fake user data\n;; (CORS-enabled, no API key needed)\n\n(println \"=== Random User Profiles ===\\n\")\n\n(define resp (http/get \"https://randomuser.me/api/?results=5&nat=us,gb,no,de,fr\"))\n\n(if (= (:status resp) 200)\n  (let ((data (json/decode (:body resp))))\n    (for-each (fn (user)\n      (let* ((name (get user :name))\n             (loc  (get user :location))\n             (full-name (format \"~a ~a\" (get name :first) (get name :last)))\n             (city (get loc :city))\n             (country (get loc :country))\n             (email (get user :email))\n             (age (get (get user :dob) :age)))\n        (println (format \"  ~a (~a)\" full-name age))\n        (println (format \"    ðŸ“§ ~a\" email))\n        (println (format \"    ðŸ“ ~a, ~a\" city country))\n        (println \"\")))\n      (get data :results)))\n  (println (format \"Failed: ~a\" (:status resp))))\n" }
  ]},
  { category: "Patterns", files: [
    { id: "patterns/dsl-builder.sema", name: "dsl-builder.sema", code: ";; Mini DSL system for HTML and CSS generation\n\n(println \"=== HTML DSL ===\\n\")\n\n(define self-closing (list \"br\" \"hr\" \"img\" \"input\"))\n\n(define (render-attrs attrs)\n  (if (empty? attrs) \"\"\n    (string-append \" \"\n      (string/join (map (fn (e)\n        (format \"~a=\\\"~a\\\"\" (keyword->string (first e)) (nth e 1)))\n        (map/entries attrs)) \" \"))))\n\n(define (tag name attrs . children)\n  (if (member name self-closing)\n    (format \"<~a~a />\" name (render-attrs attrs))\n    (format \"<~a~a>~a</~a>\" name (render-attrs attrs) (string/join children \"\") name)))\n\n(define (html . ch) (tag \"html\" {} (string/join ch \"\\n\")))\n(define (head . ch) (tag \"head\" {} (string/join ch \"\\n\")))\n(define (body . ch) (tag \"body\" {} (string/join ch \"\\n\")))\n(define (div attrs . ch) (tag \"div\" attrs (string/join ch \"\\n\")))\n(define (title t) (tag \"title\" {} t))\n(define (h1 t) (tag \"h1\" {} t))\n(define (h2 t) (tag \"h2\" {} t))\n(define (p t) (tag \"p\" {} t))\n(define (a attrs t) (tag \"a\" attrs t))\n(define (ul . items) (tag \"ul\" {} (string/join (map (fn (i) (tag \"li\" {} i)) items) \"\\n\")))\n(define (hr) (tag \"hr\" {}))\n\n(println (div {:class \"card\"} (h2 \"Welcome\") (p \"Hello world.\") (hr) (p \"Footer\")))\n\n(println \"\\n=== CSS DSL ===\\n\")\n\n(define (pairs->decls kvs)\n  (if (null? kvs) '()\n    (cons (format \"  ~a: ~a;\" (keyword->string (first kvs)) (nth kvs 1))\n          (pairs->decls (drop 2 kvs)))))\n\n(define (css-rule sel . props)\n  (format \"~a {\\n~a\\n}\" sel (string/join (pairs->decls props) \"\\n\")))\n\n(define style\n  (string/join (list\n    (css-rule \"body\" :margin \"0\" :font-family \"sans-serif\")\n    (css-rule \".card\" :border \"1px solid #ccc\" :padding \"1rem\"))\n    \"\\n\\n\"))\n\n(println style)\n\n(println \"\\n=== Full Page ===\\n\")\n\n(println (string-append \"<!DOCTYPE html>\\n\"\n  (html (head (title \"Sema DSL\")) (body (div {:class \"card\"} (h1 \"Hello\") (ul \"HTML\" \"CSS\" \"DSL\"))))))\n" },
    { id: "patterns/functional-patterns.sema", name: "functional-patterns.sema", code: ";; Functional programming patterns and idioms\n\n;; === Currying ===\n(define (curry2 f) (fn (a) (fn (b) (f a b))))\n(define add (curry2 +))\n(define add5 (add 5))\n(define double ((curry2 *) 2))\n(define triple ((curry2 *) 3))\n(println (format \"add5(3) = ~a, double(7) = ~a, triple(7) = ~a\"\n  (add5 3) (double 7) (triple 7)))\n\n;; === Pipeline ===\n(define (pipe . fns)\n  (foldl (fn (acc f) (fn (x) (f (acc x)))) (fn (x) x) fns))\n\n(define process\n  (pipe (fn (x) (* x 2)) (fn (x) (+ x 10)) (fn (x) (* x x))))\n(println (format \"pipe(double, +10, square)(5) = ~a\" (process 5)))\n\n;; === Option/Maybe ===\n(define (maybe-map f val) (if (nil? val) nil (f val)))\n(define (maybe-or val default) (if (nil? val) default val))\n\n(define config {:db {:host \"localhost\" :port 5432} :cache nil})\n(println (format \"\\ndb host: ~a\"\n  (maybe-or (maybe-map (fn (db) (get db :host)) (get config :db)) \"unknown\")))\n(println (format \"cache host: ~a\"\n  (maybe-or (maybe-map (fn (c) (get c :host)) (get config :cache)) \"not configured\")))\n\n;; === Error handling ===\n(define (safe-divide a b) (try (/ a b) (catch e nil)))\n(define (try-parse s) (try {:ok (int s)} (catch e {:error (:message e)})))\n(println (format \"\\n10/3 = ~a, 10/0 = ~a\" (safe-divide 10 3) (safe-divide 10 0)))\n(println (format \"parse \\\"99\\\": ~a\" (try-parse \"99\")))\n(println (format \"parse \\\"nope\\\": ~a\" (try-parse \"nope\")))\n\n;; === Binary Search Tree ===\n(define (make-tree val left right) (list val left right))\n(define (tree-val t) (first t))\n(define (tree-left t) (nth t 1))\n(define (tree-right t) (nth t 2))\n\n(define (tree-insert tree val)\n  (if (nil? tree) (make-tree val nil nil)\n    (cond\n      ((< val (tree-val tree))\n       (make-tree (tree-val tree) (tree-insert (tree-left tree) val) (tree-right tree)))\n      ((> val (tree-val tree))\n       (make-tree (tree-val tree) (tree-left tree) (tree-insert (tree-right tree) val)))\n      (else tree))))\n\n(define (tree-inorder tree)\n  (if (nil? tree) '()\n    (append (tree-inorder (tree-left tree))\n            (list (tree-val tree))\n            (tree-inorder (tree-right tree)))))\n\n(define bst (foldl tree-insert nil (list 5 3 7 1 4 6 8 2)))\n(println (format \"\\nBST inorder: ~a\" (tree-inorder bst)))\n\n;; === Collatz ===\n(define (collatz n)\n  (let loop ((x n) (steps 0))\n    (cond ((= x 1) steps)\n          ((even? x) (loop (/ x 2) (+ steps 1)))\n          (else (loop (+ (* 3 x) 1) (+ steps 1))))))\n\n(println \"\\nCollatz sequence lengths:\")\n(for-each (fn (n)\n  (println (format \"  ~a â†’ ~a steps\" (string/pad-left (str n) 4) (collatz n))))\n  (list 1 7 27 97 871 6171))\n" },
    { id: "patterns/interpreter.sema", name: "interpreter.sema", code: ";; A mini-lisp interpreter written in Sema\n\n(println \"=== Mini-Lisp Interpreter ===\\n\")\n\n;; AST constructors\n(define (make-num n)        (hash-map :type :number :value n))\n(define (make-var name)     (hash-map :type :var :name name))\n(define (make-binop op l r) (hash-map :type :binop :op op :left l :right r))\n(define (make-if c t f)     (hash-map :type :if :cond c :then t :else f))\n(define (make-let name val body)\n  (hash-map :type :let :name name :val val :body body))\n(define (make-lam param body)\n  (hash-map :type :lambda :param param :body body))\n(define (make-call fn arg)\n  (hash-map :type :call :fn fn :arg arg))\n\n;; Evaluator\n(define (eval-ast node env)\n  (let ((tag (get node :type)))\n    (cond\n      ((eq? tag :number) (get node :value))\n      ((eq? tag :var)\n       (if (contains? env (get node :name))\n         (get env (get node :name))\n         (throw (format \"Unbound: ~a\" (get node :name)))))\n      ((eq? tag :binop)\n       (let ((op (get node :op))\n             (lv (eval-ast (get node :left) env))\n             (rv (eval-ast (get node :right) env)))\n         (cond ((eq? op :+) (+ lv rv)) ((eq? op :-) (- lv rv))\n               ((eq? op :*) (* lv rv)) ((eq? op :/) (/ lv rv))\n               ((eq? op :>) (> lv rv)) ((eq? op :=) (= lv rv)))))\n      ((eq? tag :if)\n       (if (eval-ast (get node :cond) env)\n         (eval-ast (get node :then) env)\n         (eval-ast (get node :else) env)))\n      ((eq? tag :let)\n       (eval-ast (get node :body)\n         (assoc env (get node :name) (eval-ast (get node :val) env))))\n      ((eq? tag :lambda)\n       (hash-map :type :closure :param (get node :param) :body (get node :body) :env env))\n      ((eq? tag :call)\n       (let ((cl (eval-ast (get node :fn) env))\n             (av (eval-ast (get node :arg) env)))\n         (eval-ast (get cl :body) (assoc (get cl :env) (get cl :param) av)))))))\n\n(define E (hash-map))\n(define (run label ast)\n  (println (format \"  ~a => ~a\" label (eval-ast ast E))))\n\n(println \"--- Arithmetic ---\")\n(run \"(+ (* 3 4) (- 10 5))\"\n  (make-binop :+ (make-binop :* (make-num 3) (make-num 4))\n                 (make-binop :- (make-num 10) (make-num 5))))\n\n(println \"\\n--- Let & If ---\")\n(run \"(let x 7 (if (= x 7) 100 200))\"\n  (make-let :x (make-num 7)\n    (make-if (make-binop := (make-var :x) (make-num 7)) (make-num 100) (make-num 200))))\n\n(println \"\\n--- Lambda ---\")\n(run \"((fn n (+ n 1)) 41)\"\n  (make-call (make-lam :n (make-binop :+ (make-var :n) (make-num 1))) (make-num 41)))\n\n(run \"(let double (fn x (* x 2)) (double 21))\"\n  (make-let :double (make-lam :x (make-binop :* (make-var :x) (make-num 2)))\n    (make-call (make-var :double) (make-num 21))))\n\n(println \"\\nAll passed!\")\n" },
    { id: "patterns/macros.sema", name: "macros.sema", code: ";; Define a simple macro\n(defmacro unless (condition . body)\n  `(if (not ,condition) (begin ,@body)))\n\n(unless (= 1 2)\n  (println \"Math still works!\"))\n\n;; A \"when-let\" macro\n(defmacro when-let (binding . body)\n  `(let ((,(car binding) ,(cadr binding)))\n     (when ,(car binding) ,@body)))\n\n(when-let (x (get {:name \"Sema\"} :name))\n  (println \"Found:\" x))\n\n;; Pipeline with let\n(let ((data [3 1 4 1 5 9 2 6]))\n  (filter (fn (x) (> x 4))\n    (map (fn (x) (* x x))\n      (sort data <))))\n" },
    { id: "patterns/meta-eval.sema", name: "meta-eval.sema", code: ";; meta-eval.sema â€” A Lisp interpreter written in Sema\n;;\n;; A complete lexer, parser, and evaluator for a minimal Lisp,\n;; implemented entirely in Sema. Supports: numbers, strings, symbols,\n;; booleans, nil, quote, if, define, lambda, and a handful of builtins.\n;;\n;; This is the classic \"meta-circular evaluator\" â€” a language interpreting\n;; a subset of itself â€” the oldest rite of passage in Lisp.\n\n;; ============================================================\n;; 1. LEXER â€” tokenize a source string into a flat token list\n;; ============================================================\n\n;; Each token is a map: {:type <keyword> :value <val>}\n;; Token types: :lparen :rparen :quote :number :string :symbol :bool :nil\n\n(define (tokenize src)\n  (let ((len (string-length src)))\n    (let loop ((pos 0) (tokens '()))\n      (if (>= pos len)\n        (reverse tokens)\n        (let ((ch (string-ref src pos)))\n          (cond\n            ;; Skip whitespace\n            ((char-whitespace? ch)\n             (loop (+ pos 1) tokens))\n\n            ;; Skip line comments\n            ((char=? ch #\\;)\n             (let skip ((p (+ pos 1)))\n               (if (or (>= p len) (char=? (string-ref src p) #\\newline))\n                 (loop (+ p 1) tokens)\n                 (skip (+ p 1)))))\n\n            ;; Parentheses\n            ((char=? ch #\\()\n             (loop (+ pos 1) (cons {:type :lparen} tokens)))\n            ((char=? ch #\\))\n             (loop (+ pos 1) (cons {:type :rparen} tokens)))\n\n            ;; Quote shorthand\n            ((char=? ch #\\')\n             (loop (+ pos 1) (cons {:type :quote} tokens)))\n\n            ;; String literals\n            ((char=? ch #\\\")\n             (let scan ((p (+ pos 1)) (chars '()))\n               (cond\n                 ((>= p len)\n                  (error \"unterminated string literal\"))\n                 ((char=? (string-ref src p) #\\\\)\n                  (if (>= (+ p 1) len)\n                    (error \"unterminated escape in string\")\n                    (let ((esc (string-ref src (+ p 1))))\n                      (scan (+ p 2)\n                            (cons (cond ((char=? esc #\\n) #\\newline)\n                                        ((char=? esc #\\t) #\\tab)\n                                        ((char=? esc #\\\\) #\\\\)\n                                        ((char=? esc #\\\") #\\\")\n                                        (else esc))\n                                  chars)))))\n                 ((char=? (string-ref src p) #\\\")\n                  (loop (+ p 1)\n                        (cons {:type :string :value (list->string (reverse chars))}\n                              tokens)))\n                 (else\n                  (scan (+ p 1) (cons (string-ref src p) chars))))))\n\n            ;; Numbers (including negative: -N where N starts with digit)\n            ((or (char-numeric? ch)\n                 (and (char=? ch #\\-)\n                      (< (+ pos 1) len)\n                      (char-numeric? (string-ref src (+ pos 1)))))\n             (let scan ((p (if (char=? ch #\\-) (+ pos 1) pos))\n                        (has-dot #f))\n               (cond\n                 ((and (< p len) (char-numeric? (string-ref src p)))\n                  (scan (+ p 1) has-dot))\n                 ((and (< p len) (char=? (string-ref src p) #\\.) (not has-dot))\n                  (scan (+ p 1) #t))\n                 (else\n                  (let ((numstr (substring src pos p)))\n                    (loop p (cons {:type :number\n                                   :value (string->number numstr)}\n                                  tokens)))))))\n\n            ;; Booleans: #t #f\n            ((char=? ch #\\#)\n             (if (< (+ pos 1) len)\n               (let ((next (string-ref src (+ pos 1))))\n                 (cond\n                   ((char=? next #\\t)\n                    (loop (+ pos 2) (cons {:type :bool :value #t} tokens)))\n                   ((char=? next #\\f)\n                    (loop (+ pos 2) (cons {:type :bool :value #f} tokens)))\n                   (else (error (format \"unexpected #~a\" (char->string next))))))\n               (error \"unexpected # at end of input\")))\n\n            ;; Symbols â€” anything else that's not a delimiter\n            (else\n             (let scan ((p pos))\n               (if (and (< p len)\n                        (let ((c (string-ref src p)))\n                          (not (or (char-whitespace? c)\n                                   (char=? c #\\()\n                                   (char=? c #\\))\n                                   (char=? c #\\\")\n                                   (char=? c #\\;)))))\n                 (scan (+ p 1))\n                 (let ((sym (substring src pos p)))\n                   (loop p\n                         (cons (cond\n                                 ((equal? sym \"nil\") {:type :nil})\n                                 (else {:type :symbol :value sym}))\n                               tokens))))))))))))\n\n;; ============================================================\n;; 2. PARSER â€” recursive descent from token list to AST\n;; ============================================================\n\n;; Returns {:expr <ast> :rest <remaining-tokens>}\n;; AST representation:\n;;   numbers  â†’ Sema numbers\n;;   strings  â†’ Sema strings\n;;   bools    â†’ Sema booleans\n;;   nil      â†’ the symbol :nil-value (to distinguish from Sema nil)\n;;   symbols  â†’ {:ast :symbol :name \"foo\"}\n;;   lists    â†’ {:ast :list :items (<ast>...)}\n\n;; Sentinel for the interpreted nil (distinct from Sema's nil)\n(define NIL :__meta-nil__)\n\n(define (meta-nil? v) (equal? v NIL))\n\n(define (parse-expr tokens)\n  (when (null? tokens)\n    (error \"unexpected end of input\"))\n  (let ((tok (car tokens))\n        (rest (cdr tokens)))\n    (cond\n      ;; Quote: 'x â†’ (quote x)\n      ((equal? (get tok :type) :quote)\n       (let ((inner (parse-expr rest)))\n         {:expr {:ast :list\n                 :items (list {:ast :symbol :name \"quote\"}\n                              (get inner :expr))}\n          :rest (get inner :rest)}))\n\n      ;; Open paren: parse a list\n      ((equal? (get tok :type) :lparen)\n       (let loop ((toks rest) (items '()))\n         (cond\n           ((null? toks)\n            (error \"unexpected end of input â€” missing )\"))\n           ((equal? (get (car toks) :type) :rparen)\n            {:expr {:ast :list :items (reverse items)}\n             :rest (cdr toks)})\n           (else\n            (let ((parsed (parse-expr toks)))\n              (loop (get parsed :rest)\n                    (cons (get parsed :expr) items)))))))\n\n      ;; Atoms\n      ((equal? (get tok :type) :number) {:expr (get tok :value) :rest rest})\n      ((equal? (get tok :type) :string) {:expr (get tok :value) :rest rest})\n      ((equal? (get tok :type) :bool)   {:expr (get tok :value) :rest rest})\n      ((equal? (get tok :type) :nil)    {:expr NIL :rest rest})\n      ((equal? (get tok :type) :symbol) {:expr {:ast :symbol :name (get tok :value)}\n                                         :rest rest})\n\n      (else (error (format \"unexpected token: ~a\" tok))))))\n\n;; Parse all expressions from a token list\n(define (parse-all tokens)\n  (let loop ((toks tokens) (exprs '()))\n    (if (null? toks)\n      (reverse exprs)\n      (let ((result (parse-expr toks)))\n        (loop (get result :rest) (cons (get result :expr) exprs))))))\n\n;; Convenience: string â†’ AST list\n(define (parse-source src)\n  (parse-all (tokenize src)))\n\n;; ============================================================\n;; 3. ENVIRONMENT â€” mutable closure-based frames\n;; ============================================================\n;;\n;; Each env is a closure (message-passing object) that responds to:\n;;   (env :lookup name)     â†’ value or error\n;;   (env :define name val) â†’ mutates bindings in place via set!\n;;   (env :set! name val)   â†’ update existing binding (walks parent chain)\n\n(define (make-env parent)\n  (define bindings {})\n  (fn (msg . args)\n    (cond\n      ((equal? msg :lookup)\n       (let ((name (car args)))\n         (let ((key (string->keyword name)))\n           (if (contains? bindings key)\n             (get bindings key)\n             (if (nil? parent)\n               (error (format \"unbound variable: ~a\" name))\n               (parent :lookup name))))))\n\n      ((equal? msg :define)\n       (let ((name (car args))\n             (value (nth args 1)))\n         (set! bindings (assoc bindings (string->keyword name) value))\n         value))\n\n      ((equal? msg :set!)\n       (let ((name (car args))\n             (value (nth args 1)))\n         (let ((key (string->keyword name)))\n           (if (contains? bindings key)\n             (begin\n               (set! bindings (assoc bindings key value))\n               value)\n             (if (nil? parent)\n               (error (format \"set!: unbound variable: ~a\" name))\n               (parent :set! name value))))))\n\n      (else (error (format \"unknown env message: ~a\" msg))))))\n\n;; ============================================================\n;; 4. EVALUATOR â€” eval / apply\n;; ============================================================\n\n;; A closure is: {:type :closure :params (...) :body <ast> :env <env-fn>}\n\n;; Helper: check if an AST node is a symbol with a given name\n(define (sym-named? node name)\n  (and (map? node)\n       (equal? (get node :ast) :symbol)\n       (equal? (get node :name) name)))\n\n;; Helper: extract param names from AST param list\n;; NOTE: We avoid stdlib map/filter/for-each in the evaluator because\n;; the stdlib HOFs use a mini-evaluator that doesn't preserve closures\n;; over variables like our mutable env. Use manual loops instead.\n(define (extract-param-names param-items)\n  (let loop ((items param-items) (result '()))\n    (if (null? items)\n      (reverse result)\n      (loop (cdr items) (cons (get (car items) :name) result)))))\n\n;; Parse parameter list, handling rest params: (a b . rest)\n;; Returns {:params (\"a\" \"b\") :rest \"rest\"} or {:params (\"a\" \"b\") :rest nil}\n(define (parse-params param-items)\n  (let loop ((items param-items) (params '()))\n    (cond\n      ((null? items)\n       {:params (reverse params) :rest nil})\n      ;; Check for dot: (a b . rest)\n      ((and (map? (car items))\n            (equal? (get (car items) :ast) :symbol)\n            (equal? (get (car items) :name) \".\"))\n       {:params (reverse params)\n        :rest (get (car (cdr items)) :name)})\n      (else\n       (loop (cdr items)\n             (cons (get (car items) :name) params))))))\n\n;; Helper: evaluate a list of expressions, returning list of values\n(define (eval-list exprs env)\n  (let loop ((remaining exprs) (result '()))\n    (if (null? remaining)\n      (reverse result)\n      (loop (cdr remaining)\n            (cons (meta-eval (car remaining) env) result)))))\n\n(define (meta-eval expr env)\n  (cond\n    ;; Self-evaluating: numbers, strings, booleans\n    ((number? expr) expr)\n    ((string? expr) expr)\n    ((boolean? expr) expr)\n\n    ;; Our nil sentinel\n    ((meta-nil? expr) '())\n\n    ;; Symbol lookup\n    ((and (map? expr) (equal? (get expr :ast) :symbol))\n     (env :lookup (get expr :name)))\n\n    ;; List forms (special forms + application)\n    ((and (map? expr) (equal? (get expr :ast) :list))\n     (let ((items (get expr :items)))\n       (if (null? items)\n         '()  ;; empty list evaluates to empty list\n         (let ((head (car items))\n               (args (cdr items)))\n           (cond\n             ;; (quote <datum>)\n             ((sym-named? head \"quote\")\n              (if (null? args)\n                (error \"quote requires an argument\")\n                (ast->datum (car args))))\n\n             ;; (if <test> <then> <else?>)\n             ((sym-named? head \"if\")\n              (let ((test-val (meta-eval (car args) env)))\n                (if (or (equal? test-val #f) (null? test-val))\n                  (if (>= (length args) 3)\n                    (meta-eval (nth args 2) env)\n                    '())\n                  (meta-eval (nth args 1) env))))\n\n             ;; (define <name> <expr>) or (define (<name> <params>...) <body>)\n             ((sym-named? head \"define\")\n              (let ((target (car args)))\n                (if (and (map? target) (equal? (get target :ast) :list))\n                  ;; Function shorthand: (define (f x y) body...)\n                  (let ((fname (get (car (get target :items)) :name))\n                        (parsed (parse-params (cdr (get target :items))))\n                        (body-exprs (cdr args))\n                        (body (if (null? (cdr (cdr args)))\n                                (nth args 1)\n                                {:ast :list :items (cons {:ast :symbol :name \"begin\"}\n                                                         (cdr args))})))\n                    (let ((closure {:type :closure\n                                    :params (get parsed :params)\n                                    :rest-param (get parsed :rest)\n                                    :body body\n                                    :env env}))\n                      (env :define fname closure)\n                      closure))\n                  ;; Simple: (define name expr)\n                  (let ((name (get target :name))\n                        (val (meta-eval (nth args 1) env)))\n                    (env :define name val)\n                    val))))\n\n             ;; (set! <name> <expr>)\n             ((sym-named? head \"set!\")\n              (let ((name (get (car args) :name))\n                    (val (meta-eval (nth args 1) env)))\n                (env :set! name val)\n                val))\n\n             ;; (lambda (params...) body...) or (fn (params...) body...)\n             ;; Supports rest params: (lambda (a b . rest) body)\n             ;; Supports multi-expression body (implicit begin)\n             ((or (sym-named? head \"lambda\") (sym-named? head \"fn\"))\n              (let ((raw-params (get (car args) :items))\n                    (body-exprs (cdr args)))\n                (let ((parsed (parse-params raw-params))\n                      (body (if (null? (cdr body-exprs))\n                              (car body-exprs)\n                              {:ast :list :items (cons {:ast :symbol :name \"begin\"}\n                                                       body-exprs)})))\n                  {:type :closure\n                   :params (get parsed :params)\n                   :rest-param (get parsed :rest)\n                   :body body\n                   :env env})))\n\n             ;; (begin <expr>...)\n             ((sym-named? head \"begin\")\n              (let loop ((exprs args) (result '()))\n                (if (null? exprs)\n                  result\n                  (loop (cdr exprs) (meta-eval (car exprs) env)))))\n\n             ;; (cond (test expr)... (else expr))\n             ((sym-named? head \"cond\")\n              (let loop ((clauses args))\n                (if (null? clauses)\n                  '()\n                  (let ((clause (get (car clauses) :items)))\n                    (let ((test (car clause)))\n                      (if (sym-named? test \"else\")\n                        (meta-eval (nth clause 1) env)\n                        (let ((test-val (meta-eval test env)))\n                          (if (and (not (equal? test-val #f))\n                                   (not (null? test-val)))\n                            (meta-eval (nth clause 1) env)\n                            (loop (cdr clauses))))))))))\n\n             ;; (let ((name val)...) body) or (let name ((name val)...) body)\n             ((sym-named? head \"let\")\n              (let ((first-arg (car args)))\n                (if (and (map? first-arg) (equal? (get first-arg :ast) :symbol))\n                  ;; Named let: (let loop ((i 0) ...) body)\n                  (let ((loop-name (get first-arg :name))\n                        (binding-list (get (nth args 1) :items))\n                        (body (nth args 2)))\n                    (let ((let-env (make-env env)))\n                      ;; Extract param names and initial values\n                      (let extract ((bs binding-list) (pnames '()) (inits '()))\n                        (if (null? bs)\n                          (let ((params (reverse pnames))\n                                (init-vals (reverse inits)))\n                            ;; Define the loop function\n                            (let-env :define loop-name\n                              {:type :closure :params params :rest-param nil\n                               :body body :env let-env})\n                            ;; Call it with initial values\n                            (meta-apply (let-env :lookup loop-name) init-vals))\n                          (let ((pair (get (car bs) :items)))\n                            (extract (cdr bs)\n                                     (cons (get (car pair) :name) pnames)\n                                     (cons (meta-eval (nth pair 1) env) inits)))))))\n                  ;; Regular let: (let ((x 1) (y 2)) body)\n                  (let ((binding-list (get first-arg :items))\n                        (body (nth args 1)))\n                    (let ((let-env (make-env env)))\n                      (let bind-loop ((bs binding-list))\n                        (when (not (null? bs))\n                          (let ((pair (get (car bs) :items)))\n                            (let-env :define\n                              (get (car pair) :name)\n                              (meta-eval (nth pair 1) env)))\n                          (bind-loop (cdr bs))))\n                      (meta-eval body let-env))))))\n\n             ;; (and <expr>...) â€” variadic, short-circuit\n             ((sym-named? head \"and\")\n              (let and-loop ((remaining args))\n                (if (null? remaining)\n                  #t\n                  (let ((val (meta-eval (car remaining) env)))\n                    (if (or (equal? val #f) (null? val))\n                      #f\n                      (if (null? (cdr remaining))\n                        val\n                        (and-loop (cdr remaining))))))))\n\n             ;; (or <expr>...) â€” variadic, short-circuit\n             ((sym-named? head \"or\")\n              (let or-loop ((remaining args))\n                (if (null? remaining)\n                  #f\n                  (let ((val (meta-eval (car remaining) env)))\n                    (if (and (not (equal? val #f)) (not (null? val)))\n                      val\n                      (or-loop (cdr remaining)))))))\n\n             ;; Function application\n             (else\n              (let ((fn-val (meta-eval head env))\n                    (arg-vals (eval-list args env)))\n                (meta-apply fn-val arg-vals))))))))\n\n    (else (error (format \"cannot evaluate: ~a\" expr)))))\n\n;; Convert AST back to a Sema datum (for quote)\n(define (ast->datum ast)\n  (cond\n    ((number? ast) ast)\n    ((string? ast) ast)\n    ((boolean? ast) ast)\n    ((meta-nil? ast) '())\n    ((and (map? ast) (equal? (get ast :ast) :symbol))\n     (string->symbol (get ast :name)))\n    ((and (map? ast) (equal? (get ast :ast) :list))\n     (map ast->datum (get ast :items)))\n    (else ast)))\n\n;; Apply a function to arguments\n(define (meta-apply fn-val args)\n  (cond\n    ;; Native builtin\n    ((and (map? fn-val) (equal? (get fn-val :type) :builtin))\n     ((get fn-val :proc) args))\n\n    ;; User-defined closure\n    ((and (map? fn-val) (equal? (get fn-val :type) :closure))\n     (let ((params (get fn-val :params))\n           (rest-param (get fn-val :rest-param))\n           (body (get fn-val :body))\n           (closure-env (get fn-val :env)))\n       ;; Create a child env and bind parameters\n       (let ((call-env (make-env closure-env)))\n         ;; Bind regular params\n         (let bind-loop ((ps params) (as args))\n           (when (not (null? ps))\n             (call-env :define (car ps) (car as))\n             (bind-loop (cdr ps) (cdr as))))\n         ;; Bind rest param if present\n         (when (and rest-param (not (null? rest-param)))\n           (let ((rest-args (let drop-loop ((n (length params)) (as args))\n                              (if (= n 0) as (drop-loop (- n 1) (cdr as))))))\n             (call-env :define rest-param rest-args)))\n         (meta-eval body call-env))))\n\n    (else (error (format \"not a function: ~a\" fn-val)))))\n\n;; ============================================================\n;; 5. BUILTINS â€” primitive operations\n;; ============================================================\n\n(define (make-builtin proc)\n  {:type :builtin :proc proc})\n\n(define (setup-builtins)\n  (let ((env (make-env nil)))\n    ;; Arithmetic\n    (env :define \"+\" (make-builtin (fn (args) (foldl + 0 args))))\n    (env :define \"-\" (make-builtin\n      (fn (args)\n        (if (= (length args) 1)\n          (- 0 (car args))\n          (foldl - (car args) (cdr args))))))\n    (env :define \"*\" (make-builtin (fn (args) (foldl * 1 args))))\n    (env :define \"/\" (make-builtin\n      (fn (args)\n        (if (= (length args) 1)\n          (/ 1 (car args))\n          (foldl / (car args) (cdr args))))))\n    (env :define \"remainder\" (make-builtin\n      (fn (args) (- (car args) (* (/ (car args) (nth args 1)) (nth args 1))))))\n\n    ;; Comparison\n    (env :define \"=\" (make-builtin\n      (fn (args) (equal? (car args) (nth args 1)))))\n    (env :define \"<\" (make-builtin\n      (fn (args) (< (car args) (nth args 1)))))\n    (env :define \">\" (make-builtin\n      (fn (args) (> (car args) (nth args 1)))))\n    (env :define \"<=\" (make-builtin\n      (fn (args) (<= (car args) (nth args 1)))))\n    (env :define \">=\" (make-builtin\n      (fn (args) (>= (car args) (nth args 1)))))\n\n    ;; List operations\n    (env :define \"cons\" (make-builtin\n      (fn (args) (cons (car args) (nth args 1)))))\n    (env :define \"car\" (make-builtin (fn (args) (car (car args)))))\n    (env :define \"cdr\" (make-builtin (fn (args) (cdr (car args)))))\n    (env :define \"list\" (make-builtin (fn (args) args)))\n    (env :define \"null?\" (make-builtin (fn (args) (null? (car args)))))\n    (env :define \"pair?\" (make-builtin (fn (args) (pair? (car args)))))\n    (env :define \"length\" (make-builtin (fn (args) (length (car args)))))\n    (env :define \"append\" (make-builtin\n      (fn (args) (append (car args) (nth args 1)))))\n\n    ;; Type predicates\n    (env :define \"number?\" (make-builtin (fn (args) (number? (car args)))))\n    (env :define \"string?\" (make-builtin (fn (args) (string? (car args)))))\n    (env :define \"boolean?\" (make-builtin (fn (args) (boolean? (car args)))))\n    (env :define \"not\" (make-builtin (fn (args) (not (car args)))))\n    (env :define \"equal?\" (make-builtin\n      (fn (args) (equal? (car args) (nth args 1)))))\n\n    ;; I/O\n    (env :define \"display\" (make-builtin (fn (args) (display (car args)))))\n    (env :define \"newline\" (make-builtin (fn (args) (println))))\n\n    ;; String operations\n    (env :define \"string-append\" (make-builtin\n      (fn (args) (apply string-append args))))\n    (env :define \"string-length\" (make-builtin\n      (fn (args) (string-length (car args)))))\n    (env :define \"number->string\" (make-builtin\n      (fn (args) (number->string (car args)))))\n\n    env))\n\n;; ============================================================\n;; 6. RUN â€” parse and evaluate a program string\n;; ============================================================\n\n(define (run-program src)\n  (let ((exprs (parse-source src))\n        (env (setup-builtins)))\n    (let loop ((remaining exprs) (result '()))\n      (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (meta-eval (car remaining) env))))))\n\n;; ============================================================\n;; 7. DEMO â€” run example programs\n;; ============================================================\n\n(println \"=== Meta-Eval: A Lisp Interpreter in Sema ===\")\n(println)\n\n;; --- Test 1: Arithmetic ---\n(println \"--- Arithmetic ---\")\n(println (format \"  (+ 1 2 3)       = ~a\" (run-program \"(+ 1 2 3)\")))\n(println (format \"  (* 6 7)         = ~a\" (run-program \"(* 6 7)\")))\n(println (format \"  (- 10 3)        = ~a\" (run-program \"(- 10 3)\")))\n(println (format \"  (/ 100 4)       = ~a\" (run-program \"(/ 100 4)\")))\n(println (format \"  (+ 1 (* 2 3))   = ~a\" (run-program \"(+ 1 (* 2 3))\")))\n\n;; --- Test 2: Booleans and conditionals ---\n(println)\n(println \"--- Conditionals ---\")\n(println (format \"  (if #t 1 2)     = ~a\" (run-program \"(if #t 1 2)\")))\n(println (format \"  (if #f 1 2)     = ~a\" (run-program \"(if #f 1 2)\")))\n(println (format \"  (if (> 5 3) \\\"yes\\\" \\\"no\\\") = ~a\"\n  (run-program \"(if (> 5 3) \\\"yes\\\" \\\"no\\\")\")))\n\n;; --- Test 3: Define and use variables ---\n(println)\n(println \"--- Variables ---\")\n(println (format \"  (define x 42) x = ~a\" (run-program \"(define x 42) x\")))\n(println (format \"  pi * 2         = ~a\"\n  (run-program \"(define pi 3.14159) (* pi 2)\")))\n\n;; --- Test 4: Lambda ---\n(println)\n(println \"--- Lambda ---\")\n(println (format \"  ((fn (x) (* x x)) 5) = ~a\"\n  (run-program \"((lambda (x) (* x x)) 5)\")))\n(println (format \"  (define square ...) (square 7) = ~a\"\n  (run-program \"(define (square x) (* x x)) (square 7)\")))\n\n;; --- Test 5: Recursion ---\n(println)\n(println \"--- Recursion ---\")\n(println (format \"  factorial(10) = ~a\"\n  (run-program \"\n    (define (factorial n)\n      (if (<= n 1) 1 (* n (factorial (- n 1)))))\n    (factorial 10)\")))\n\n(println (format \"  fibonacci(10) = ~a\"\n  (run-program \"\n    (define (fib n)\n      (if (<= n 1) n (+ (fib (- n 1)) (fib (- n 2)))))\n    (fib 10)\")))\n\n;; --- Test 6: Higher-order functions ---\n(println)\n(println \"--- Higher-Order Functions ---\")\n(println (format \"  map square over (1 2 3 4 5) = ~a\"\n  (run-program \"\n    (define (square x) (* x x))\n    (define (my-map f lst)\n      (if (null? lst) '()\n        (cons (f (car lst)) (my-map f (cdr lst)))))\n    (my-map square (list 1 2 3 4 5))\")))\n\n;; --- Test 7: Closures ---\n(println)\n(println \"--- Closures ---\")\n(println (format \"  make-adder(5)(3) = ~a\"\n  (run-program \"\n    (define (make-adder n)\n      (lambda (x) (+ n x)))\n    (define add5 (make-adder 5))\n    (add5 3)\")))\n\n;; --- Test 8: List operations ---\n(println)\n(println \"--- Lists ---\")\n(println (format \"  (car '(1 2 3))  = ~a\" (run-program \"(car '(1 2 3))\")))\n(println (format \"  (cdr '(1 2 3))  = ~a\" (run-program \"(cdr '(1 2 3))\")))\n(println (format \"  (cons 0 '(1 2)) = ~a\" (run-program \"(cons 0 '(1 2))\")))\n\n;; --- Test 9: Cond ---\n(println)\n(println \"--- Cond ---\")\n(println (format \"  fizzbuzz(15) = ~a\"\n  (run-program \"\n    (define (fizzbuzz n)\n      (cond\n        ((= (remainder n 15) 0) \\\"FizzBuzz\\\")\n        ((= (remainder n 3) 0)  \\\"Fizz\\\")\n        ((= (remainder n 5) 0)  \\\"Buzz\\\")\n        (else (number->string n))))\n    (fizzbuzz 15)\")))\n\n;; --- Test 10: Let bindings ---\n(println)\n(println \"--- Let ---\")\n(println (format \"  (let ((x 2) (y 3)) (+ x y)) = ~a\"\n  (run-program \"(let ((x 2) (y 3)) (+ x y))\")))\n(println (format \"  nested let = ~a\"\n  (run-program \"\n    (let ((x 10))\n      (let ((y 20))\n        (+ x y)))\")))\n\n;; --- Test 11: A bigger program ---\n(println)\n(println \"--- Bigger Program: List Utilities ---\")\n(run-program \"\n  (define (my-map f lst)\n    (if (null? lst) '()\n      (cons (f (car lst)) (my-map f (cdr lst)))))\n\n  (define (my-filter pred lst)\n    (if (null? lst) '()\n      (if (pred (car lst))\n        (cons (car lst) (my-filter pred (cdr lst)))\n        (my-filter pred (cdr lst)))))\n\n  (define (my-foldl f acc lst)\n    (if (null? lst) acc\n      (my-foldl f (f acc (car lst)) (cdr lst))))\n\n  (define (my-reverse lst)\n    (my-foldl (lambda (acc x) (cons x acc)) '() lst))\n\n  (define nums (list 1 2 3 4 5 6 7 8 9 10))\n  (define squares (my-map (lambda (x) (* x x)) nums))\n  (define evens (my-filter (lambda (x) (= (remainder x 2) 0)) nums))\n  (define sum (my-foldl + 0 nums))\n\n  (display \\\"  squares: \\\") (display squares) (newline)\n  (display \\\"  evens:   \\\") (display evens) (newline)\n  (display \\\"  sum:     \\\") (display sum) (newline)\n  (display \\\"  reverse: \\\") (display (my-reverse (list 1 2 3 4 5))) (newline)\")\n\n;; --- Test 12: Mutual recursion via define ---\n(println)\n(println \"--- And/Or as Special Forms ---\")\n(println (format \"  (and #t #f)     = ~a\" (run-program \"(and #t #f)\")))\n(println (format \"  (and #t #t)     = ~a\" (run-program \"(and #t #t)\")))\n(println (format \"  (or #f #t)      = ~a\" (run-program \"(or #f #t)\")))\n(println (format \"  (or #f #f)      = ~a\" (run-program \"(or #f #f)\")))\n\n(println)\n(println \"=== All tests passed! ===\")\n" },
    { id: "patterns/multimethods.sema", name: "multimethods.sema", code: ";;; Type-dispatched polymorphism via maps\n\n(defmacro -> (val . forms)\n  (if (null? forms) val\n    (let ((form (car forms)) (rest (cdr forms)))\n      (if (list? form)\n        `(-> (,(car form) ,val ,@(cdr form)) ,@rest)\n        `(-> (,form ,val) ,@rest)))))\n\n(define (make-multi dispatch-fn) {:dispatch-fn dispatch-fn :methods {} :default nil})\n(define (add-method multi dispatch-val impl)\n  (assoc multi :methods (assoc (get multi :methods) dispatch-val impl)))\n(define (set-default-method multi impl) (assoc multi :default impl))\n\n(define (invoke multi . args)\n  (let* ((dispatch-val (apply (get multi :dispatch-fn) args))\n         (method (get (get multi :methods) dispatch-val)))\n    (if (nil? method)\n      (if (nil? (get multi :default))\n        (error (format \"No method for: ~a\" dispatch-val))\n        (apply (get multi :default) args))\n      (apply method args))))\n\n(println \"=== Multimethods ===\\n\")\n(println \"--- Shape area ---\")\n\n(define area\n  (-> (make-multi (fn (shape) (get shape :type)))\n      (add-method :circle (fn (s) (* pi (get s :radius) (get s :radius))))\n      (add-method :rect (fn (s) (* (get s :width) (get s :height))))\n      (add-method :triangle (fn (s) (* 0.5 (get s :base) (get s :height))))))\n\n(for-each\n  (fn (s) (println (format \"  ~a area = ~a\" (get s :type) (round (* 100 (invoke area s))))))\n  (list {:type :circle :radius 5}\n        {:type :rect :width 4 :height 6}\n        {:type :triangle :base 8 :height 3}))\n\n;; Open extension â€” add ellipse without modifying existing code\n(define area (add-method area :ellipse\n  (fn (s) (* pi (get s :a) (get s :b)))))\n(println (format \"  ~a area = ~a\" :ellipse\n  (round (* 100 (invoke area {:type :ellipse :a 3 :b 5})))))\n\n(println \"\\n--- Animal sounds ---\")\n(define speak\n  (-> (make-multi (fn (a) (get a :species)))\n      (add-method :dog (fn (a) (format \"~a says: Woof!\" (get a :name))))\n      (add-method :cat (fn (a) (format \"~a says: Meow!\" (get a :name))))\n      (add-method :duck (fn (a) (format \"~a says: Quack!\" (get a :name))))\n      (set-default-method (fn (a) (format \"~a says: ...\" (get a :name))))))\n\n(for-each\n  (fn (a) (println (format \"  ~a\" (invoke speak a))))\n  (list {:species :dog :name \"Rex\"} {:species :cat :name \"Whiskers\"}\n        {:species :duck :name \"Donald\"} {:species :fish :name \"Nemo\"}))\n" },
    { id: "patterns/quickcheck.sema", name: "quickcheck.sema", code: ";;; Property-based testing framework\n;;; Random inputs, test properties, shrink to minimal counterexamples\n\n(define qc-num-tests 100)\n\n;; Generators\n(define (gen/int lo hi) (fn () (math/random-int lo hi)))\n(define (gen/nat) (gen/int 0 1000))\n(define (gen/char) (fn () (char->string (integer->char (math/random-int 32 126)))))\n(define (gen/string-of max-len)\n  (fn () (let ((len (math/random-int 0 max-len)))\n    (string/join (map (fn (_) ((gen/char))) (range len)) \"\"))))\n(define (gen/list-of elem-gen max-len)\n  (fn () (let ((len (math/random-int 0 max-len)))\n    (map (fn (_) (elem-gen)) (range len)))))\n\n;; Shrinking\n(define (shrink-int n)\n  (if (= n 0) '()\n    (let ((half (if (> n 0) (floor (/ n 2)) (ceil (/ n 2)))))\n      (list 0 half))))\n\n(define (shrink-list lst)\n  (if (null? lst) '()\n    (cons '() (map (fn (i) (append (take i lst) (drop (+ i 1) lst)))\n                   (range (length lst))))))\n\n(define (find-minimal prop val shrinker)\n  (let loop ((current val) (fuel 50))\n    (if (= fuel 0) current\n      (let ((candidates (shrinker current)))\n        (let check ((cs candidates))\n          (if (null? cs) current\n            (if (not (prop (car cs)))\n              (loop (car cs) (- fuel 1))\n              (check (cdr cs)))))))))\n\n;; Test runner\n(define (check-property prop gen shrinker)\n  (let loop ((i 0))\n    (if (= i qc-num-tests)\n      {:status :pass :tests qc-num-tests}\n      (let ((val (gen)))\n        (if (prop val) (loop (+ i 1))\n          (let ((shrunk (if shrinker (find-minimal prop val shrinker) val)))\n            {:status :fail :counterexample val :shrunk shrunk :after-tests (+ i 1)}))))))\n\n(define (check-property-2 prop gen-a gen-b shrinker-a shrinker-b)\n  (let loop ((i 0))\n    (if (= i qc-num-tests)\n      {:status :pass :tests qc-num-tests}\n      (let ((a (gen-a)) (b (gen-b)))\n        (if (prop a b) (loop (+ i 1))\n          {:status :fail :counterexample (list a b) :after-tests (+ i 1)})))))\n\n(define (report name result)\n  (if (= (get result :status) :pass)\n    (println (format \"  PASS  ~a (~a tests)\" name (get result :tests)))\n    (begin\n      (println (format \"  FAIL  ~a (after ~a tests)\" name (get result :after-tests)))\n      (println (format \"        counterexample: ~a\" (get result :counterexample)))\n      (when (not (= (get result :counterexample) (get result :shrunk)))\n        (println (format \"        shrunk to:      ~a\" (get result :shrunk)))))))\n\n(println \"=== Property-Based Testing ===\\n\")\n(println \"--- Should pass ---\")\n\n(report \"add-commutative\"\n  (check-property-2 (fn (a b) (= (+ a b) (+ b a)))\n    (gen/int -1000 1000) (gen/int -1000 1000) nil nil))\n\n(report \"reverse-involution\"\n  (check-property (fn (lst) (equal? lst (reverse (reverse lst))))\n    (gen/list-of (gen/int 0 100) 20) shrink-list))\n\n(report \"sort-idempotent\"\n  (check-property (fn (lst) (equal? (sort lst) (sort (sort lst))))\n    (gen/list-of (gen/int -100 100) 20) shrink-list))\n\n(report \"abs-non-negative\"\n  (check-property (fn (n) (>= (abs n) 0))\n    (gen/int -10000 10000) shrink-int))\n\n(println \"\\n--- Should fail (testing shrinking) ---\")\n\n(report \"all-less-than-50\"\n  (check-property (fn (n) (< n 50)) (gen/int 0 100) shrink-int))\n\n(report \"sort-is-identity\"\n  (check-property (fn (lst) (equal? lst (sort lst)))\n    (gen/list-of (gen/int 0 100) 10) shrink-list))\n" },
    { id: "patterns/record-types.sema", name: "record-types.sema", code: ";; SRFI-9 Record Types: Points, Shapes & Linked Lists\n\n(println \"=== Record Types ===\\n\")\n\n;; --- Point ---\n(define-record-type Point\n  (make-point x y) point?\n  (x point-x) (y point-y))\n\n(define p1 (make-point 3 4))\n(define p2 (make-point 7 1))\n(println (format \"p1 = (~a, ~a)\" (point-x p1) (point-y p1)))\n(println (format \"p2 = (~a, ~a)\" (point-x p2) (point-y p2)))\n(println (format \"p1 is Point? ~a  42 is Point? ~a\" (point? p1) (point? 42)))\n\n(define (distance a b)\n  (sqrt (+ (expt (- (point-x b) (point-x a)) 2)\n           (expt (- (point-y b) (point-y a)) 2))))\n(println (format \"Distance: ~a\" (distance p1 p2)))\n\n;; --- Shapes ---\n(println \"\\n--- Shapes ---\")\n\n(define-record-type Circle\n  (make-circle center radius) circle?\n  (center circle-center) (radius circle-radius))\n\n(define-record-type Rect\n  (make-rect origin width height) rect?\n  (origin rect-origin) (width rect-width) (height rect-height))\n\n(define (area shape)\n  (cond ((circle? shape) (* pi (expt (circle-radius shape) 2)))\n        ((rect? shape) (* (rect-width shape) (rect-height shape)))))\n\n(define c1 (make-circle (make-point 0 0) 5))\n(define r1 (make-rect (make-point 1 2) 10 6))\n\n(for-each (fn (s)\n  (println (format \"  ~a  area=~a\"\n    (if (circle? s) (format \"Circle r=~a\" (circle-radius s))\n        (format \"Rect ~ax~a\" (rect-width s) (rect-height s)))\n    (round (* (area s) 100)))))\n  (list c1 r1))\n\n;; --- Linked List via Records ---\n(println \"\\n--- Linked List via Records ---\")\n\n(define-record-type Cell\n  (make-cell head tail) cell?\n  (head cell-head) (tail cell-tail))\n\n(define (cell-from-list items) (foldr make-cell nil items))\n(define (cell-to-list lst)\n  (if (null? lst) '() (cons (cell-head lst) (cell-to-list (cell-tail lst)))))\n(define (cell-map f lst)\n  (if (null? lst) nil (make-cell (f (cell-head lst)) (cell-map f (cell-tail lst)))))\n\n(define my-list (cell-from-list '(10 20 30 40 50)))\n(println (format \"\\n  As list: ~a\" (cell-to-list my-list)))\n(println (format \"  Doubled: ~a\" (cell-to-list (cell-map (fn (x) (* x 2)) my-list))))\n" },
    { id: "patterns/scheme-basics.sema", name: "scheme-basics.sema", code: ";; Standard Scheme features\n;; Car/cdr compositions, alists, do loops, characters, promises\n\n(println \"=== Car/Cdr Compositions ===\")\n(define nested '((1 2 3) (4 5 6) (7 8 9)))\n(println (format \"nested:  ~s\" nested))\n(println (format \"caar:    ~a\" (caar nested)))\n(println (format \"cadr:    ~s\" (cadr nested)))\n(println (format \"caddr:   ~s\" (caddr nested)))\n\n(println \"\\n=== Association Lists ===\")\n(define phonebook\n  '((\"Alice\" \"555-1234\") (\"Bob\" \"555-5678\") (\"Charlie\" \"555-9012\")))\n(define entry (assoc \"Bob\" phonebook))\n(println (format \"assoc \\\"Bob\\\": ~s\" entry))\n(println (format \"Bob's number: ~a\" (cadr entry)))\n\n(println \"\\n=== Do Loops ===\")\n(define sum\n  (do ((i 1 (+ i 1)) (acc 0 (+ acc i)))\n    ((> i 10) acc)))\n(println (format \"Sum 1..10: ~a\" sum))\n\n(define fact\n  (do ((n 10 (- n 1)) (acc 1 (* acc n)))\n    ((= n 0) acc)))\n(println (format \"10!: ~a\" fact))\n\n(println \"\\n=== Characters ===\")\n(println (format \"alphabetic? #\\\\A: ~a\" (char-alphabetic? #\\A)))\n(println (format \"numeric? #\\\\5: ~a\" (char-numeric? #\\5)))\n(println (format \"upcase #\\\\a: ~s\" (char-upcase #\\a)))\n(println (format \"string->list: ~s\" (string->list \"Hello\")))\n\n(println \"\\n=== Promises (delay/force) ===\")\n(define p (delay (begin (println \"  Computing...\") (* 6 7))))\n(println (format \"promise? p: ~a\" (promise? p)))\n(println \"Forcing p:\")\n(define result (force p))\n(println (format \"Result: ~a\" result))\n(println (format \"Forced? ~a\" (promise-forced? p)))\n\n;; Memoization\n(define counter 0)\n(define memo-p (delay (begin (set! counter (+ counter 1)) counter)))\n(println (format \"\\nFirst force:  ~a\" (force memo-p)))\n(println (format \"Second force: ~a (same â€” memoized)\" (force memo-p)))\n" },
    { id: "patterns/state-machine.sema", name: "state-machine.sema", code: ";; Finite state machines using maps\n\n(println \"=== Finite State Machines ===\\n\")\n\n;; --- Traffic Light ---\n(println \"--- Traffic Light ---\\n\")\n\n(define traffic-fsm\n  (hash-map \"red\" (hash-map \"next\" \"green\" \"dur\" 5)\n            \"green\" (hash-map \"next\" \"yellow\" \"dur\" 4)\n            \"yellow\" (hash-map \"next\" \"red\" \"dur\" 1)))\n\n(define traffic-labels\n  (hash-map \"red\" \"ðŸ”´ RED\" \"green\" \"ðŸŸ¢ GREEN\" \"yellow\" \"ðŸŸ¡ YELLOW\"))\n\n(define (run-traffic state steps)\n  (when (> steps 0)\n    (let ((info (get traffic-fsm state)))\n      (println (format \"  ~a  (~as)\" (get traffic-labels state) (get info \"dur\")))\n      (run-traffic (get info \"next\") (- steps 1)))))\n\n(run-traffic \"red\" 9)\n\n;; --- Vending Machine ---\n(println \"\\n--- Vending Machine ---\\n\")\n\n(define vending-fsm\n  (hash-map \"idle\" (hash-map \"coin\" \"selecting\" \"msg\" \"Waiting...\")\n            \"selecting\" (hash-map \"select\" \"dispensing\" \"cancel\" \"idle\" \"msg\" \"Choose item!\")\n            \"dispensing\" (hash-map \"done\" \"idle\" \"msg\" \"Dispensing...\")))\n\n(define (vend-step state event)\n  (let ((next (get (get vending-fsm state) event)))\n    (if (null? next)\n      (begin (println (format \"  âš  No '~a' in ~a\" event state)) state)\n      (begin (println (format \"  ~a --[~a]--> ~a: ~a\" state event next (get (get vending-fsm next) \"msg\"))) next))))\n\n(define (vend-run state events)\n  (if (null? events) (println (format \"  Final: ~a\" state))\n    (vend-run (vend-step state (car events)) (cdr events))))\n\n(println \"Buy item:\")\n(vend-run \"idle\" '(\"coin\" \"select\" \"done\"))\n(println \"\\nCancel:\")\n(vend-run \"idle\" '(\"coin\" \"cancel\"))\n\n;; --- Door FSM ---\n(println \"\\n--- Door ---\\n\")\n\n(define door-fsm\n  (hash-map \"locked\" (hash-map \"unlock\" \"closed\")\n            \"closed\" (hash-map \"open\" \"open\" \"lock\" \"locked\")\n            \"open\" (hash-map \"close\" \"closed\")))\n\n(define (fsm-run fsm state events)\n  (if (null? events) state\n    (let ((next (get (get fsm state) (car events))))\n      (println (format \"  ~a --[~a]--> ~a\" state (car events) next))\n      (fsm-run fsm next (cdr events)))))\n\n(println (format \"Final: ~a\"\n  (fsm-run door-fsm \"locked\" '(\"unlock\" \"open\" \"close\" \"lock\"))))\n" }
  ]},
  { category: "Visuals", files: [
    { id: "visuals/ascii-art.sema", name: "ascii-art.sema", code: ";; ASCII art generators and visualizations\n\n;; === 1. Sierpinski Triangle ===\n(println \"=== Sierpinski Triangle ===\\n\")\n\n(define sierpinski-rows 16)\n\n(define (pascal-next row)\n  (let loop ((i 0) (acc '()))\n    (if (> i (length row)) (reverse acc)\n      (let ((left (if (= i 0) 0 (nth row (- i 1))))\n            (right (if (= i (length row)) 0 (nth row i))))\n        (loop (+ i 1) (cons (+ left right) acc))))))\n\n(define (pascal-rows n)\n  (let loop ((i 1) (current '(1)) (acc (list '(1))))\n    (if (= i n) acc\n      (let ((next (pascal-next current)))\n        (loop (+ i 1) next (append acc (list next)))))))\n\n(for-each\n  (fn (row)\n    (display (string/repeat \" \" (- sierpinski-rows (length row))))\n    (for-each\n      (fn (val) (if (= 0 (mod val 2)) (display \"  \") (display \"* \")))\n      row)\n    (println \"\"))\n  (pascal-rows sierpinski-rows))\n\n;; === 2. Diamond ===\n(println \"\\n=== Diamond ===\\n\")\n\n(define diamond-size 9)\n(let ((half (/ (- diamond-size 1) 2)))\n  (let loop-top ((i 0))\n    (when (<= i half)\n      (display (string/repeat \" \" (- half i)))\n      (println (string/repeat \"*\" (+ 1 (* 2 i))))\n      (loop-top (+ i 1))))\n  (let loop-bot ((i (- half 1)))\n    (when (>= i 0)\n      (display (string/repeat \" \" (- half i)))\n      (println (string/repeat \"*\" (+ 1 (* 2 i))))\n      (loop-bot (- i 1)))))\n\n;; === 3. Sine Wave ===\n(println \"\\n=== Sine Wave ===\\n\")\n\n(define wave-cols 60)\n(define wave-rows 21)\n(define wave-mid (/ (- wave-rows 1) 2))\n\n(let loop-row ((row 0))\n  (when (< row wave-rows)\n    (let ((line\n            (let loop-col ((col 0) (acc \"\"))\n              (if (>= col wave-cols) acc\n                (let* ((x (* (/ col (- wave-cols 1.0)) (* 4.0 pi)))\n                       (y (sin x))\n                       (target-row (round (* (- 1.0 y) 0.5 (- wave-rows 1)))))\n                  (cond\n                    ((= row (round target-row))\n                     (loop-col (+ col 1) (string-append acc \"*\")))\n                    ((and (= row wave-mid) (= col 0))\n                     (loop-col (+ col 1) (string-append acc \"+\")))\n                    ((= row wave-mid)\n                     (loop-col (+ col 1) (string-append acc \"-\")))\n                    ((= col 0)\n                     (loop-col (+ col 1) (string-append acc \"|\")))\n                    (else\n                     (loop-col (+ col 1) (string-append acc \" \")))))))))\n      (println line))\n    (loop-row (+ row 1))))\n\n;; === 4. Bar Chart ===\n(println \"\\n=== Bar Chart ===\\n\")\n\n(define chart-data\n  (list (list \"Rust\" 85) (list \"Python\" 72) (list \"JavaScript\" 68)\n        (list \"Go\" 54) (list \"Sema\" 95) (list \"Haskell\" 42) (list \"C\" 61)))\n\n(define chart-max (foldl (fn (mx item) (if (> (nth item 1) mx) (nth item 1) mx)) 0 chart-data))\n(define max-label-len (foldl (fn (mx item) (if (> (string-length (nth item 0)) mx) (string-length (nth item 0)) mx)) 0 chart-data))\n\n(for-each\n  (fn (item)\n    (let* ((label (nth item 0)) (value (nth item 1))\n           (bar-len (round (* (/ value (+ chart-max 0.0)) 40))))\n      (println (format \"  ~a|~a ~a\"\n        (string/pad-right label (+ max-label-len 1))\n        (string/repeat \"â–ˆ\" bar-len) value))))\n  chart-data)\n" },
    { id: "visuals/brainfuck.sema", name: "brainfuck.sema", code: ";; A Brainfuck interpreter written in Sema\n\n(println \"=== Brainfuck Interpreter ===\\n\")\n\n(define (tape-get t p) (get t p 0))\n(define (tape-set t p v) (assoc t p v))\n\n(define (find-matching-bracket prog pos dir)\n  (let loop ((p (+ pos dir)) (depth 1))\n    (let ((ch (string-ref prog p)))\n      (cond\n        ((and (= ch #\\[) (= dir 1))  (loop (+ p dir) (+ depth 1)))\n        ((and (= ch #\\]) (= dir -1)) (loop (+ p dir) (+ depth 1)))\n        ((and (= ch #\\]) (= dir 1))\n         (if (= depth 1) p (loop (+ p dir) (- depth 1))))\n        ((and (= ch #\\[) (= dir -1))\n         (if (= depth 1) p (loop (+ p dir) (- depth 1))))\n        (else (loop (+ p dir) depth))))))\n\n(define (bf-run program)\n  (let loop ((ip 0) (tape (hash-map)) (ptr 0) (output \"\"))\n    (if (>= ip (string-length program)) output\n      (let ((ch (string-ref program ip)))\n        (cond\n          ((= ch #\\>) (loop (+ ip 1) tape (+ ptr 1) output))\n          ((= ch #\\<) (loop (+ ip 1) tape (- ptr 1) output))\n          ((= ch #\\+) (loop (+ ip 1) (tape-set tape ptr (mod (+ (tape-get tape ptr) 1) 256)) ptr output))\n          ((= ch #\\-) (loop (+ ip 1) (tape-set tape ptr (mod (+ (tape-get tape ptr) 255) 256)) ptr output))\n          ((= ch #\\.) (loop (+ ip 1) tape ptr (string-append output (char->string (integer->char (tape-get tape ptr))))))\n          ((= ch #\\[) (if (= (tape-get tape ptr) 0)\n            (loop (find-matching-bracket program ip 1) tape ptr output)\n            (loop (+ ip 1) tape ptr output)))\n          ((= ch #\\]) (if (not (= (tape-get tape ptr) 0))\n            (loop (find-matching-bracket program ip -1) tape ptr output)\n            (loop (+ ip 1) tape ptr output)))\n          (else (loop (+ ip 1) tape ptr output)))))))\n\n(println \"--- Hello World ---\")\n(println (format \"  ~a\" (bf-run \"++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.\")))\n\n(println \"\\n--- Counting 0-9 ---\")\n(println (format \"  ~a\" (bf-run \"++++++++++++++++++++++++++++++++++++++++++++++++.+.+.+.+.+.+.+.+.+.\")))\n\n(println \"\\n--- Alphabet A-Z ---\")\n(println (format \"  ~a\" (bf-run \"++++++++[>++++++++<-]>+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.\")))\n" },
    { id: "visuals/cellular-automata.sema", name: "cellular-automata.sema", code: ";; 1D Cellular Automata (Wolfram rules)\n\n(println \"=== 1D Cellular Automata ===\\n\")\n\n(define WIDTH 61)\n(define ROWS 30)\n\n(define (rule-to-bits rule)\n  (map (fn (i) (if (= 0 (bit/and rule (bit/shift-left 1 i))) 0 1)) (range 8)))\n\n(define (format-rule-binary rule)\n  (string/join (reverse (map str (rule-to-bits rule))) \"\"))\n\n(define (apply-rule rule-bits left center right)\n  (nth rule-bits (+ (bit/shift-left left 2) (bit/shift-left center 1) right)))\n\n(define (make-initial-row width)\n  (map (fn (i) (if (= i (/ (- width 1) 2)) 1 0)) (range width)))\n\n(define (next-row rule-bits row)\n  (let ((len (length row)))\n    (map (fn (i)\n      (apply-rule rule-bits\n        (if (= i 0) 0 (nth row (- i 1)))\n        (nth row i)\n        (if (= i (- len 1)) 0 (nth row (+ i 1)))))\n      (range len))))\n\n(define (render-row row)\n  (string/join (map (fn (cell) (if (= cell 1) \"â–ˆ\" \" \")) row) \"\"))\n\n(define (run-automaton rule num-rows width)\n  (let ((bits (rule-to-bits rule)))\n    (println (format \"Rule ~a (binary: ~a)\" rule (format-rule-binary rule)))\n    (let ((border (string/repeat \"â”€\" width)))\n      (println (string-append \"â”Œ\" border \"â”\"))\n      (let loop ((row (make-initial-row width)) (gen 0))\n        (println (string-append \"â”‚\" (render-row row) \"â”‚\"))\n        (if (< gen (- num-rows 1))\n          (loop (next-row bits row) (+ gen 1))))\n      (println (string-append \"â””\" border \"â”˜\")))))\n\n;; Rule 90 â€” Sierpinski triangle\n(println \"=== Rule 90 â€” Sierpinski ===\\n\")\n(run-automaton 90 ROWS WIDTH)\n\n;; Rule 30 â€” Chaotic\n(println \"\\n=== Rule 30 â€” Chaos ===\\n\")\n(run-automaton 30 ROWS WIDTH)\n\n;; Rule 110 â€” Turing-complete\n(println \"\\n=== Rule 110 â€” Complex ===\\n\")\n(run-automaton 110 ROWS WIDTH)\n" },
    { id: "visuals/game-of-life.sema", name: "game-of-life.sema", code: ";; Conway's Game of Life\n(define ROWS 15)\n(define COLS 30)\n\n(define (make-grid rows cols)\n  (map (fn (_) (map (fn (_) 0) (range cols))) (range rows)))\n\n(define (grid-get grid r c)\n  (nth (nth grid (mod r ROWS)) (mod c COLS)))\n\n(define (grid-set grid r c val)\n  (map (fn (ri)\n    (if (= ri r)\n      (map (fn (ci) (if (= ci c) val (nth (nth grid ri) ci))) (range COLS))\n      (nth grid ri)))\n    (range ROWS)))\n\n(define (grid-set-cells grid cells)\n  (foldl (fn (g cell) (grid-set g (car cell) (cadr cell) 1)) grid cells))\n\n(define (count-neighbors grid r c)\n  (let ((ru (+ r ROWS -1)) (rd (+ r 1))\n        (cl (+ c COLS -1)) (cr (+ c 1)))\n    (+ (grid-get grid ru cl) (grid-get grid ru c) (grid-get grid ru cr)\n       (grid-get grid r cl) (grid-get grid r cr)\n       (grid-get grid rd cl) (grid-get grid rd c) (grid-get grid rd cr))))\n\n(define (next-cell grid r c)\n  (let* ((alive (grid-get grid r c))\n         (n (count-neighbors grid r c)))\n    (cond ((and (= alive 1) (< n 2)) 0)\n          ((and (= alive 1) (> n 3)) 0)\n          ((and (= alive 0) (= n 3)) 1)\n          (else alive))))\n\n(define (next-gen grid)\n  (map (fn (r) (map (fn (c) (next-cell grid r c)) (range COLS))) (range ROWS)))\n\n(define (render-row row)\n  (string/join (map (fn (cell) (if (= cell 1) \"â–ˆ\" \" \")) row) \"\"))\n\n(define (show grid gen)\n  (let ((alive (foldl + 0 (map (fn (row) (foldl + 0 row)) grid)))\n        (border (string/repeat \"â”€\" COLS)))\n    (println (format \"Gen ~a | Live: ~a\" gen alive))\n    (println (str \"â”Œ\" border \"â”\"))\n    (for-each (fn (row) (println (str \"â”‚\" (render-row row) \"â”‚\"))) grid)\n    (println (str \"â””\" border \"â”˜\"))\n    (println \"\")))\n\n;; R-pentomino â€” chaotic, long-lived\n(define grid (grid-set-cells (make-grid ROWS COLS)\n  (list (list 6 16) (list 6 17) (list 7 15) (list 7 16) (list 8 16))))\n\n(define (run grid gen)\n  (show grid gen)\n  (if (< gen 15) (run (next-gen grid) (+ gen 1)) grid))\n\n(run grid 0)\n" },
    { id: "visuals/l-system.sema", name: "l-system.sema", code: ";; L-system string rewriting\n\n(println \"=== L-System String Rewriting ===\\n\")\n\n(define (apply-char rules ch)\n  (let ((r (get rules (string->keyword (char->string ch)))))\n    (if (nil? r) (char->string ch) r)))\n\n(define (apply-rules str rules)\n  (string/join (map (fn (ch) (apply-char rules ch)) (string/chars str)) \"\"))\n\n(define (iterate-lsystem axiom rules n)\n  (let loop ((current axiom) (i 0) (history (list axiom)))\n    (if (= i n) history\n      (let ((next (apply-rules current rules)))\n        (loop next (+ i 1) (append history (list next)))))))\n\n(define (show-lsystem name axiom rules n)\n  (println (format \"--- ~a ---\" name))\n  (let ((gens (iterate-lsystem axiom rules n)))\n    (for-each (fn (i)\n      (let ((gen (nth gens i)))\n        (if (<= (string-length gen) 55)\n          (println (format \"  ~a: ~a\" i gen))\n          (println (format \"  ~a: [~a chars] ~a...\" i (string-length gen) (substring gen 0 50))))))\n      (range (+ n 1))))\n  (println \"\"))\n\n;; Algae: Aâ†’AB, Bâ†’A\n(show-lsystem \"Algae (Aâ†’AB, Bâ†’A)\" \"A\" {:A \"AB\" :B \"A\"} 7)\n\n;; Binary tree: 1â†’11, 0â†’1[0]0\n(show-lsystem \"Binary Tree\" \"0\" {:1 \"11\" :0 \"1[0]0\"} 4)\n\n;; Sierpinski: Aâ†’B-A-B, Bâ†’A+B+A\n(show-lsystem \"Sierpinski\" \"A\" {:A \"B-A-B\" :B \"A+B+A\"} 5)\n\n;; Dragon curve\n(show-lsystem \"Dragon Curve\" \"FX\" {:X \"X+YF+\" :Y \"-FX-Y\"} 7)\n\n;; Growth statistics\n(println \"=== Growth Stats ===\\n\")\n(define (show-growth name axiom rules n)\n  (let ((gens (iterate-lsystem axiom rules n)))\n    (println (format \"~a:\" name))\n    (for-each (fn (i)\n      (let ((len (string-length (nth gens i))))\n        (println (format \"  Gen ~a: ~a chars ~a\"\n          (string/pad-left (str i) 2)\n          (string/pad-left (str len) 6)\n          (string/repeat \"â–ˆ\" (min 30 (int (/ len 10))))))))\n      (range (+ n 1)))))\n\n(show-growth \"Algae\" \"A\" {:A \"AB\" :B \"A\"} 10)\n" },
    { id: "visuals/lorem-ipsum.sema", name: "lorem-ipsum.sema", code: ";; Random text and data generator\n\n(define (pick-random lst) (nth lst (math/random-int 0 (- (length lst) 1))))\n(define (pick-n n lst)\n  (if (<= n 0) '() (cons (pick-random lst) (pick-n (- n 1) lst))))\n(define (capitalize s)\n  (if (> (string-length s) 0)\n    (string-append (string/upper (substring s 0 1)) (substring s 1)) s))\n\n(define lorem-words\n  (list \"lorem\" \"ipsum\" \"dolor\" \"sit\" \"amet\" \"consectetur\" \"adipiscing\"\n        \"elit\" \"sed\" \"do\" \"eiusmod\" \"tempor\" \"incididunt\" \"ut\" \"labore\"\n        \"et\" \"dolore\" \"magna\" \"aliqua\" \"enim\" \"ad\" \"minim\" \"veniam\"\n        \"quis\" \"nostrud\" \"exercitation\" \"ullamco\" \"laboris\" \"nisi\"\n        \"aliquip\" \"ex\" \"ea\" \"commodo\" \"consequat\" \"duis\" \"aute\" \"irure\"\n        \"in\" \"reprehenderit\" \"voluptate\" \"velit\" \"esse\" \"cillum\"\n        \"fugiat\" \"nulla\" \"pariatur\" \"excepteur\" \"sint\" \"occaecat\"\n        \"cupidatat\" \"non\" \"proident\" \"sunt\" \"culpa\" \"qui\" \"officia\"\n        \"deserunt\" \"mollit\" \"anim\" \"id\" \"est\" \"laborum\"))\n\n(define (generate-sentence)\n  (let ((words (pick-n (math/random-int 5 15) lorem-words)))\n    (string-append (capitalize (string/join words \" \")) \".\")))\n\n(define (generate-paragraph)\n  (let loop ((i 0) (count (math/random-int 3 6)) (acc '()))\n    (if (>= i count) (string/join (reverse acc) \" \")\n      (loop (+ i 1) count (cons (generate-sentence) acc)))))\n\n(println \"=== Lorem Ipsum ===\\n\")\n(println (generate-paragraph))\n(println \"\")\n(println (generate-paragraph))\n\n;; Random names\n(define first-names\n  (list \"James\" \"Mary\" \"Robert\" \"Patricia\" \"John\" \"Jennifer\" \"Emma\"\n        \"Oliver\" \"Ava\" \"Liam\" \"Sophia\" \"Noah\" \"Isabella\" \"Ethan\"))\n(define last-names\n  (list \"Smith\" \"Johnson\" \"Williams\" \"Brown\" \"Jones\" \"Garcia\" \"Miller\"\n        \"Davis\" \"Rodriguez\" \"Martinez\" \"Wilson\" \"Anderson\" \"Thomas\"))\n\n(println \"\\n=== Random Names ===\\n\")\n(let loop ((i 0))\n  (when (< i 8)\n    (println (format \"  ~a. ~a ~a\" (+ i 1) (pick-random first-names) (pick-random last-names)))\n    (loop (+ i 1))))\n\n;; Random data table\n(define cities (list \"New York\" \"London\" \"Tokyo\" \"Paris\" \"Berlin\" \"Sydney\" \"Toronto\"))\n\n(println \"\\n=== Data Table ===\\n\")\n(println (format \"| ~a | ~a | ~a | ~a |\"\n  (string/pad-right \"Name\" 20) (string/pad-right \"Age\" 5)\n  (string/pad-right \"City\" 12) (string/pad-right \"Score\" 7)))\n(println (format \"|~a|~a|~a|~a|\"\n  (string/repeat \"-\" 22) (string/repeat \"-\" 7)\n  (string/repeat \"-\" 14) (string/repeat \"-\" 9)))\n\n(let loop ((i 0))\n  (when (< i 6)\n    (println (format \"| ~a | ~a | ~a | ~a |\"\n      (string/pad-right (str (pick-random first-names) \" \" (pick-random last-names)) 20)\n      (string/pad-right (str (math/random-int 22 65)) 5)\n      (string/pad-right (pick-random cities) 12)\n      (string/pad-right (str (math/random-int 50 100)) 7)))\n    (loop (+ i 1))))\n" },
    { id: "visuals/mandelbrot.sema", name: "mandelbrot.sema", code: ";; ASCII Mandelbrot set renderer\n(define chars \" .:-=+*#%@\")\n(define num-chars (string-length chars))\n\n(define (mandelbrot-iter cx cy max-iter)\n  (do ((i 0 (+ i 1))\n       (zr 0.0 (+ (- (* zr zr) (* zi zi)) cx))\n       (zi 0.0 (+ (* 2.0 old-zr zi) cy))\n       (old-zr 0.0 zr))\n    ((or (>= i max-iter)\n         (> (+ (* zr zr) (* zi zi)) 4.0))\n     i)))\n\n(define (iter->char iter max-iter)\n  (if (= iter max-iter)\n    (char->string (string-ref chars (- num-chars 1)))\n    (let ((idx (floor (* (/ iter max-iter) (- num-chars 1)))))\n      (char->string (string-ref chars idx)))))\n\n(define (render x-min x-max y-min y-max w h max-iter)\n  (let ((dx (/ (- x-max x-min) w))\n        (dy (/ (- y-max y-min) h)))\n    (do ((row 0 (+ row 1)))\n      ((= row h))\n      (let ((cy (+ y-min (* row dy))))\n        (do ((col 0 (+ col 1)))\n          ((= col w))\n          (let* ((cx (+ x-min (* col dx)))\n                 (iter (mandelbrot-iter cx cy max-iter)))\n            (display (iter->char iter max-iter)))))\n      (newline))))\n\n(render -2.5 1.0 -1.1 1.1 60 20 60)\n" },
    { id: "visuals/maze-solver.sema", name: "maze-solver.sema", code: ";; Maze generator + BFS solver â€” shows solution path with +\n(define width 15)\n(define height 10)\n\n(define (pos x y) (str x \",\" y))\n\n(define (shuffle lst)\n  (if (<= (length lst) 1) lst\n    (let* ((i (math/random-int 0 (- (length lst) 1)))\n           (picked (nth lst i))\n           (rest (append (take i lst) (drop (+ i 1) lst))))\n      (cons picked (shuffle rest)))))\n\n(define directions (list (list 0 -1) (list 0 1) (list -1 0) (list 1 0)))\n\n(define (unvisited-neighbors grid cx cy)\n  (filter\n    (fn (entry)\n      (let ((nx (car entry)) (ny (cadr entry)))\n        (and (>= nx 0) (< nx width)\n             (>= ny 0) (< ny height)\n             (not (get grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #f)))))\n    (map (fn (dir)\n           (list (+ cx (car dir)) (+ cy (cadr dir)) (car dir) (cadr dir)))\n         (shuffle directions))))\n\n(define (generate-maze)\n  (let loop ((stack (list (list 0 0)))\n             (grid (assoc {} (pos 1 1) #t)))\n    (if (null? stack) grid\n      (let* ((cell (car stack))\n             (cx (car cell)) (cy (cadr cell))\n             (neighbors (unvisited-neighbors grid cx cy)))\n        (if (null? neighbors)\n          (loop (cdr stack) grid)\n          (let* ((next (car neighbors))\n                 (nx (car next)) (ny (cadr next))\n                 (dx (nth next 2)) (dy (nth next 3))\n                 (grid (assoc grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #t))\n                 (grid (assoc grid (pos (+ (* cx 2) 1 dx) (+ (* cy 2) 1 dy)) #t)))\n            (loop (cons (list nx ny) stack) grid)))))))\n\n(define grid-w (+ (* 2 width) 1))\n(define grid-h (+ (* 2 height) 1))\n\n(define (wall? grid x y)\n  (and (>= x 0) (< x grid-w) (>= y 0) (< y grid-h)\n       (not (get grid (pos x y) #f))))\n\n(define (box-char grid x y)\n  (let* ((u (wall? grid x (- y 1)))\n         (d (wall? grid x (+ y 1)))\n         (l (wall? grid (- x 1) y))\n         (r (wall? grid (+ x 1) y))\n         (bits (+ (if u 1 0) (if d 2 0) (if l 4 0) (if r 8 0))))\n    (cond\n      ((= bits 15) \"â”¼â”€\")  ((= bits 14) \"â”¬â”€\")  ((= bits 13) \"â”´â”€\")\n      ((= bits 11) \"â”œâ”€\")  ((= bits  7) \"â”¤ \")  ((= bits  6) \"â” \")\n      ((= bits 10) \"â”Œâ”€\")  ((= bits  5) \"â”˜ \")  ((= bits  9) \"â””â”€\")\n      ((= bits 12) \"â”€â”€\")  ((= bits  3) \"â”‚ \")  ((= bits  1) \"â”‚ \")\n      ((= bits  2) \"â”‚ \")  ((= bits  4) \"â”€ \")  ((= bits  8) \"â”€â”€\")\n      (else \"Â· \"))))\n\n;;; --- BFS Solver ---\n\n(define (reconstruct-path parent start-key end-key)\n  (let loop ((key end-key)\n             (path (assoc {} end-key #t)))\n    (if (equal? key start-key) path\n      (let ((prev (get parent key #f)))\n        (if prev\n          (loop prev (assoc path prev #t))\n          path)))))\n\n(define (solve grid start-x start-y end-x end-y)\n  (let ((start-key (pos start-x start-y))\n        (end-key (pos end-x end-y)))\n    (let bfs ((queue (list (list start-x start-y)))\n              (visited (assoc {} start-key #t))\n              (parent {}))\n      (if (null? queue) {}\n        (let* ((current (car queue))\n               (rest-queue (cdr queue))\n               (cx (car current)) (cy (cadr current)))\n          (if (and (= cx end-x) (= cy end-y))\n            (reconstruct-path parent start-key end-key)\n            (let* ((nbrs (filter\n                           (fn (n)\n                             (let ((nx (car n)) (ny (cadr n)))\n                               (and (>= nx 0) (< nx grid-w)\n                                    (>= ny 0) (< ny grid-h)\n                                    (get grid (pos nx ny) #f)\n                                    (not (get visited (pos nx ny) #f)))))\n                           (map (fn (d) (list (+ cx (car d)) (+ cy (cadr d))))\n                                directions)))\n                   (state (foldl\n                            (fn (acc n)\n                              (let ((nkey (pos (car n) (cadr n))))\n                                (list (append (car acc) (list n))\n                                      (assoc (cadr acc) nkey #t)\n                                      (assoc (nth acc 2) nkey (pos cx cy)))))\n                            (list rest-queue visited parent)\n                            nbrs)))\n              (bfs (car state) (cadr state) (nth state 2)))))))))\n\n;;; --- Render with solution ---\n\n(define (render-solved grid path)\n  (for-each\n    (fn (y)\n      (println\n        (string/join\n          (map (fn (x)\n                 (if (get grid (pos x y) #f)\n                   (if (get path (pos x y) #f) \"+ \" \"  \")\n                   (box-char grid x y)))\n               (range grid-w)) \"\")))\n    (range grid-h)))\n\n(define grid (generate-maze))\n(define path (solve grid 1 1 (- grid-w 2) (- grid-h 2)))\n(render-solved grid path)\n" },
    { id: "visuals/maze.sema", name: "maze.sema", code: ";; ASCII maze generator\n(define width 15)\n(define height 10)\n\n(define (pos x y) (str x \",\" y))\n\n(define (shuffle lst)\n  (if (<= (length lst) 1) lst\n    (let* ((i (math/random-int 0 (- (length lst) 1)))\n           (picked (nth lst i))\n           (rest (append (take i lst) (drop (+ i 1) lst))))\n      (cons picked (shuffle rest)))))\n\n(define directions (list (list 0 -1) (list 0 1) (list -1 0) (list 1 0)))\n\n(define (unvisited-neighbors grid cx cy)\n  (filter\n    (fn (entry)\n      (let ((nx (car entry)) (ny (cadr entry)))\n        (and (>= nx 0) (< nx width)\n             (>= ny 0) (< ny height)\n             (not (get grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #f)))))\n    (map (fn (dir)\n           (list (+ cx (car dir)) (+ cy (cadr dir)) (car dir) (cadr dir)))\n         (shuffle directions))))\n\n(define (generate-maze)\n  (let loop ((stack (list (list 0 0)))\n             (grid (assoc {} (pos 1 1) #t)))\n    (if (null? stack) grid\n      (let* ((cell (car stack))\n             (cx (car cell)) (cy (cadr cell))\n             (neighbors (unvisited-neighbors grid cx cy)))\n        (if (null? neighbors)\n          (loop (cdr stack) grid)\n          (let* ((next (car neighbors))\n                 (nx (car next)) (ny (cadr next))\n                 (dx (nth next 2)) (dy (nth next 3))\n                 (grid (assoc grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #t))\n                 (grid (assoc grid (pos (+ (* cx 2) 1 dx) (+ (* cy 2) 1 dy)) #t)))\n            (loop (cons (list nx ny) stack) grid)))))))\n\n(define grid-w (+ (* 2 width) 1))\n(define grid-h (+ (* 2 height) 1))\n\n(define (wall? grid x y)\n  (and (>= x 0) (< x grid-w) (>= y 0) (< y grid-h)\n       (not (get grid (pos x y) #f))))\n\n;; Double-wide box chars to correct for ~2:1 char aspect ratio\n(define (box-char grid x y)\n  (let* ((u (wall? grid x (- y 1)))\n         (d (wall? grid x (+ y 1)))\n         (l (wall? grid (- x 1) y))\n         (r (wall? grid (+ x 1) y))\n         (bits (+ (if u 1 0) (if d 2 0) (if l 4 0) (if r 8 0))))\n    (cond\n      ((= bits 15) \"â”¼â”€\")  ((= bits 14) \"â”¬â”€\")  ((= bits 13) \"â”´â”€\")\n      ((= bits 11) \"â”œâ”€\")  ((= bits  7) \"â”¤ \")  ((= bits  6) \"â” \")\n      ((= bits 10) \"â”Œâ”€\")  ((= bits  5) \"â”˜ \")  ((= bits  9) \"â””â”€\")\n      ((= bits 12) \"â”€â”€\")  ((= bits  3) \"â”‚ \")  ((= bits  1) \"â”‚ \")\n      ((= bits  2) \"â”‚ \")  ((= bits  4) \"â”€ \")  ((= bits  8) \"â”€â”€\")\n      (else \"Â· \"))))\n\n(define (render grid)\n  (for-each\n    (fn (y)\n      (println\n        (string/join\n          (map (fn (x)\n                 (if (get grid (pos x y) #f) \"  \" (box-char grid x y)))\n               (range grid-w)) \"\")))\n    (range grid-h)))\n\n(render (generate-maze))\n" },
    { id: "visuals/perlin-noise.sema", name: "perlin-noise.sema", code: ";; Value noise terrain generator\n(define width 60)\n(define height 20)\n(define seed (math/random-int 1 999999))\n\n(define (hash x y)\n  (let* ((h (mod (+ (* (abs x) 374761393) (* (abs y) 668265263)\n                    (* seed 1274126177)) 1000000003))\n         (h2 (mod (* h h) 1000000007)))\n    (/ (mod (abs h2) 1000000) 1000000.0)))\n\n(define (fade t)\n  (let ((t3 (* t t t)))\n    (* t3 (+ (* t (- (* t 6.0) 15.0)) 10.0))))\n\n(define (lerp a b t) (+ a (* (- b a) t)))\n\n(define (value-noise x y)\n  (let* ((ix (floor x)) (iy (floor y))\n         (fx (- x ix)) (fy (- y iy))\n         (u (fade fx)) (v (fade fy)))\n    (lerp (lerp (hash ix iy) (hash (+ ix 1) iy) u)\n          (lerp (hash ix (+ iy 1)) (hash (+ ix 1) (+ iy 1)) u)\n          v)))\n\n(define (octave-noise x y)\n  (let loop ((i 0) (freq 1.0) (amp 1.0) (total 0.0) (max-amp 0.0))\n    (if (= i 3) (/ total max-amp)\n      (loop (+ i 1) (* freq 2.0) (* amp 0.5)\n            (+ total (* amp (value-noise (* x freq 0.08) (* y freq 0.08))))\n            (+ max-amp amp)))))\n\n(define (terrain-char val)\n  (cond ((< val 0.30) \"~\") ((< val 0.38) \".\") ((< val 0.50) \",\")\n        ((< val 0.60) \";\") ((< val 0.72) \":\") ((< val 0.85) \"%\")\n        (#t \"#\")))\n\n(for-each (fn (y)\n  (println (string/join (map (fn (x) (terrain-char (octave-noise x y))) (range width)) \"\")))\n  (range height))\n\n(println \"\")\n(println \"~ water  . sand  , grass  ; shrub  : forest  % mountain  # peak\")\n" }
  ]},
  { category: "Math & Crypto", files: [
    { id: "math-crypto/datetime.sema", name: "datetime.sema", code: ";; Date/time operations\n\n(define now (time/now))\n(println (format \"Current: ~a\" (time/format now \"%Y-%m-%d %H:%M:%S UTC\")))\n\n(define parts (time/date-parts now))\n(println (format \"\\nDate parts:\"))\n(println (format \"  Year: ~a  Month: ~a  Day: ~a\" (get parts :year) (get parts :month) (get parts :day)))\n(println (format \"  Hour: ~a  Min: ~a  Sec: ~a\" (get parts :hour) (get parts :minute) (get parts :second)))\n(println (format \"  Weekday: ~a\" (get parts :weekday)))\n\n;; Parse and reformat\n(println \"\\nDate reformatting:\")\n(for-each (fn (date-str)\n  (let* ((ts (time/parse date-str \"%Y-%m-%d %H:%M:%S\"))\n         (parts (time/date-parts ts)))\n    (println (format \"  ~a â†’ ~a (~a)\"\n      date-str (time/format ts \"%B %d, %Y\") (get parts :weekday)))))\n  (list \"2024-01-15 10:30:00\" \"2024-06-21 14:00:00\" \"2024-12-25 00:00:00\"))\n\n;; Epoch milestones\n(println \"\\nEpoch milestones:\")\n(for-each (fn (m)\n  (println (format \"  ~a: ~a\"\n    (string/pad-right (first m) 16)\n    (time/format (nth m 1) \"%Y-%m-%d %H:%M:%S\"))))\n  (list (list \"Unix epoch\" 0.0) (list \"Y2K\" 946684800.0)\n        (list \"Unix 1 billion\" 1000000000.0) (list \"2024-01-01\" 1704067200.0)))\n\n;; Date arithmetic\n(println \"\\nDays between dates:\")\n(define (days-between a b)\n  (let ((ta (time/parse a \"%Y-%m-%d %H:%M:%S\"))\n        (tb (time/parse b \"%Y-%m-%d %H:%M:%S\")))\n    (round (/ (abs (- tb ta)) 86400.0))))\n(println (format \"  2024-01-01 to 2024-12-25: ~a days\"\n  (days-between \"2024-01-01 00:00:00\" \"2024-12-25 00:00:00\")))\n\n;; Timing operations\n(println \"\\nTiming operations:\")\n(define (measure name thunk)\n  (let ((start (time-ms)))\n    (thunk)\n    (println (format \"  ~a took ~ams\" (string/pad-right name 30) (- (time-ms) start)))))\n\n(measure \"Sum 1 to 100000\" (fn () (foldl + 0 (range 1 100001))))\n(measure \"Generate 1000 random numbers\" (fn () (map (fn (_) (math/random)) (range 1000))))\n(measure \"Sort 1000 random ints\"\n  (fn () (sort (map (fn (_) (math/random-int 1 10000)) (range 1000)))))\n" },
    { id: "math-crypto/math-crypto.sema", name: "math-crypto.sema", code: ";; Math, crypto, base64, UUID, bitwise operations\n\n;; Prime sieve\n(define (sieve-primes n)\n  (let loop ((candidates (range 2 n)) (primes '()))\n    (if (null? candidates) (reverse primes)\n      (let ((p (first candidates)))\n        (loop (filter (fn (x) (not (= 0 (math/remainder x p)))) (rest candidates))\n              (cons p primes))))))\n\n(define primes-100 (sieve-primes 100))\n(println (format \"Primes under 100 (~a total):\" (length primes-100)))\n(println (format \"  ~a\" (string/join (map str primes-100) \" \")))\n\n(println (format \"\\ngcd(12, 8) = ~a\" (math/gcd 12 8)))\n(println (format \"lcm(12, 8) = ~a\" (math/lcm 12 8)))\n\n;; Trig identity\n(println \"\\nVerifying sinÂ²(x) + cosÂ²(x) = 1:\")\n(for-each (fn (x)\n  (let ((s (sin x)) (c (cos x)))\n    (println (format \"  x=~a â†’ ~a âœ“\"\n      (string/pad-right (str (round (* x 100))) 4)\n      (+ (* s s) (* c c))))))\n  (list 0.0 0.5 1.0 1.5 2.0 pi))\n\n;; Bitwise IP parsing\n(define (ip-to-int a b c d)\n  (bit/or (bit/or (bit/shift-left a 24) (bit/shift-left b 16))\n          (bit/or (bit/shift-left c 8) d)))\n(define (int-to-ip n)\n  (format \"~a.~a.~a.~a\"\n    (bit/and (bit/shift-right n 24) 255)\n    (bit/and (bit/shift-right n 16) 255)\n    (bit/and (bit/shift-right n 8) 255)\n    (bit/and n 255)))\n\n(println (format \"\\n192.168.1.100 â†’ ~a â†’ ~a\"\n  (ip-to-int 192 168 1 100)\n  (int-to-ip (ip-to-int 192 168 1 100))))\n\n;; UUID\n(println \"\\nUUIDs:\")\n(for-each (fn (_) (println (format \"  ~a\" (uuid/v4)))) (range 3))\n\n;; Base64\n(println \"\\nBase64:\")\n(for-each (fn (msg)\n  (let ((enc (base64/encode msg)))\n    (println (format \"  ~a â†’ ~a â†’ ~a\"\n      (string/pad-right msg 20) (string/pad-right enc 28) (base64/decode enc)))))\n  (list \"Hello, World!\" \"Sema Lisp rocks\" \"data: 42\"))\n\n;; SHA-256\n(println \"\\nSHA-256:\")\n(for-each (fn (input)\n  (println (format \"  sha256(~a) = ~a...\"\n    (string/pad-right (format \"\\\"~a\\\"\" input) 15)\n    (substring (hash/sha256 input) 0 16))))\n  (list \"\" \"hello\" \"Hello\" \"Sema\"))\n" },
    { id: "math-crypto/matrix-math.sema", name: "matrix-math.sema", code: ";; Matrix operations using nested lists\n\n(println \"=== Matrix Math ===\\n\")\n\n(define (matrix-rows m) (length m))\n(define (matrix-cols m) (length (first m)))\n\n(define (matrix-transpose m)\n  (map (fn (c) (map (fn (row) (nth row c)) m)) (range (matrix-cols m))))\n\n(define (matrix-add a b)\n  (map (fn (pair) (map + (first pair) (nth pair 1))) (zip a b)))\n\n(define (matrix-scalar-multiply s m)\n  (map (fn (row) (map (fn (x) (* s x)) row)) m))\n\n(define (matrix-multiply a b)\n  (let ((bt (matrix-transpose b)))\n    (map (fn (row-a)\n      (map (fn (col-b) (foldl + 0 (map * row-a col-b))) bt)) a)))\n\n(define (matrix-identity n)\n  (map (fn (i) (map (fn (j) (if (= i j) 1 0)) (range n))) (range n)))\n\n(define (matrix-determinant m)\n  (let ((n (matrix-rows m)))\n    (cond\n      ((= n 2) (- (* (nth (first m) 0) (nth (nth m 1) 1))\n                   (* (nth (first m) 1) (nth (nth m 1) 0))))\n      ((= n 3)\n       (let ((a (first m)) (b (nth m 1)) (c (nth m 2)))\n         (- (+ (* (nth a 0) (- (* (nth b 1) (nth c 2)) (* (nth b 2) (nth c 1))))\n               (* (nth a 2) (- (* (nth b 0) (nth c 1)) (* (nth b 1) (nth c 0)))))\n            (* (nth a 1) (- (* (nth b 0) (nth c 2)) (* (nth b 2) (nth c 0))))))))))\n\n(define (matrix-print name m)\n  (println (format \"  ~a =\" name))\n  (for-each (fn (row)\n    (println (format \"    â”‚ ~a â”‚\"\n      (string/join (map (fn (x) (string/pad-left (str x) 5)) row) \" \"))))\n    m)\n  (println \"\"))\n\n(define A (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))\n(define B (list (list 9 8 7) (list 6 5 4) (list 3 2 1)))\n\n(matrix-print \"A\" A)\n(matrix-print \"B\" B)\n(matrix-print \"A + B\" (matrix-add A B))\n(matrix-print \"2Â·A\" (matrix-scalar-multiply 2 A))\n\n;; Transpose: (A^T)^T = A\n(println \"=== Properties ===\\n\")\n(define At (matrix-transpose A))\n(matrix-print \"Aáµ€\" At)\n(println (format \"  (Aáµ€)áµ€ = A? ~a\" (if (equal? A (matrix-transpose At)) \"YES âœ“\" \"NO âœ—\")))\n\n;; Multiply\n(define P (list (list 1 2) (list 3 4)))\n(define Q (list (list 5 6) (list 7 8)))\n(matrix-print \"\\n  PÃ—Q\" (matrix-multiply P Q))\n\n;; A Ã— I = A\n(define I3 (matrix-identity 3))\n(println (format \"  AÃ—I = A? ~a\" (if (equal? (matrix-multiply A I3) A) \"YES âœ“\" \"NO âœ—\")))\n\n;; Determinants\n(println \"\\n=== Determinants ===\\n\")\n(define M3 (list (list 6 1 1) (list 4 -2 5) (list 2 8 7)))\n(matrix-print \"Mâ‚ƒ\" M3)\n(println (format \"  det(Mâ‚ƒ) = ~a\" (matrix-determinant M3)))\n(println (format \"  det(Iâ‚ƒ) = ~a\" (matrix-determinant I3)))\n" },
    { id: "math-crypto/pretty-print.sema", name: "pretty-print.sema", code: ";;; S-expression pretty printer\n\n(define pp-indent 2)\n(define pp-width 60)\n\n(define (flat-length val) (string-length (str val)))\n(define (flat val) (str val))\n\n(define (pp val indent)\n  (cond\n    ((number? val) (flat val))\n    ((string? val) (format \"\\\"~a\\\"\" val))\n    ((symbol? val) (flat val))\n    ((keyword? val) (flat val))\n    ((boolean? val) (if val \"#t\" \"#f\"))\n    ((nil? val) \"nil\")\n    ((list? val)\n     (if (null? val) \"()\"\n       (let ((flat-repr (flat val)))\n         (if (<= (+ indent (string-length flat-repr)) pp-width)\n           flat-repr (pp-list val indent)))))\n    ((vector? val)\n     (let ((flat-repr (flat val)))\n       (if (<= (+ indent (string-length flat-repr)) pp-width)\n         flat-repr (pp-vector val indent))))\n    ((map? val)\n     (let ((flat-repr (flat val)))\n       (if (<= (+ indent (string-length flat-repr)) pp-width)\n         flat-repr (pp-map val indent))))\n    (else (flat val))))\n\n(define (pp-list lst indent)\n  (let* ((head (car lst))\n         (is-special (and (symbol? head)\n                          (let ((s (str head)))\n                            (or (= s \"define\") (= s \"fn\") (= s \"lambda\")\n                                (= s \"let\") (= s \"let*\") (= s \"if\")\n                                (= s \"cond\") (= s \"when\") (= s \"begin\"))))))\n    (if is-special (pp-special lst indent) (pp-call lst indent))))\n\n(define (pp-special lst indent)\n  (let* ((head (car lst)) (rest-items (cdr lst))\n         (child-indent (+ indent pp-indent))\n         (pad (string/repeat \" \" child-indent)))\n    (if (null? rest-items) (str \"(\" head \")\")\n      (let* ((first-arg (car rest-items)) (more (cdr rest-items))\n             (line1 (str \"(\" head \" \" (pp first-arg (+ indent (string-length (str head)) 2)))))\n        (if (null? more) (str line1 \")\")\n          (string-append line1 \"\\n\"\n            (string/join (map (fn (item) (str pad (pp item child-indent))) more) \"\\n\")\n            \")\"))))))\n\n(define (pp-call lst indent)\n  (let* ((child-indent (+ indent pp-indent))\n         (pad (string/repeat \" \" child-indent))\n         (items (map (fn (item) (pp item child-indent)) lst)))\n    (string-append \"(\" (string/join items (str \"\\n\" pad)) \")\")))\n\n(define (pp-vector vec indent)\n  (let* ((ci (+ indent 1)) (pad (string/repeat \" \" ci))\n         (items (map (fn (item) (pp item ci)) (vector->list vec))))\n    (string-append \"[\" (string/join items (str \"\\n\" pad)) \"]\")))\n\n(define (pp-map m indent)\n  (let* ((ci (+ indent 1)) (pad (string/repeat \" \" ci))\n         (lines (map (fn (entry)\n           (str (pp (car entry) ci) \" \"\n                (pp (cadr entry) (+ ci (flat-length (car entry)) 1))))\n           (map/entries m))))\n    (string-append \"{\" (string/join lines (str \"\\n\" pad)) \"}\")))\n\n(define (pretty-print val) (println (pp val 0)))\n\n(println \"=== S-Expression Pretty Printer ===\\n\")\n\n(println \"--- Short list ---\")\n(pretty-print '(+ 1 2 3))\n\n(println \"\\n--- Nested expression ---\")\n(pretty-print '(define (fibonacci n)\n                 (let loop ((i n) (a 0) (b 1))\n                   (if (= i 0) a (loop (- i 1) b (+ a b))))))\n\n(println \"\\n--- Map ---\")\n(pretty-print {:name \"Alice\" :age 30 :hobbies (list \"reading\" \"hiking\" \"coding\")\n               :address {:street \"123 Main St\" :city \"Wonderland\"}})\n\n(println \"\\n--- Lambda ---\")\n(pretty-print '(fn (request)\n                 (let ((method (get request :method))\n                       (path (get request :path)))\n                   (cond\n                     ((= method \"GET\") (handle-get path))\n                     ((= method \"POST\") (handle-post path (get request :body)))\n                     (else (error \"unsupported method\"))))))\n" }
  ]}
];
