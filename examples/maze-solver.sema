;;; maze-solver.sema — Maze generator + BFS solver
;;;
;;; Generates a perfect maze using randomized depth-first search,
;;; then solves it with breadth-first search and displays the
;;; solution path marked with + characters.
;;;
;;; Demonstrates: BFS path-finding, map-based sparse grids,
;;;               path reconstruction via parent pointers

(define width   30)
(define height  15)

;;; --- Utilities ---

(define (pos x y) (str x "," y))

(define (shuffle lst)
  (if (<= (length lst) 1)
    lst
    (let* ((i       (math/random-int 0 (- (length lst) 1)))
           (picked  (nth lst i))
           (rest    (append (take i lst) (drop (+ i 1) lst))))
      (cons picked (shuffle rest)))))

;;; --- Maze generation ---
;;;
;;; The maze lives on a (2W+1) x (2H+1) rendering grid.
;;; Cells sit at odd coordinates (2x+1, 2y+1); walls fill the gaps.
;;; Passable positions stored in a map: "gx,gy" -> #t

(define directions (list (list 0 -1) (list 0 1) (list -1 0) (list 1 0)))

(define (unvisited-neighbors grid cx cy)
  (filter
    (fn (entry)
      (let ((nx (car entry)) (ny (cadr entry)))
        (and (>= nx 0)
          (< nx width)
          (>= ny 0)
          (< ny height)
          (not (get grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #f)))))
    (map
      (fn (dir)
        (list (+ cx (car dir)) (+ cy (cadr dir)) (car dir) (cadr dir)))
      (shuffle directions))))

(define (generate-maze)
  (let loop ((stack  (list (list 0 0)))
             (grid   (assoc {} (pos 1 1) #t)))
    (if (null? stack)
      grid
      (let* ((cell       (car stack))
             (cx         (car cell))
             (cy         (cadr cell))
             (neighbors  (unvisited-neighbors grid cx cy)))
        (if (null? neighbors)
          (loop (cdr stack) grid)
          (let* ((next (car neighbors))
                 (nx (car next))
                 (ny (cadr next))
                 (dx (nth next 2))
                 (dy (nth next 3))
                 (grid (assoc grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #t))
                 (grid (assoc grid (pos (+ (* cx 2) 1 dx) (+ (* cy 2) 1 dy)) #t)))
            (loop (cons (list nx ny) stack) grid)))))))

;;; --- Rendering ---

(define grid-w (+ (* 2 width) 1))
(define grid-h (+ (* 2 height) 1))

(define (wall? grid x y)
  (and (>= x 0)
    (< x grid-w)
    (>= y 0)
    (< y grid-h)
    (not (get grid (pos x y) #f))))

(define (box-char grid x y)
  (let* ((u     (wall? grid x (- y 1)))
         (d     (wall? grid x (+ y 1)))
         (l     (wall? grid (- x 1) y))
         (r     (wall? grid (+ x 1) y))
         (bits  (+ (if u 1 0) (if d 2 0) (if l 4 0) (if r 8 0))))
    (cond
      ((= bits 15)  "┼─")
      ((= bits 14)  "┬─")
      ((= bits 13)  "┴─")
      ((= bits 11)  "├─")
      ((= bits 7)   "┤ ")
      ((= bits 6)   "┐ ")
      ((= bits 10)  "┌─")
      ((= bits 5)   "┘ ")
      ((= bits 9)   "└─")
      ((= bits 12)  "──")
      ((= bits 3)   "│ ")
      ((= bits 1)   "│ ")
      ((= bits 2)   "│ ")
      ((= bits 4)   "─ ")
      ((= bits 8)   "──")
      (else         "· "))))

;;; --- BFS Solver ---

;; Walk parent pointers from end back to start, collecting path cells
(define (reconstruct-path parent start-key end-key)
  (let loop ((key   end-key)
             (path  (assoc {} end-key #t)))
    (if (equal? key start-key)
      path
      (let ((prev (get parent key #f)))
        (if prev
          (loop prev (assoc path prev #t))
          path)))))

;; BFS on the rendering grid — finds shortest path from start to end
(define (solve grid start-x start-y end-x end-y)
  (let ((start-key  (pos start-x start-y))
        (end-key    (pos end-x end-y)))
    (let bfs ((queue    (list (list start-x start-y)))
              (visited  (assoc {} start-key #t))
              (parent   {}))
      (if (null? queue)
        {}
        ;; no path found
        (let* ((current     (car queue))
               (rest-queue  (cdr queue))
               (cx          (car current))
               (cy          (cadr current)))
          (if (and (= cx end-x) (= cy end-y))
            ;; Found the end — reconstruct and return path
            (reconstruct-path parent start-key end-key)
            ;; Explore passable, unvisited neighbors
            (let* ((nbrs
                     (filter
                       (fn (n)
                         (let ((nx (car n)) (ny (cadr n)))
                           (and (>= nx 0)
                             (< nx grid-w)
                             (>= ny 0)
                             (< ny grid-h)
                             (get grid (pos nx ny) #f)
                             (not (get visited (pos nx ny) #f)))))
                       (map (fn (d) (list (+ cx (car d)) (+ cy (cadr d))))
                         directions)))
                   ;; Fold over new neighbors: enqueue, mark visited, record parent
                   (state
                     (foldl
                       (fn (acc n)
                         (let ((nkey (pos (car n) (cadr n))))
                           (list (append (car acc) (list n))
                             (assoc (cadr acc) nkey #t)
                             (assoc (nth acc 2) nkey (pos cx cy)))))
                       (list rest-queue visited parent)
                       nbrs)))
              (bfs (car state) (cadr state) (nth state 2)))))))))

;;; --- Render with solution path ---

(define (render-solved grid path)
  (for-each
    (fn (y)
      (println
        (string/join
          (map
            (fn (x)
              (if (get grid (pos x y) #f)
                (if (get path (pos x y) #f)
                  "+ "
                  "  ")
                (box-char grid x y)))
            (range grid-w))
          "")))
    (range grid-h)))

;;; --- Main ---

(define grid (generate-maze))
(define path (solve grid 1 1 (- grid-w 2) (- grid-h 2)))

(println (str "Solved " width "×" height " maze:\n"))
(render-solved grid path)
