;; towers-of-hanoi.sema — Classic Towers of Hanoi with ASCII visualization

(println "=== Towers of Hanoi ===\n")

(define num-disks 5)
(define move-counter (list 0))

;; Tower state: 3 stacks stored as a map {:A (...) :B (...) :C (...)}
(define (make-towers n)
  (hash-map :A (range 1 (+ n 1)) :B (list) :C (list)))

;; Move top disk from one peg to another
(define (move-disk towers from to)
  (let* ((from-stack (get towers from))
         (to-stack (get towers to))
         (disk (car from-stack))
         (new-from (cdr from-stack))
         (new-to (cons disk to-stack)))
    (assoc (assoc towers from new-from) to new-to)))

;; Render a single disk as ASCII art
(define (render-disk disk width)
  (if (= disk 0)
    (string-append (string/pad-left "|" width) (string/repeat " " (- width 1)))
    (let* ((arm (string/repeat "█" disk))
           (line (string-append arm "|" arm))
           (pad-left (string/pad-left line width))
           (total-width (- (* 2 width) 1)))
      (string/pad-right pad-left total-width))))

;; Display the current state of all three towers
(define (display-towers towers)
  (let* ((col-width (+ num-disks 1))
         (total-col (- (* 2 col-width) 1))
         (a (get towers :A))
         (b (get towers :B))
         (c (get towers :C))
         (pad-a
           (append (map (lambda (_) 0) (range 0 (- num-disks (length a)))) a))
         (pad-b
           (append (map (lambda (_) 0) (range 0 (- num-disks (length b)))) b))
         (pad-c
           (append (map (lambda (_) 0) (range 0 (- num-disks (length c)))) c)))
    (for-each
      (lambda (i)
        (let ((da (nth pad-a i))
              (db (nth pad-b i))
              (dc (nth pad-c i)))
          (println
            (format "  ~a ~a ~a"
              (render-disk da col-width)
              (render-disk db col-width)
              (render-disk dc col-width)))))
      (range 0 num-disks))
    (println
      (format "  ~a ~a ~a"
        (string/pad-right (string/pad-left "A" col-width) total-col)
        (string/pad-right (string/pad-left "B" col-width) total-col)
        (string/pad-right (string/pad-left "C" col-width) total-col)))
    (println "")))

;; Solve recursively, displaying each move
(define (solve n from to aux towers)
  (if (= n 0)
    towers
    (let* ((towers1 (solve (- n 1) from aux to towers))
           (disk (car (get towers1 from)))
           (towers2 (move-disk towers1 from to))
           (move-num (+ 1 (car move-counter))))
      (set! move-counter (list move-num))
      (println
        (format "--- Move ~a: Disk ~a from ~a → ~a ---"
          move-num
          disk
          (keyword->string from)
          (keyword->string to)))
      (display-towers towers2)
      (solve (- n 1) aux to from towers2))))

;; Run it
(println (format "Solving for ~a disks...\n" num-disks))

(define initial (make-towers num-disks))
(println "--- Initial State ---")
(display-towers initial)

(define final-state (solve num-disks :A :C :B initial))

(println "=== Complete! ===")
(println
  (format "Total moves: ~a (optimal = ~a)"
    (car move-counter)
    (- (pow 2 num-disks) 1)))
