;; coding-agent.sema — Coding Agent with Terminal UX
;;
;; A real coding agent with file editing, search, and shell tools.
;; Shows each tool call with color-coded output and animated spinners.
;;
;; Usage:
;;   sema examples/ai-tools/coding-agent.sema

(define provider (llm/auto-configure))
(when (nil? provider)
  (io/println-error "Error: Set ANTHROPIC_API_KEY or OPENAI_API_KEY")
  (exit 1))

;; ---- Environment context ----
(define cwd       (sys/cwd))
(define platform  (sys/platform))

;; ---- Banned commands for safety ----
(define banned-commands
  '("rm -rf /" "rm -rf ~"
    "mkfs"
    "dd if="
    "> /dev/sd"
    ":(){"
    "fork"
    "format c:"))

(define (command-safe? cmd)
  (not (any (lambda (pat) (string/contains? cmd pat)) banned-commands)))

;; ---- Helper: truncate long strings ----
(define (truncate-str s max-len)
  (if (> (string/length s) max-len)
    (string/append (string/slice s 0 max-len) "...")
    s))

;; ---- Tool definitions ----

(deftool read-file
  "Read a file and return its contents with line numbers. Always read a file before editing it."
  {:path {:type :string :description "Path to the file to read"}}
  (lambda (path)
    (if (file/exists? path)
      (let* ((content (file/read path))
             (lines (string/split content "\n"))
             (numbered
               (map
                 (lambda (pair)
                   (format "~a\t~a"
                     (+ 1 (car pair))
                     (cdr pair)))
                 (zip (range 0 (length lines)) lines))))
        (string/join numbered "\n"))
      (format "Error: File not found: ~a" path))))

(deftool write-file
  "Create or overwrite a file with the given content."
  {:path {:type :string :description "Path to the file to write"}
   :content {:type :string :description "Content to write"}}
  (lambda (path content)
    (file/write path content)
    (format "Wrote ~a bytes to ~a" (string/length content) path)))

(deftool edit-file
  "Edit a file by replacing an exact string match. You must read the file first.
The old_string must match exactly (including whitespace and indentation).
For creating new files, use write-file instead."
  {:path {:type :string :description "Path to the file to edit"}
   :old_string {:type :string :description "Exact string to find and replace"}
   :new_string {:type :string :description "Replacement string"}}
  (lambda (path old_string new_string)
    (if (file/exists? path)
      (let ((content (file/read path)))
        (if (string/contains? content old_string)
          (let ((new-content (string/replace content old_string new_string)))
            (file/write path new-content)
            (format "Edited ~a: replaced ~a chars with ~a chars"
              path
              (string/length old_string)
              (string/length new_string)))
          (format
            "Error: old_string not found in ~a. Read the file first to get exact content."
            path)))
      (format "Error: File not found: ~a" path))))

(deftool search
  "Search for a pattern in files using grep. Returns matching lines with file paths and line numbers."
  {:pattern {:type :string :description "Search pattern (text to find)"}
   :path {:type :string
    :description "Directory or file to search in (default: current directory)"}}
  (lambda (pattern path)
    (define search-path (if (= path "") "." path))
    (define result
      (shell "grep" "-rn" "--include=*" "-m" "50" pattern search-path))
    (if (= (string/trim (:stdout result)) "")
      "No matches found."
      (:stdout result))))

(deftool list-files
  "List files and directories at the given path."
  {:path {:type :string
    :description "Directory path to list (default: current directory)"}}
  (lambda (path)
    (define target (if (= path "") "." path))
    (if (file/exists? target)
      (let ((entries (file/list target)))
        (string/join (sort entries) "\n"))
      (format "Error: Directory not found: ~a" target))))

(deftool run-command
  "Run a shell command and return its output. Use for: running tests, building projects,
git operations, installing packages, and other development tasks.
Do NOT use for: destructive operations like rm -rf, formatting disks, etc."
  {:command {:type :string
    :description "The shell command to run (e.g., 'cargo test', 'npm install')"}}
  (lambda (command)
    (unless (command-safe? command)
      (error (format "Blocked unsafe command: ~a" command)))
    (define result (shell "sh" "-c" command))
    (define output
      (string/append
        (if (= (:stdout result) "")
          ""
          (string/append "stdout:\n" (:stdout result)))
        (if (= (:stderr result) "")
          ""
          (string/append "\nstderr:\n" (:stderr result)))))
    (if (= (:exit-code result) 0)
      (if (= (string/trim output) "")
        "Command completed successfully (no output)."
        output)
      (format "~a\nExit code: ~a" output (:exit-code result)))))

;; ---- Agent definition ----

(defagent coder
  {:system (format
     "You are a coding assistant with access to the local filesystem.

Environment:
- Working directory: ~a
- Platform: ~a

Rules:
1. ALWAYS read a file before editing it — never guess at content
2. Use search to find relevant files before making changes
3. After editing, verify your changes (read the file or run tests)
4. Make minimal, focused changes — don't rewrite files unnecessarily
5. If a task is unclear, ask for clarification instead of guessing
6. When running commands, explain what you're doing and why

Workflow: search → read → edit → verify"
     cwd
     platform)
   :tools [read-file write-file edit-file search list-files run-command]
   :max-turns 50})

;; ---- Tool call display callback ----

(define active-spinner #f)

(define (on-tool-call event)
  (let ((evt   (:event event))
        (tool  (:tool event))
        (args  (:args event)))
    (cond
      ((= evt "start")
        ;; Show tool header
        (io/println-error
          (term/style (format "  ── ~a ──" tool) :bold :cyan))
        ;; Show key args (truncated)
        (when (map? args)
          (for-each
            (lambda (key)
              (let ((val (get args key)))
                (io/println-error
                  (format "     ~a: ~a"
                    (term/dim (keyword/to-string key))
                    (term/dim (truncate-str (format "~a" val) 60))))))
            (keys args)))
        ;; Start spinner
        (set! active-spinner
          (term/spinner-start (term/dim (format "  ~a..." tool)))))

      ((= evt "end")
        ;; Stop spinner with success
        (when active-spinner
          (term/spinner-stop active-spinner
            {:symbol (term/green "✔")
             :text (term/dim (format "~a (~ams)" tool (:duration-ms event)))})
          (set! active-spinner #f))
        (io/println-error "")))))

;; ---- Interactive REPL ----

(define prompt-str (term/style "sɛ̂ma ❯ " :bold :magenta))

(io/println-error "")
(io/println-error (term/style "  Coding Agent" :bold))
(io/println-error (term/dim (format "  Working directory: ~a" cwd)))
(io/println-error (term/dim "  Type your request, or 'quit' to exit."))
(io/println-error "")

(define history '())

(let loop ()
  (io/print-error prompt-str)
  (define input (io/read-line))
  (when
    (and (not (= input "quit"))
      (not (= input "exit"))
      (not (= input "")))
    (io/println-error "")
    (define result
      (agent/run coder
        input
        {:on-tool-call on-tool-call :messages history}))
    (set! history (:messages result))
    (println "")
    (println (:response result))
    (println "")
    (loop)))
