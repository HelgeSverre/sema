;; Verify ALL JSON code samples from http-json.md
;; (HTTP samples can't be tested without network)

(define (assert-eq actual expected label)
  (if (equal? actual expected)
    (println "  ✓ " label)
    (error (format "  ✗ ~a: expected ~a, got ~a" label expected actual))))

(println "=== http-json.md JSON verification ===")

;; json/encode
(assert-eq (json/encode 42) "42" "encode int")
(assert-eq (json/encode "hello") "\"hello\"" "encode string")
(assert-eq (json/encode #t) "true" "encode true")
(assert-eq (json/encode nil) "null" "encode nil")
(assert-eq (json/encode '(1 2 3)) "[1,2,3]" "encode list")
(assert-eq (json/encode [1 2 3]) "[1,2,3]" "encode vector")
(assert-eq (json/encode {:name "Ada" :age 36}) "{\"age\":36,\"name\":\"Ada\"}" "encode map")

;; json/encode errors
(try
  (json/encode (/ 0.0 0.0))
  (catch e (println "  ✓  encode NaN error caught")))

(try
  (json/encode println)
  (catch e (println "  ✓  encode function error caught")))

;; json/encode-pretty
(define pretty (json/encode-pretty {:name "Ada" :scores [95 87 92]}))
(assert-eq (string? pretty) #t "encode-pretty returns string")
(assert-eq (string/contains? pretty "\n") #t "encode-pretty has newlines")

;; json/decode
(assert-eq (json/decode "42") 42 "decode int")
(assert-eq (json/decode "3.14") 3.14 "decode float")
(assert-eq (json/decode "\"hello\"") "hello" "decode string")
(assert-eq (json/decode "true") #t "decode true")
(assert-eq (json/decode "null") nil "decode null")
(assert-eq (json/decode "[1, 2, 3]") '(1 2 3) "decode array")
(assert-eq (json/decode "{\"name\": \"Ada\"}") {:name "Ada"} "decode object")

;; json/decode errors
(try
  (json/decode "not json")
  (catch e (println "  ✓  decode invalid JSON error caught")))

(try
  (json/decode 42)
  (catch e (println "  ✓  decode non-string error caught")))

;; Roundtrips
(assert-eq (json/decode (json/encode [1 2 3])) '(1 2 3) "roundtrip vector->list")
(assert-eq (json/decode (json/encode {:a 1 :b 2})) {:a 1 :b 2} "roundtrip map")

;; Nested roundtrip
(define data {:users [{:name "Ada"} {:name "Bob"}]
              :count 2
              :active #t})
(define roundtripped (json/decode (json/encode data)))
(assert-eq (:count roundtripped) 2 "nested roundtrip :count")
(assert-eq (:active roundtripped) #t "nested roundtrip :active")

;; Error handling patterns
(try
  (json/encode (/ 0.0 0.0))
  (catch e (println "  ✓  error handling: encode catch")))

(try
  (json/decode "invalid json {{{")
  (catch e (println "  ✓  error handling: decode catch")))

(println "=== http-json.md JSON: ALL PASSED ===")
