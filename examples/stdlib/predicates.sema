;; stdlib-predicates.sema — Exercises all predicate / type-checking functions
;; Functions: null?, nil?, list?, vector?, number?, integer?, float?,
;;   string?, symbol?, keyword?, map?, bool?, fn?, char?, pair?,
;;   boolean?, procedure?, equal?, bytevector?, record?,
;;   prompt?, conversation?, promise?, promise-forced?, type

(define (assert-eq actual expected label)
  (if (equal? actual expected)
    (println "  ✓ " label)
    (error (format "  ✗ ~a: expected ~a, got ~a" label expected actual))))

(println "=== Predicate Functions ===")
(println)

;; --- null? ---
(println "null?  (empty list or nil):")
(println "  (null? '())     => " (null? '()))             ;; => #t
(println "  (null? nil)     => " (null? nil))             ;; => #t
(println "  (null? '(1 2))  => " (null? '(1 2)))         ;; => #f
(println "  (null? 0)       => " (null? 0))              ;; => #f
(assert-eq (null? '()) #t "(null? '()) = #t")
(assert-eq (null? '(1)) #f "(null? '(1)) = #f")
(println)

;; --- nil? ---
(println "nil?  (specifically nil value):")
(println "  (nil? nil)      => " (nil? nil))              ;; => #t
(println "  (nil? '())      => " (nil? '()))              ;; => #f (empty list ≠ nil)
(println "  (nil? 0)        => " (nil? 0))               ;; => #f
(assert-eq (nil? nil) #t "(nil? nil) = #t")
(assert-eq (nil? '()) #f "(nil? '()) = #f")
(println)

;; --- list? ---
(println "list?:")
(println "  (list? '(1 2 3)) => " (list? '(1 2 3)))     ;; => #t
(println "  (list? '())      => " (list? '()))            ;; => #t
(println "  (list? 42)       => " (list? 42))            ;; => #f
(println "  (list? \"hi\")     => " (list? "hi"))          ;; => #f
(assert-eq (list? '(1 2)) #t "(list? '(1 2)) = #t")
(assert-eq (list? 42) #f "(list? 42) = #f")
(println)

;; --- vector? ---
(println "vector?:")
(println "  (vector? [1 2 3]) => " (vector? [1 2 3]))   ;; => #t
(println "  (vector? [])      => " (vector? []))         ;; => #t
(println "  (vector? '(1 2))  => " (vector? '(1 2)))    ;; => #f
(println "  (vector? 42)      => " (vector? 42))         ;; => #f
(assert-eq (vector? [1 2]) #t "(vector? [1 2]) = #t")
(assert-eq (vector? '(1 2)) #f "(vector? '(1 2)) = #f")
(println)

;; --- number? ---
(println "number?:")
(println "  (number? 42)     => " (number? 42))          ;; => #t
(println "  (number? 3.14)   => " (number? 3.14))        ;; => #t
(println "  (number? \"42\")   => " (number? "42"))       ;; => #f
(println "  (number? #t)     => " (number? #t))          ;; => #f
(assert-eq (number? 42) #t "(number? 42) = #t")
(assert-eq (number? "42") #f "(number? \"42\") = #f")
(println)

;; --- integer? ---
(println "integer?:")
(println "  (integer? 42)    => " (integer? 42))         ;; => #t
(println "  (integer? 3.14)  => " (integer? 3.14))       ;; => #f
(println "  (integer? -7)    => " (integer? -7))         ;; => #t
(assert-eq (integer? 42) #t "(integer? 42) = #t")
(assert-eq (integer? 3.14) #f "(integer? 3.14) = #f")
(println)

;; --- float? ---
(println "float?:")
(println "  (float? 3.14)    => " (float? 3.14))         ;; => #t
(println "  (float? 42)      => " (float? 42))           ;; => #f
(println "  (float? 0.0)     => " (float? 0.0))          ;; => #t
(assert-eq (float? 3.14) #t "(float? 3.14) = #t")
(assert-eq (float? 42) #f "(float? 42) = #f")
(println)

;; --- string? ---
(println "string?:")
(println "  (string? \"hi\")   => " (string? "hi"))       ;; => #t
(println "  (string? \"\")     => " (string? ""))          ;; => #t
(println "  (string? 42)     => " (string? 42))          ;; => #f
(assert-eq (string? "hi") #t "(string? \"hi\") = #t")
(assert-eq (string? 42) #f "(string? 42) = #f")
(println)

;; --- symbol? ---
(println "symbol?:")
(println "  (symbol? 'foo)   => " (symbol? 'foo))        ;; => #t
(println "  (symbol? 42)     => " (symbol? 42))          ;; => #f
(println "  (symbol? \"foo\")  => " (symbol? "foo"))      ;; => #f
(assert-eq (symbol? 'foo) #t "(symbol? 'foo) = #t")
(assert-eq (symbol? 42) #f "(symbol? 42) = #f")
(println)

;; --- keyword? ---
(println "keyword?:")
(println "  (keyword? :foo)  => " (keyword? :foo))       ;; => #t
(println "  (keyword? :bar)  => " (keyword? :bar))       ;; => #t
(println "  (keyword? 'foo)  => " (keyword? 'foo))       ;; => #f
(println "  (keyword? \"foo\") => " (keyword? "foo"))     ;; => #f
(assert-eq (keyword? :foo) #t "(keyword? :foo) = #t")
(assert-eq (keyword? 'foo) #f "(keyword? 'foo) = #f")
(println)

;; --- map? ---
(println "map?:")
(println "  (map? {:a 1})    => " (map? {:a 1}))         ;; => #t
(println "  (map? {})        => " (map? {}))             ;; => #t
(println "  (map? '(1 2))    => " (map? '(1 2)))         ;; => #f
(println "  (map? 42)        => " (map? 42))             ;; => #f
(assert-eq (map? {:a 1}) #t "(map? {:a 1}) = #t")
(assert-eq (map? 42) #f "(map? 42) = #f")
(println)

;; --- bool? / boolean? ---
(println "bool? / boolean?:")
(println "  (bool? #t)       => " (bool? #t))            ;; => #t
(println "  (bool? #f)       => " (bool? #f))            ;; => #t
(println "  (bool? 1)        => " (bool? 1))             ;; => #f
(println "  (boolean? #t)    => " (boolean? #t))         ;; => #t
(println "  (boolean? 0)     => " (boolean? 0))          ;; => #f
(assert-eq (bool? #t) #t "(bool? #t) = #t")
(assert-eq (bool? 1) #f "(bool? 1) = #f")
(assert-eq (boolean? #f) #t "(boolean? #f) = #t")
(println)

;; --- fn? / procedure? ---
(println "fn? / procedure?:")
(define (my-fn x) x)
(println "  (fn? my-fn)      => " (fn? my-fn))           ;; => #t
(println "  (fn? +)          => " (fn? +))               ;; => #t (native fn)
(println "  (fn? 42)         => " (fn? 42))              ;; => #f
(println "  (procedure? my-fn) => " (procedure? my-fn))  ;; => #t
(println "  (procedure? +)     => " (procedure? +))      ;; => #t
(println "  (procedure? 42)    => " (procedure? 42))     ;; => #f
(assert-eq (fn? my-fn) #t "(fn? my-fn) = #t")
(assert-eq (fn? 42) #f "(fn? 42) = #f")
(assert-eq (procedure? +) #t "(procedure? +) = #t")
(println)

;; --- char? ---
(println "char?:")
(println "  (char? #\\a)     => " (char? #\a))            ;; => #t
(println "  (char? #\\space) => " (char? #\space))        ;; => #t
(println "  (char? \"a\")     => " (char? "a"))            ;; => #f
(println "  (char? 65)       => " (char? 65))            ;; => #f
(assert-eq (char? #\a) #t "(char? #\\a) = #t")
(assert-eq (char? "a") #f "(char? \"a\") = #f")
(println)

;; --- pair? ---
(println "pair?  (non-empty list):")
(println "  (pair? '(1 2))  => " (pair? '(1 2)))         ;; => #t
(println "  (pair? '(1))    => " (pair? '(1)))           ;; => #t
(println "  (pair? '())     => " (pair? '()))            ;; => #f (empty list)
(println "  (pair? 42)      => " (pair? 42))             ;; => #f
(assert-eq (pair? '(1 2)) #t "(pair? '(1 2)) = #t")
(assert-eq (pair? '()) #f "(pair? '()) = #f")
(println)

;; --- equal? ---
(println "equal?  (deep structural equality):")
(println "  (equal? 1 1)         => " (equal? 1 1))              ;; => #t
(println "  (equal? '(1 2) '(1 2)) => " (equal? '(1 2) '(1 2))) ;; => #t
(println "  (equal? \"a\" \"a\")     => " (equal? "a" "a"))        ;; => #t
(println "  (equal? '(1 2) '(1 3)) => " (equal? '(1 2) '(1 3))) ;; => #f
(println "  (equal? 1 1.0)        => " (equal? 1 1.0))           ;; => #f (different types)
(assert-eq (equal? '(1 2) '(1 2)) #t "(equal? '(1 2) '(1 2)) = #t")
(assert-eq (equal? '(1 2) '(1 3)) #f "(equal? '(1 2) '(1 3)) = #f")
(println)

;; --- bytevector? ---
(println "bytevector?:")
(println "  (bytevector? #u8(1 2 3)) => " (bytevector? #u8(1 2 3)))  ;; => #t
(println "  (bytevector? '(1 2 3))   => " (bytevector? '(1 2 3)))    ;; => #f
(println "  (bytevector? 42)         => " (bytevector? 42))          ;; => #f
(assert-eq (bytevector? #u8(1 2 3)) #t "(bytevector? #u8(1 2 3)) = #t")
(assert-eq (bytevector? 42) #f "(bytevector? 42) = #f")
(println)

;; --- record? ---
(println "record?:")
(define-record-type point (make-point x y) point? (x point-x) (y point-y))
(define p (make-point 3 4))
(println "  (record? (make-point 3 4)) => " (record? p))   ;; => #t
(println "  (record? 42)               => " (record? 42))  ;; => #f
(println "  (record? '(1 2))           => " (record? '(1 2))) ;; => #f
(assert-eq (record? p) #t "(record? point) = #t")
(assert-eq (record? 42) #f "(record? 42) = #f")
(println)

;; --- prompt? ---
(println "prompt?:")
(println "  (prompt? 42)     => " (prompt? 42))           ;; => #f
(println "  (prompt? \"hi\")   => " (prompt? "hi"))        ;; => #f
(println "  (prompt? #t)     => " (prompt? #t))           ;; => #f
(assert-eq (prompt? 42) #f "(prompt? 42) = #f")
(println)

;; --- conversation? ---
(println "conversation?:")
(println "  (conversation? 42) => " (conversation? 42))   ;; => #f
(println "  (conversation? '()) => " (conversation? '())) ;; => #f
(assert-eq (conversation? 42) #f "(conversation? 42) = #f")
(println)

;; --- promise? / promise-forced? ---
(println "promise? / promise-forced?:")
(define my-promise (delay (* 6 7)))
(println "  (promise? (delay ...))     => " (promise? my-promise))         ;; => #t
(println "  (promise? 42)              => " (promise? 42))                 ;; => #f
(println "  (promise-forced? my-promise) => " (promise-forced? my-promise)) ;; => #f
(force my-promise)
(println "  After (force my-promise):")
(println "  (promise-forced? my-promise) => " (promise-forced? my-promise)) ;; => #t
(assert-eq (promise? my-promise) #t "(promise? delay) = #t")
(assert-eq (promise? 42) #f "(promise? 42) = #f")
(assert-eq (promise-forced? my-promise) #t "(promise-forced? after force) = #t")
(println)

;; --- type ---
(println "type  (returns type as keyword):")
(println "  (type 42)        => " (type 42))              ;; => :int
(println "  (type 3.14)      => " (type 3.14))            ;; => :float
(println "  (type \"hi\")      => " (type "hi"))           ;; => :string
(println "  (type 'foo)      => " (type 'foo))            ;; => :symbol
(println "  (type :bar)      => " (type :bar))            ;; => :keyword
(println "  (type #t)        => " (type #t))              ;; => :bool
(println "  (type '(1 2))    => " (type '(1 2)))          ;; => :list
(println "  (type [1 2])     => " (type [1 2]))           ;; => :vector
(println "  (type {:a 1})    => " (type {:a 1}))          ;; => :map
(println "  (type #\\a)      => " (type #\a))              ;; => :char
(println "  (type nil)       => " (type nil))             ;; => :nil
(println "  (type +)         => " (type +))               ;; => :native-fn
(println "  (type my-fn)     => " (type my-fn))           ;; => :lambda
(println "  (type p)         => " (type p))               ;; => :point (record type tag)
(println "  (type #u8(1 2))  => " (type #u8(1 2)))        ;; => :bytevector
(assert-eq (type 42) :int "(type 42) = :int")
(assert-eq (type "hi") :string "(type \"hi\") = :string")
(assert-eq (type :bar) :keyword "(type :bar) = :keyword")
(println)

(println "Done!")
