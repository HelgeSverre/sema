;; modules-demo.sema — Module system, imports, error handling
;; Demonstrates: module/import, try/catch, defmacro, load

;; === Create helper modules ===

;; Math utilities module
(file/write "/tmp/sema-mod-math.sema"
  "(module math-utils (export factorial fibonacci prime? fizzbuzz)
     (define (factorial n)
       (let loop ((i n) (acc 1))
         (if (<= i 1) acc (loop (- i 1) (* acc i)))))

     (define (fibonacci n)
       (let loop ((i n) (a 0) (b 1))
         (if (= i 0) a (loop (- i 1) b (+ a b)))))

     (define (prime? n)
       (cond
         ((<= n 1) #f)
         ((= n 2) #t)
         ((even? n) #f)
         (else
           (let loop ((i 3))
             (cond
               ((> (* i i) n) #t)
               ((= 0 (math/remainder n i)) #f)
               (else (loop (+ i 2))))))))

     (define (fizzbuzz n)
       (cond
         ((= 0 (math/remainder n 15)) \"FizzBuzz\")
         ((= 0 (math/remainder n 3)) \"Fizz\")
         ((= 0 (math/remainder n 5)) \"Buzz\")
         (else (str n)))))")

;; String utilities module
(file/write "/tmp/sema-mod-string.sema"
  "(module string-utils (export slugify truncate word-wrap repeat-str)
     (define (slugify s)
       (string/lower
         (string/join
           (regex/find-all \"[a-zA-Z0-9]+\" s)
           \"-\")))

     (define (truncate s max-len)
       (if (<= (string-length s) max-len)
         s
         (string-append (substring s 0 (- max-len 3)) \"...\")))

     (define (word-wrap s width)
       (let loop ((words (string/split s \" \")) (line \"\") (lines '()))
         (if (null? words)
           (reverse (if (> (string-length line) 0) (cons line lines) lines))
           (let ((word (first words))
                 (rest-words (rest words)))
             (if (= (string-length line) 0)
               (loop rest-words word lines)
               (if (> (+ (string-length line) 1 (string-length word)) width)
                 (loop rest-words word (cons line lines))
                 (loop rest-words (string-append line \" \" word) lines)))))))

     (define (repeat-str s n)
       (string/repeat s n)))")

;; === Import and use ===
(import "/tmp/sema-mod-math.sema")
(import "/tmp/sema-mod-string.sema")

(println "=== Math Utilities ===")
(println (format "10! = ~a" (factorial 10)))
(println (format "fib(20) = ~a" (fibonacci 20)))

(define primes (filter prime? (range 2 50)))
(println (format "Primes under 50: ~a" primes))

(println "\nFizzBuzz 1-20:")
(println (format "  ~a"
  (string/join (map fizzbuzz (range 1 21)) " ")))

(println "\n=== String Utilities ===")
(println (format "slugify: ~a" (slugify "Hello World! This is Sema Lisp.")))
(println (format "truncate: ~a" (truncate "The quick brown fox jumps over the lazy dog" 25)))

(define long-text "The quick brown fox jumps over the lazy dog and continues running through the forest")
(println (format "\nWord wrap (width=30):"))
(for-each
  (fn (line) (println (format "  |~a|" (string/pad-right line 30))))
  (word-wrap long-text 30))

;; === Error Handling Patterns ===
(println "\n=== Error Handling ===")

;; Safe operations that return result maps
(define (safe-op name thunk)
  (try
    {:status :ok :value (thunk)}
    (catch e {:status :error :name name :error (:message e)})))

(define results
  (list
    (safe-op "divide-ok" (fn () (/ 10 3)))
    (safe-op "divide-zero" (fn () (/ 10 0)))
    (safe-op "parse-ok" (fn () (int "42")))
    (safe-op "parse-fail" (fn () (int "abc")))
    (safe-op "list-ok" (fn () (nth (list 1 2 3) 1)))
    (safe-op "list-oob" (fn () (nth (list 1 2 3) 10)))))

(for-each
  (fn (r)
    (if (= (get r :status) :ok)
      (println (format "  ✓ ~a" (get r :value)))
      (println (format "  ✗ ~a: ~a" (get r :name) (get r :error)))))
  results)

;; === Macro-based Mini DSL ===
(println "\n=== Config DSL ===")

(defmacro defconfig (name . pairs)
  `(define ,name (hash-map ,@pairs)))

(defconfig db-config
  :host "localhost"
  :port 5432
  :name "sema_db"
  :pool-size 10)

(defconfig app-config
  :debug #t
  :version "2.0.0"
  :log-level "info")

(println (format "DB: ~a:~a/~a" (get db-config :host) (get db-config :port) (get db-config :name)))
(println (format "App version: ~a (debug=~a)" (get app-config :version) (get app-config :debug)))

;; === Selective Import ===
(file/write "/tmp/sema-mod-selective.sema"
  "(module selective (export public-fn secret-fn)
     (define (public-fn) \"I am public\")
     (define (secret-fn) \"I am also exported\")
     (define (private-fn) \"I am private\"))")

(import "/tmp/sema-mod-selective.sema" public-fn)
(println (format "\nSelective import: ~a" (public-fn)))

;; Verify private is not accessible
(try
  (begin
    (eval '(secret-fn))
    (println "ERROR: secret-fn should not be available"))
  (catch e
    (println (format "Correctly blocked: ~a" (:type e)))))

;; Clean up
(file/delete "/tmp/sema-mod-math.sema")
(file/delete "/tmp/sema-mod-string.sema")
(file/delete "/tmp/sema-mod-selective.sema")

(println "\nDone!")
