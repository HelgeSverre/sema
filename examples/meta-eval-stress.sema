;; meta-eval-stress.sema — Stress-test the meta-circular interpreter
;; by running real algorithms from the Sema example suite through it.
;;
;; Load the interpreter first, then run programs and check results.

(load "meta-eval.sema")

;; ============================================================
;; Test harness
;; ============================================================

(define tests-passed 0)
(define tests-failed 0)
(define tests-total 0)

(define (test name expected program)
  (set! tests-total (+ tests-total 1))
  (let ((result
         (try
           (let ((val (run-program program)))
             {:ok val})
           (catch e {:error (:message e)}))))
    (cond
      ((and (get result :ok)
            (equal? (get result :ok) expected))
       (set! tests-passed (+ tests-passed 1))
       (println (format "  PASS  ~a = ~a" name expected)))
      ((get result :error)
       (set! tests-failed (+ tests-failed 1))
       (println (format "  FAIL  ~a — error: ~a" name (get result :error))))
      (else
       (set! tests-failed (+ tests-failed 1))
       (println (format "  FAIL  ~a — expected ~a, got ~a"
         name expected (get result :ok)))))))

(println)
(println "=== Meta-Eval Stress Tests ===")
(println)

;; ============================================================
;; 1. TAK benchmark (from benchmarks/tak.sema)
;; ============================================================
(println "--- TAK Benchmark ---")
(test "tak(18,12,6)" 7
  "(define (tak x y z)
     (if (not (< y x))
       z
       (tak (tak (- x 1) y z)
            (tak (- y 1) z x)
            (tak (- z 1) x y))))
   (tak 18 12 6)")

(test "tak(10,5,2)" 5  ;; Sema uses integer division, result is 5
  "(define (tak x y z)
     (if (not (< y x))
       z
       (tak (tak (- x 1) y z)
            (tak (- y 1) z x)
            (tak (- z 1) x y))))
   (tak 10 5 2)")

;; ============================================================
;; 2. N-Queens (adapted — no named let, no inner define)
;; ============================================================
(println)
(println "--- N-Queens (adapted) ---")
(test "nqueens(1)" 1
  "(define (one-to-helper i l)
     (if (= i 0) l (one-to-helper (- i 1) (cons i l))))

   (define (ok? row dist placed)
     (if (null? placed)
       #t
       (and (not (= (car placed) (+ row dist)))
            (not (= (car placed) (- row dist)))
            (ok? row (+ dist 1) (cdr placed)))))

   (define (try-it x y z)
     (if (null? x)
       (if (null? y) 1 0)
       (+ (if (ok? (car x) 1 z)
            (try-it (append (cdr x) y) '() (cons (car x) z))
            0)
          (try-it (cdr x) (cons (car x) y) z))))

   (define (nqueens n)
     (try-it (one-to-helper n '()) '() '()))

   (nqueens 1)")

(test "nqueens(4)" 2
  "(define (one-to-helper i l)
     (if (= i 0) l (one-to-helper (- i 1) (cons i l))))

   (define (ok? row dist placed)
     (if (null? placed)
       #t
       (and (not (= (car placed) (+ row dist)))
            (not (= (car placed) (- row dist)))
            (ok? row (+ dist 1) (cdr placed)))))

   (define (try-it x y z)
     (if (null? x)
       (if (null? y) 1 0)
       (+ (if (ok? (car x) 1 z)
            (try-it (append (cdr x) y) '() (cons (car x) z))
            0)
          (try-it (cdr x) (cons (car x) y) z))))

   (define (nqueens n)
     (try-it (one-to-helper n '()) '() '()))

   (nqueens 4)")

(test "nqueens(5)" 10
  "(define (one-to-helper i l)
     (if (= i 0) l (one-to-helper (- i 1) (cons i l))))

   (define (ok? row dist placed)
     (if (null? placed)
       #t
       (and (not (= (car placed) (+ row dist)))
            (not (= (car placed) (- row dist)))
            (ok? row (+ dist 1) (cdr placed)))))

   (define (try-it x y z)
     (if (null? x)
       (if (null? y) 1 0)
       (+ (if (ok? (car x) 1 z)
            (try-it (append (cdr x) y) '() (cons (car x) z))
            0)
          (try-it (cdr x) (cons (car x) y) z))))

   (define (nqueens n)
     (try-it (one-to-helper n '()) '() '()))

   (nqueens 5)")

;; ============================================================
;; 3. Ackermann function (from scheme-algorithms.sema)
;; ============================================================
(println)
(println "--- Ackermann Function ---")
(test "ackermann(0,0)" 1
  "(define (ackermann m n)
     (cond
       ((= m 0) (+ n 1))
       ((= n 0) (ackermann (- m 1) 1))
       (else (ackermann (- m 1) (ackermann m (- n 1))))))
   (ackermann 0 0)")

(test "ackermann(3,4)" 125
  "(define (ackermann m n)
     (cond
       ((= m 0) (+ n 1))
       ((= n 0) (ackermann (- m 1) 1))
       (else (ackermann (- m 1) (ackermann m (- n 1))))))
   (ackermann 3 4)")

;; ============================================================
;; 4. Church Numerals (from scheme-algorithms.sema)
;; ============================================================
(println)
(println "--- Church Numerals ---")
(test "church: 0" 0
  "(define church-zero (fn (f) (fn (x) x)))
   (define (church-succ n) (fn (f) (fn (x) (f ((n f) x)))))
   (define (church->int n) ((n (fn (x) (+ x 1))) 0))
   (church->int church-zero)")

(test "church: 2+3=5" 5
  "(define church-zero (fn (f) (fn (x) x)))
   (define (church-succ n) (fn (f) (fn (x) (f ((n f) x)))))
   (define (church-add a b) (fn (f) (fn (x) ((a f) ((b f) x)))))
   (define (church->int n) ((n (fn (x) (+ x 1))) 0))
   (define one (church-succ church-zero))
   (define two (church-succ one))
   (define three (church-succ two))
   (church->int (church-add two three))")

(test "church: 2*3=6" 6
  "(define church-zero (fn (f) (fn (x) x)))
   (define (church-succ n) (fn (f) (fn (x) (f ((n f) x)))))
   (define (church-mul a b) (fn (f) (a (b f))))
   (define (church->int n) ((n (fn (x) (+ x 1))) 0))
   (define one (church-succ church-zero))
   (define two (church-succ one))
   (define three (church-succ two))
   (church->int (church-mul two three))")

(test "church: zero? zero" "true"
  "(define church-zero (fn (f) (fn (x) x)))
   (define (church-succ n) (fn (f) (fn (x) (f ((n f) x)))))
   (define church-true  (fn (a b) a))
   (define church-false (fn (a b) b))
   (define (church-if c t f) (c t f))
   (define (church-zero? n) ((n (fn (x) church-false)) church-true))
   (define three (church-succ (church-succ (church-succ church-zero))))
   (church-if (church-zero? church-zero) \"true\" \"false\")")

(test "church: zero? three" "false"
  "(define church-zero (fn (f) (fn (x) x)))
   (define (church-succ n) (fn (f) (fn (x) (f ((n f) x)))))
   (define church-true  (fn (a b) a))
   (define church-false (fn (a b) b))
   (define (church-if c t f) (c t f))
   (define (church-zero? n) ((n (fn (x) church-false)) church-true))
   (define three (church-succ (church-succ (church-succ church-zero))))
   (church-if (church-zero? three) \"true\" \"false\")")

;; ============================================================
;; 5. CPS Transformations (from scheme-algorithms.sema)
;; ============================================================
(println)
(println "--- CPS Transformations ---")
(test "cps factorial(10)" 3628800
  "(define (fact-cps n k)
     (if (= n 0)
       (k 1)
       (fact-cps (- n 1) (fn (result) (k (* n result))))))
   (fact-cps 10 (fn (x) x))")

(test "cps fibonacci(10)" 55
  "(define (fib-cps n k)
     (if (< n 2)
       (k n)
       (fib-cps (- n 1)
         (fn (r1)
           (fib-cps (- n 2)
             (fn (r2) (k (+ r1 r2))))))))
   (fib-cps 10 (fn (x) x))")

(test "cps product with short-circuit" 0
  "(define (product-cps lst k)
     (cond
       ((null? lst) (k 1))
       ((= (car lst) 0) 0)
       (else (product-cps (cdr lst) (fn (rest) (k (* (car lst) rest)))))))
   (product-cps '(1 2 0 4 5) (fn (x) x))")

(test "cps product normal" 120
  "(define (product-cps lst k)
     (cond
       ((null? lst) (k 1))
       ((= (car lst) 0) 0)
       (else (product-cps (cdr lst) (fn (rest) (k (* (car lst) rest)))))))
   (product-cps '(1 2 3 4 5) (fn (x) x))")

;; ============================================================
;; 6. BST (adapted — replace cadr/caddr, no foldl)
;; ============================================================
(println)
(println "--- Binary Search Tree (adapted) ---")
(test "bst insert + inorder" '(1 2 3 4 5)
  "(define (make-leaf v) (list v '() '()))
   (define (make-node v left right) (list v left right))
   (define (tree-value t) (car t))
   (define (tree-left t) (car (cdr t)))
   (define (tree-right t) (car (cdr (cdr t))))

   (define (bst-insert tree val)
     (if (null? tree)
       (make-leaf val)
       (let ((v (tree-value tree)))
         (cond
           ((< val v) (make-node v (bst-insert (tree-left tree) val) (tree-right tree)))
           ((> val v) (make-node v (tree-left tree) (bst-insert (tree-right tree) val)))
           (else tree)))))

   (define (tree-inorder tree)
     (if (null? tree)
       '()
       (append (tree-inorder (tree-left tree))
               (append (list (tree-value tree))
                       (tree-inorder (tree-right tree))))))

   (define t (bst-insert (bst-insert (bst-insert (bst-insert (bst-insert '() 3) 1) 4) 5) 2))
   (tree-inorder t)")

;; ============================================================
;; 7. Mergesort (adapted — no let*, no cadr, no math/quotient)
;; ============================================================
(println)
(println "--- Mergesort (adapted) ---")
;; Mergesort — interpreter has no TCO so each meta-eval call deepens
;; Sema's own call stack. 4 elements works; larger lists hit depth limit.
(test "mergesort(4)" '(1 2 3 4)
  "(define (merge xs ys)
     (cond
       ((null? xs) ys)
       ((null? ys) xs)
       ((<= (car xs) (car ys))
        (cons (car xs) (merge (cdr xs) ys)))
       (else
        (cons (car ys) (merge xs (cdr ys))))))

   (define (take-n lst n)
     (if (or (= n 0) (null? lst)) '()
       (cons (car lst) (take-n (cdr lst) (- n 1)))))

   (define (drop-n lst n)
     (if (or (= n 0) (null? lst)) lst
       (drop-n (cdr lst) (- n 1))))

   (define (mergesort lst)
     (if (or (null? lst) (null? (cdr lst)))
       lst
       (let ((half (/ (length lst) 2)))
         (merge (mergesort (take-n lst half))
                (mergesort (drop-n lst half))))))

   (mergesort '(4 2 3 1))")

;; ============================================================
;; 8. Y-Combinator — the ultimate lambda calculus test
;; ============================================================
(println)
(println "--- Y-Combinator ---")
(test "Y factorial(5)" 120
  "(define (Y f)
     ((fn (x) (f (fn (v) ((x x) v))))
      (fn (x) (f (fn (v) ((x x) v))))))

   (define factorial
     (Y (fn (self)
          (fn (n)
            (if (<= n 1) 1 (* n (self (- n 1))))))))

   (factorial 5)")

(test "Y fibonacci(10)" 55
  "(define (Y f)
     ((fn (x) (f (fn (v) ((x x) v))))
      (fn (x) (f (fn (v) ((x x) v))))))

   (define fib
     (Y (fn (self)
          (fn (n)
            (if (< n 2) n (+ (self (- n 1)) (self (- n 2))))))))

   (fib 10)")

;; ============================================================
;; 9. Mutual recursion (even?/odd?)
;; ============================================================
(println)
(println "--- Mutual Recursion ---")
(test "even?(10)" #t
  "(define (my-even? n) (if (= n 0) #t (my-odd? (- n 1))))
   (define (my-odd? n)  (if (= n 0) #f (my-even? (- n 1))))
   (my-even? 10)")

(test "odd?(7)" #t
  "(define (my-even? n) (if (= n 0) #t (my-odd? (- n 1))))
   (define (my-odd? n)  (if (= n 0) #f (my-even? (- n 1))))
   (my-odd? 7)")

;; ============================================================
;; 10. Deep closure nesting
;; ============================================================
(println)
(println "--- Deep Closure Nesting ---")
(test "triple-adder(1)(2)(3)" 6
  "(define (triple-adder a)
     (fn (b) (fn (c) (+ a (+ b c)))))
   (((triple-adder 1) 2) 3)")

(test "compose functions" 20
  "(define (compose f g) (fn (x) (f (g x))))
   (define (double x) (* x 2))
   (define (add3 x) (+ x 3))
   (define double-then-add3 (compose add3 double))
   (define add3-then-double (compose double add3))
   (add3-then-double 7)")

;; ============================================================
;; 11. List algorithms written in interpreted Lisp
;; ============================================================
(println)
(println "--- List Algorithms ---")
(test "flatten nested lists" '(1 2 3 4 5 6)
  "(define (my-append a b)
     (if (null? a) b
       (cons (car a) (my-append (cdr a) b))))

   (define (flatten lst)
     (cond
       ((null? lst) '())
       ((pair? (car lst))
        (my-append (flatten (car lst)) (flatten (cdr lst))))
       (else (cons (car lst) (flatten (cdr lst))))))

   (flatten '((1 2) (3 (4 5)) 6))")

(test "zip two lists" '((1 4) (2 5) (3 6))
  "(define (my-zip a b)
     (if (or (null? a) (null? b)) '()
       (cons (list (car a) (car b))
             (my-zip (cdr a) (cdr b)))))
   (my-zip '(1 2 3) '(4 5 6))")

(test "range via accumulator" '(0 1 2 3 4)
  "(define (range-helper i n acc)
     (if (= i n) acc
       (range-helper (+ i 1) n (append acc (list i)))))
   (range-helper 0 5 '())")

;; ============================================================
;; 12. Previously missing features — now implemented
;; ============================================================
(println)
(println "--- Named Let ---")
(test "named let sum" 55
  "(let loop ((i 10) (acc 0))
     (if (= i 0) acc (loop (- i 1) (+ acc i))))")

(test "named let fibonacci" 55
  "(let fib ((n 10) (a 0) (b 1))
     (if (= n 0) a (fib (- n 1) b (+ a b))))")

(test "named let one-to-n" '(1 2 3 4 5)
  "(let loop ((i 5) (acc '()))
     (if (= i 0) acc (loop (- i 1) (cons i acc))))")

(println)
(println "--- Set! ---")
(test "set! simple" 42
  "(define x 0)
   (set! x 42)
   x")

(test "set! counter" 3
  "(define counter 0)
   (set! counter (+ counter 1))
   (set! counter (+ counter 1))
   (set! counter (+ counter 1))
   counter")

(test "set! in closure" 3
  "(define (make-counter)
     (define n 0)
     (lambda () (set! n (+ n 1)) n))
   (define c (make-counter))
   (c) (c) (c)")

(println)
(println "--- Variadic Lambda ---")
(test "variadic all rest" '(1 2 3)
  "((fn (. args) args) 1 2 3)")

(test "variadic with fixed" '(1 (2 3 4))
  "(define (f x . rest) (list x rest))
   (f 1 2 3 4)")

(test "variadic apply-like" 10
  "(define (sum . nums)
     (if (null? nums) 0
       (+ (car nums)
          (let ((rest (cdr nums)))
            (if (null? rest) 0
              (+ (car rest)
                 (let ((rest2 (cdr rest)))
                   (if (null? rest2) 0
                     (+ (car rest2)
                        (let ((rest3 (cdr rest2)))
                          (if (null? rest3) 0 (car rest3))))))))))))
   (sum 1 2 3 4)")

;; ============================================================
;; Summary
;; ============================================================
(println)
(println (format "=== Results: ~a/~a passed, ~a failed ===" tests-passed tests-total tests-failed))
