;; closure-storm.sema â€” Closure allocation and dispatch benchmark
;; Tests: MAKE_CLOSURE allocation overhead, closure call dispatch.
;;
;; Usage: sema examples/benchmarks/closure-storm.sema

(println "=== Closure Storm Benchmark ===")

;; --- Part 1: Create and immediately call closures in a tight loop ---
(println "Part 1: Create + immediate call (500,000 iterations)")

(define t0 (time-ms))
(define result1
  (let loop ((i 0) (acc 0))
    (if (= i 500000)
        acc
        (let ((f (fn (x) (+ x i))))
          (loop (+ i 1) (+ acc (f i)))))))
(define elapsed1 (- (time-ms) t0))

(println (format "Result: ~a" result1))
(println (format "500,000 create+call in ~a ms" elapsed1))

;; --- Part 2: Build a list of closures, then call them all ---
(println "")
(println "Part 2: Build list of 5,000 closures, call all, repeat 10 times")

(define (build-closures n)
  (let loop ((i 0) (acc '()))
    (if (= i n)
        acc
        (loop (+ i 1) (cons (fn () i) acc)))))

(define (call-all closures)
  (let loop ((cs closures) (acc 0))
    (if (null? cs)
        acc
        (loop (cdr cs) (+ acc ((car cs)))))))

(define t1 (time-ms))
(define result2
  (let loop ((iter 0) (v 0))
    (if (= iter 10)
        v
        (let ((closures (build-closures 5000)))
          (loop (+ iter 1) (call-all closures))))))
(define elapsed2 (- (time-ms) t1))

(println (format "Result: ~a" result2))
(println (format "10 iterations (50,000 closures total) in ~a ms" elapsed2))

;; --- Part 3: Higher-order closure composition ---
(println "")
(println "Part 3: Closure composition chain (500,000 iterations)")

(define (compose f g)
  (fn (x) (f (g x))))

(define inc (fn (x) (+ x 1)))
(define dbl (fn (x) (* x 2)))
(define inc-then-dbl (compose dbl inc))

(define t2 (time-ms))
(define result3
  (let loop ((i 0) (acc 0))
    (if (= i 500000)
        acc
        (loop (+ i 1) (+ acc (inc-then-dbl i))))))
(define elapsed3 (- (time-ms) t2))

(println (format "Result: ~a" result3))
(println (format "500,000 composed closure calls in ~a ms" elapsed3))
