;; roman-numerals.sema — Roman numeral converter with roundtrip validation
;; Demonstrates: recursion, string ops, maps, named let, formatted output

(println "=== Roman Numeral Converter ===\n")

;; Ordered pairs of (value, numeral) for subtractive notation
(define roman-table
  (list (list 1000 "M")
    (list 900 "CM")
    (list 500 "D")
    (list 400 "CD")
    (list 100 "C")
    (list 90 "XC")
    (list 50 "L")
    (list 40 "XL")
    (list 10 "X")
    (list 9 "IX")
    (list 5 "V")
    (list 4 "IV")
    (list 1 "I")))

;; Integer to Roman numeral
(define (int->roman n)
  (let loop ((n n) (table roman-table) (acc ""))
    (if (or (null? table) (= n 0))
      acc
      (let ((value   (first (first table)))
            (symbol  (nth (first table) 1)))
        (if (>= n value)
          (loop (- n value) table (string-append acc symbol))
          (loop n (rest table) acc))))))

;; Roman numeral character values
(define roman-chars (hash-map :I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000))

(define (roman-char-value ch)
  (get roman-chars (string->keyword (string/upper (char->string ch)))))

;; Roman numeral to integer
(define (roman->int s)
  (let ((chars (string/chars s)))
    (let loop ((chars chars) (total 0))
      (if (null? chars)
        total
        (let ((current (roman-char-value (first chars)))
              (next
                (if (null? (rest chars))
                  0
                  (roman-char-value (first (rest chars))))))
          (if (< current next)
            (loop (rest chars) (- total current))
            (loop (rest chars) (+ total current))))))))

;; --- Conversion Table ---
(println "=== Conversion Table ===\n")

(define test-numbers (list 1 4 9 42 99 399 1776 1999 2024 3999))

(println
  (format "  ~a  ~a  ~a"
    (string/pad-right "Integer" 9)
    (string/pad-right "Roman" 16)
    "Back"))
(println
  (format "  ~a  ~a  ~a"
    (string/repeat "─" 9)
    (string/repeat "─" 16)
    (string/repeat "─" 7)))

(for-each
  (fn (n)
    (let* ((roman  (int->roman n))
           (back   (roman->int roman)))
      (println
        (format "  ~a  ~a  ~a"
          (string/pad-right (str n) 9)
          (string/pad-right roman 16)
          back))))
  test-numbers)

;; --- Roundtrip Validation ---
(println "\n=== Roundtrip Validation ===\n")

(define (validate n)
  (let* ((roman  (int->roman n))
         (back   (roman->int roman)))
    (list n roman back (= n back))))

(define results   (map validate test-numbers))
(define all-pass  (every (fn (r) (nth r 3)) results))

(for-each
  (fn (r)
    (println
      (format "  ~a → ~a → ~a  ~a"
        (string/pad-right (str (first r)) 5)
        (string/pad-right (nth r 1) 15)
        (string/pad-right (str (nth r 2)) 5)
        (if (nth r 3) "✓" "✗"))))
  results)

(println
  (format "\n  All ~a tests passed: ~a"
    (length results)
    (if all-pass "YES ✓" "NO ✗")))

;; --- Bonus: range check ---
(println "\n=== Multiples of 400 ===\n")
(for-each
  (fn (n)
    (println
      (format "  ~a = ~a"
        (string/pad-left (str n) 5)
        (int->roman n))))
  (filter (fn (n) (= 0 (mod n 400))) (range 400 4000)))

(println "\nDone!")
