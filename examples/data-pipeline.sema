;; data-pipeline.sema — CSV processing, data transformation, and analysis
;; Demonstrates: csv, maps, lists, strings, math, sorting, threading, f-strings

;; --- Sample CSV data ---
(define csv-data "name,age,score,city
Alice,32,95,Berlin
Bob,28,82,London
Charlie,35,91,Berlin
Diana,24,78,Paris
Eve,31,99,London
Frank,29,85,Berlin
Grace,27,73,Paris
Henry,33,88,London")

;; --- Parse into structured maps ---
(define records (csv/parse-maps csv-data))
(println f"Loaded ${(length records)} records")

;; --- Convert ages and scores to numbers ---
(define typed-records
  (map (fn (r)
    (assoc r
      :age (int (get r :age))
      :score (int (get r :score))))
    records))

;; --- Basic statistics ---
(define ages (map #(get % :age) typed-records))
(define scores (map #(get % :score) typed-records))

(define avg-age (/ (foldl + 0 ages) (float (length ages))))
(define avg-score (/ (foldl + 0 scores) (float (length scores))))
(define max-score (apply max scores))
(define min-score (apply min scores))

(println f"Average age: ${(round avg-age)}")
(println f"Average score: ${(round avg-score)}")
(println f"Score range: ${min-score} - ${max-score}")

;; --- Group by city ---
(define by-city (list/group-by #(get % :city) typed-records))
(println "\nPer-city breakdown:")
(for-each
  (fn (entry)
    (let (([city people] entry))
      (let* ((city-scores (map #(get % :score) people))
             (city-avg (/ (foldl + 0 city-scores) (float (length city-scores)))))
        (println f"  ${city}: ${(length people)} people, avg score ${(round city-avg)}"))))
  (map/entries by-city))

;; --- Top performers (score >= 90) ---
(define top-performers
  (filter #(>= (get % :score) 90) typed-records))
(println (format "\nTop performers (score >= 90): ~a"
  (string/join (map #(format "~a (~a)" (get % :name) (get % :score)) top-performers) ", ")))

;; --- Sort by score descending ---
(define ranked
  (sort typed-records (fn (a b) (- (get b :score) (get a :score)))))
(println "\nRanking:")
(for-each
  (fn (r)
    (println (format "  ~a. ~a — ~a pts"
      (string/pad-left (str (+ 1 (list/index-of ranked r))) 2)
      (string/pad-right (get r :name) 8)
      (get r :score))))
  ranked)

;; --- Export filtered data back to CSV ---
(define export-rows
  (->> ranked
    (map (fn (r)
      (let ((score (get r :score)))
        (list (get r :name)
              (str score)
              (cond ((>= score 90) "A")
                    ((>= score 80) "B")
                    ((>= score 70) "C")
                    (else "D"))))))
    (cons '("name" "score" "grade"))))

(define exported-csv (csv/encode export-rows))
(println "\nExported CSV:")
(println exported-csv)

(println "Done!")
