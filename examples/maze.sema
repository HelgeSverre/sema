;;; maze.sema — ASCII maze generator
;;;
;;; Uses iterative randomized depth-first search with an explicit stack
;;; to carve a perfect maze, then renders it as ASCII art.
;;;
;;; Demonstrates: named let, maps as sparse grids, higher-order functions,
;;;               random number generation, string building

(define width 30)
(define height 15)

;;; --- Utilities ---

;; Encode (x, y) as a string key for map lookup
(define (pos x y) (str x "," y))

;; Shuffle a list by repeatedly extracting a random element
(define (shuffle lst)
  (if (<= (length lst) 1)
    lst
    (let* ((i (math/random-int 0 (- (length lst) 1)))
           (picked (nth lst i))
           (rest (append (take i lst) (drop (+ i 1) lst))))
      (cons picked (shuffle rest)))))

;;; --- Maze generation ---
;;;
;;; The maze lives on a (2W+1) × (2H+1) rendering grid.
;;; Cells sit at odd coordinates (2x+1, 2y+1); walls fill the gaps.
;;; We store passable positions in a map: "gx,gy" -> #t
;;; and carve passages via randomized depth-first traversal
;;; with an explicit stack to avoid Rust stack overflow.

(define directions (list (list 0 -1) (list 0 1) (list -1 0) (list 1 0)))

;; Find unvisited neighbors of cell (cx, cy) in random order
(define (unvisited-neighbors grid cx cy)
  (filter
    (fn (entry)
      (let ((nx (car entry)) (ny (cadr entry)))
        (and (>= nx 0) (< nx width)
             (>= ny 0) (< ny height)
             (not (get grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #f)))))
    (map (fn (dir)
           (list (+ cx (car dir)) (+ cy (cadr dir)) (car dir) (cadr dir)))
         (shuffle directions))))

;; Iterative depth-first maze carving
;; Stack is a list of (cx cy) cells to backtrack to.
;; Grid is a map of "gx,gy" -> #t for open positions.
(define (generate-maze)
  (let loop ((stack (list (list 0 0)))
             (grid (assoc {} (pos 1 1) #t)))
    (if (null? stack)
      grid
      (let* ((cell (car stack))
             (cx (car cell))
             (cy (cadr cell))
             (neighbors (unvisited-neighbors grid cx cy)))
        (if (null? neighbors)
          ;; Backtrack
          (loop (cdr stack) grid)
          ;; Pick the first unvisited neighbor (already shuffled)
          (let* ((next (car neighbors))
                 (nx (car next))
                 (ny (cadr next))
                 (dx (nth next 2))
                 (dy (nth next 3))
                 ;; Open the neighbor cell
                 (grid (assoc grid (pos (+ (* nx 2) 1) (+ (* ny 2) 1)) #t))
                 ;; Open the wall between current and neighbor
                 (grid (assoc grid (pos (+ (* cx 2) 1 dx) (+ (* cy 2) 1 dy)) #t)))
            ;; Push current cell back (for backtracking) and new cell on top
            (loop (cons (list nx ny) stack) grid)))))))

;;; --- Rendering ---

(define grid-w (+ (* 2 width) 1))
(define grid-h (+ (* 2 height) 1))

(define (render grid)
  (for-each
    (fn (y)
      (println
        (string/join
          (map (fn (x)
                 (if (get grid (pos x y) #f) "  " "##"))
               (range grid-w))
          "")))
    (range grid-h)))

;;; --- Main ---

(println (str "Generating " width "×" height " maze...\n"))
(render (generate-maze))
