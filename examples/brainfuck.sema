;; brainfuck.sema — A Brainfuck interpreter written in Sema
;; Demonstrates: string manipulation, mutable state, recursion, maps as tape

(println "=== Brainfuck Interpreter ===\n")

;; --- Tape operations (map of index -> value) ---
(define tape (hash-map))
(define ptr 0)

(define (tape-get t p) (get t p 0))
(define (tape-set t p v) (assoc t p v))

;; --- Find matching bracket ---
(define (find-matching-bracket program pos dir)
  (let loop ((p (+ pos dir)) (depth 1))
    (let ((ch (string-ref program p)))
      (cond
        ((and (= ch #\[) (= dir 1)) (loop (+ p dir) (+ depth 1)))
        ((and (= ch #\]) (= dir -1)) (loop (+ p dir) (+ depth 1)))
        ((and (= ch #\]) (= dir 1))
          (if (= depth 1) p (loop (+ p dir) (- depth 1))))
        ((and (= ch #\[) (= dir -1))
          (if (= depth 1) p (loop (+ p dir) (- depth 1))))
        (else (loop (+ p dir) depth))))))

;; --- Execute a BF program ---
(define (bf-run program)
  (define tape (hash-map))
  (define ptr 0)
  (define output "")
  (let loop ((ip 0) (tape tape) (ptr ptr) (output output))
    (if (>= ip (string-length program))
      output
      (let ((ch (string-ref program ip)))
        (cond
          ;; > move pointer right
          ((= ch #\>) (loop (+ ip 1) tape (+ ptr 1) output))

          ;; < move pointer left
          ((= ch #\<) (loop (+ ip 1) tape (- ptr 1) output))

          ;; + increment cell
          ((= ch #\+)
            (loop (+ ip 1)
              (tape-set tape ptr (mod (+ (tape-get tape ptr) 1) 256))
              ptr
              output))

          ;; - decrement cell
          ((= ch #\-)
            (loop (+ ip 1)
              (tape-set tape ptr (mod (+ (tape-get tape ptr) 255) 256))
              ptr
              output))

          ;; . output cell as char
          ((= ch #\.)
            (loop (+ ip 1)
              tape
              ptr
              (string-append output
                (char->string (integer->char (tape-get tape ptr))))))

          ;; , input (not supported — set cell to 0)
          ((= ch #\,) (loop (+ ip 1) (tape-set tape ptr 0) ptr output))

          ;; [ jump forward if zero
          ((= ch #\[)
            (if (= (tape-get tape ptr) 0)
              (loop (find-matching-bracket program ip 1) tape ptr output)
              (loop (+ ip 1) tape ptr output)))

          ;; ] jump back if non-zero
          ((= ch #\])
            (if (not (= (tape-get tape ptr) 0))
              (loop (find-matching-bracket program ip -1) tape ptr output)
              (loop (+ ip 1) tape ptr output)))

          ;; skip other characters
          (else (loop (+ ip 1) tape ptr output)))))))

;; --- Run classic BF programs ---

(println "--- Hello World ---")
(define hello-bf
  "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.")
(define hello-result (bf-run hello-bf))
(println (format "Output: ~a" hello-result))

(println "\n--- Counting 0-9 ---")
;; Prints digits 0 through 9: set cell to 48 (ASCII '0') then print incrementing
(define count-bf
  "++++++++++++++++++++++++++++++++++++++++++++++++.+.+.+.+.+.+.+.+.+.")
(define count-result (bf-run count-bf))
(println (format "Output: ~a" count-result))

(println "\n--- Exclamation Marks ---")
;; Prints "!!!" — ASCII 33 = 3*11
(define excl-bf "+++[>+++++++++++<-]>.")
(define excl-result (bf-run excl-bf))
(println
  (format "Output: ~a (ASCII ~a)"
    excl-result
    (char->integer (string-ref excl-result 0))))

(println "\n--- Alphabet (A-Z) ---")
;; Set cell to 65 (ASCII 'A') then print 26 chars
(define alpha-bf
  "++++++++[>++++++++<-]>+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.")
(define alpha-result (bf-run alpha-bf))
(println (format "Output: ~a" alpha-result))

(println "\n--- Multiply 3 × 7 ---")
;; Computes 3*7 = 21, adds 48 to get ASCII '3' (48+21=69='E')...
;; Actually: store 3 in [0], multiply with 7 into [1], add 48, print
(define mul-bf
  "+++[>+++++++<-]>++++++++++++++++++++++++++++++++++++++++++++++++.")
(define mul-result (bf-run mul-bf))
(println
  (format "3 × 7 = ~a (char: ~a)"
    (- (char->integer (string-ref mul-result 0)) 48)
    mul-result))

(println "\n--- Nested Loop Test ---")
;; Uses nested loops: 3 outer × 4 inner = 12, prints as '0'+12 = '<'
(define nested-bf
  "+++[>++++[>+<-]<-]>>++++++++++++++++++++++++++++++++++++++++++++++++.")
(define nested-result (bf-run nested-bf))
(println
  (format "3 × 4 = ~a (char: ~a)"
    (- (char->integer (string-ref nested-result 0)) 48)
    nested-result))

(println "\n--- Program Stats ---")
(define programs
  (list (list "Hello World" hello-bf)
    (list "Counter" count-bf)
    (list "Alphabet" alpha-bf)))
(for-each
  (fn (p)
    (let* ((name (first p))
           (code (nth p 1))
           (len (string-length code))
           (loops (length (filter (fn (c) (= c #\[)) (string->list code)))))
      (println
        (format "  ~a: ~a chars, ~a loops"
          (string/pad-right name 14)
          len
          loops))))
  programs)

(println "\nDone!")
