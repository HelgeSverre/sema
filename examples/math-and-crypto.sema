;; math-and-crypto.sema — Math, crypto, base64, UUID, bitwise operations
;; Demonstrates: math/*, bit/*, uuid, base64, hash, time

;; --- Prime sieve ---
(define (sieve-primes n)
  (let loop ((candidates (range 2 n)) (primes '()))
    (if (null? candidates)
      (reverse primes)
      (let ((p (first candidates)))
        (loop
          (filter (fn (x) (not (= 0 (math/remainder x p)))) (rest candidates))
          (cons p primes))))))

(define primes-100 (sieve-primes 100))
(println (format "Primes under 100 (~a total):" (length primes-100)))
(println (format "  ~a" (string/join (map str primes-100) " ")))

;; --- GCD/LCM chain ---
(println (format "\ngcd(12, 8) = ~a" (math/gcd 12 8)))
(println (format "lcm(12, 8) = ~a" (math/lcm 12 8)))
(println (format "gcd(gcd(48, 36), 24) = ~a" (math/gcd (math/gcd 48 36) 24)))

;; --- Trigonometric identity: sin^2(x) + cos^2(x) = 1 ---
(define test-angles (list 0.0 0.5 1.0 1.5 2.0 pi))
(println "\nVerifying sin²(x) + cos²(x) = 1:")
(for-each
  (fn (x)
    (let ((s (sin x)) (c (cos x)))
      (let ((sum (+ (* s s) (* c c))))
        (println
          (format "  x=~a → ~a ✓"
            (string/pad-right (str (round (* x 100))) 4)
            sum)))))
  test-angles)

;; --- Exponential/logarithm roundtrip ---
(println "\nexp(log(x)) roundtrip:")
(for-each
  (fn (x)
    (let ((result (math/exp (log x))))
      (println (format "  exp(log(~a)) = ~a" x result))))
  (list 1 2 5 10 100))

;; --- Bitwise operations: IP address parsing ---
(define (ip-to-int a b c d)
  (bit/or (bit/or (bit/shift-left a 24) (bit/shift-left b 16))
    (bit/or (bit/shift-left c 8) d)))

(define (int-to-ip n)
  (format "~a.~a.~a.~a"
    (bit/and (bit/shift-right n 24) 255)
    (bit/and (bit/shift-right n 16) 255)
    (bit/and (bit/shift-right n 8) 255)
    (bit/and n 255)))

(define ip-int (ip-to-int 192 168 1 100))
(println (format "\nIP address packing:"))
(println (format "  192.168.1.100 → ~a" ip-int))
(println (format "  ~a → ~a" ip-int (int-to-ip ip-int)))

;; Subnet mask
(define (cidr-mask bits)
  (bit/shift-left (- (bit/shift-left 1 bits) 1) (- 32 bits)))

(define mask-24 (cidr-mask 24))
(println (format "  /24 mask: ~a" (int-to-ip mask-24)))
(println (format "  network:  ~a" (int-to-ip (bit/and ip-int mask-24))))

;; --- UUID generation ---
(println "\nGenerated UUIDs:")
(for-each
  (fn (_) (println (format "  ~a" (uuid/v4))))
  (range 3))

;; --- Base64 encoding ---
(define messages (list "Hello, World!" "Sema Lisp rocks" "data: 42"))
(println "\nBase64 encoding:")
(for-each
  (fn (msg)
    (let ((encoded (base64/encode msg)))
      (let ((decoded (base64/decode encoded)))
        (println
          (format "  ~a → ~a → ~a ~a"
            (string/pad-right msg 20)
            (string/pad-right encoded 28)
            decoded
            (if (= msg decoded) "✓" "✗"))))))
  messages)

;; --- SHA-256 hashing ---
(println "\nSHA-256 hashes:")
(define hash-inputs (list "" "hello" "Hello" "hello world" "Sema"))
(for-each
  (fn (input)
    (println
      (format "  sha256(~a) = ~a"
        (string/pad-right (format "\"~a\"" input) 15)
        (substring (hash/sha256 input) 0 16))))
  hash-inputs)

;; Hash chain: H(H(H("seed")))
(define (hash-chain seed n)
  (let loop ((h seed) (i 0))
    (if (= i n)
      h
      (loop (hash/sha256 h) (+ i 1)))))

(define chain-result (hash-chain "seed" 3))
(println
  (format "\n  3x hash chain of \"seed\": ~a..." (substring chain-result 0 16)))

;; --- Timing ---
(define start (time-ms))
(define _result (sieve-primes 10000))
(define elapsed (- (time-ms) start))
(println
  (format "\nPrimes under 10000: ~a primes found in ~ams"
    (length _result)
    elapsed))

;; --- Random sampling ---
(println "\n5 random numbers [1, 100]:")
(for-each
  (fn (_) (display (format "  ~a" (math/random-int 1 100))))
  (range 5))
(println "")

;; --- Clamping ---
(println "\nClamping values to [0, 100]:")
(for-each
  (fn (v)
    (println
      (format "  clamp(~a) = ~a"
        (string/pad-left (str v) 4)
        (math/clamp v 0 100))))
  (list -50 0 42 99 100 150))

(println "\nDone!")
