;; http-router.sema — HTTP request routing with pattern matching
;; Demonstrates: match on nested maps, guards, {:keys} destructuring, f-strings

(define users
  (list {:id 1 :name "Alice" :role :admin}
    {:id 2 :name "Bob" :role :user}
    {:id 3 :name "Carol" :role :user}))

(define (find-user id)
  (list/find #(= (get % :id) id) users))

(define (handle-request req)
  (match
    req
    ;; GET /users/:id — specific user (must come before catch-all GET)
    ({:method :GET :path "/users" :id id} when
      (find-user id)
      {:status 200 :body (find-user id)})

    ;; GET /users/:id — not found
    ({:method :GET :path "/users" :id id}
      {:status 404 :body f"User ${id} not found"})

    ;; GET /users — list all
    ({:method :GET :path "/users"} {:status 200 :body users})

    ;; POST /users — create (destructure body)
    ({:method :POST :path "/users" :body {:keys [name]}}
      {:status 201 :body f"Created user: ${name}"})

    ;; DELETE — admin only (nested map destructuring + guard)
    ({:method :DELETE :path "/users" :id id :user {:keys [role]}} when
      (= role :admin)
      {:status 200 :body f"Deleted user ${id}"})

    ;; DELETE — unauthorized
    ({:method :DELETE} {:status 403 :body "Forbidden: admin only"})

    ;; Catch-all
    (_ {:status 404 :body "Not found"})))

;; Format and print a request/response pair
(define (show req)
  (let (({:keys [method path]} req)
        ({:keys [status body]} (handle-request req)))
    (println f"  ${method} ${path} → ${status}: ${body}")))

(println "=== HTTP Router ===\n")

(define requests
  (list {:method :GET :path "/users"}
    {:method :GET :path "/users" :id 1}
    {:method :GET :path "/users" :id 99}
    {:method :POST :path "/users" :body {:name "Dave"}}
    {:method :DELETE :path "/users" :id 2 :user {:role :admin}}
    {:method :DELETE :path "/users" :id 2 :user {:role :user}}
    {:method :GET :path "/about"}))

(for-each
  show
  requests)
