;; ascii-art.sema — ASCII art generators and visualizations
;; Usage: sema examples/ascii-art.sema

(define t-start (time-ms))

;; ============================================================
;; 1. Sierpinski Triangle (Pascal's triangle mod 2)
;; ============================================================
(println "=== 1. Sierpinski Triangle ===\n")

(define sierpinski-rows 16)

;; Build next row of Pascal's triangle
(define (pascal-next row)
  (let loop ((i 0) (acc '()))
    (if (> i (length row))
      (reverse acc)
      (let ((left   (if (= i 0) 0 (nth row (- i 1))))
            (right  (if (= i (length row)) 0 (nth row i))))
        (loop (+ i 1) (cons (+ left right) acc))))))

;; Build all rows
(define (pascal-rows n)
  (let loop ((i 1) (current '(1)) (acc (list '(1))))
    (if (= i n)
      acc
      (let ((next (pascal-next current)))
        (loop (+ i 1) next (append acc (list next)))))))

(define rows (pascal-rows sierpinski-rows))

(for-each
  (fn (row)
    (let ((padding (string/repeat " " (- sierpinski-rows (length row)))))
      (display padding)
      (for-each
        (fn (val)
          (if (= 0 (mod val 2))
            (display "  ")
            (display "* ")))
        row)
      (println "")))
  rows)

;; ============================================================
;; 2. Diamond Pattern
;; ============================================================
(println "\n=== 2. Diamond Pattern ===\n")

(define diamond-size 9)

(define (print-diamond n)
  (let ((half (/ (- n 1) 2)))
    ;; Top half including middle
    (let loop-top ((i 0))
      (when (<= i half)
        (let ((spaces  (- half i))
              (stars   (+ 1 (* 2 i))))
          (display (string/repeat " " spaces))
          (println (string/repeat "*" stars)))
        (loop-top (+ i 1))))
    ;; Bottom half
    (let loop-bot ((i (- half 1)))
      (when (>= i 0)
        (let ((spaces  (- half i))
              (stars   (+ 1 (* 2 i))))
          (display (string/repeat " " spaces))
          (println (string/repeat "*" stars)))
        (loop-bot (- i 1))))))

(print-diamond diamond-size)

;; ============================================================
;; 3. ASCII Sine Wave
;; ============================================================
(println "\n=== 3. ASCII Sine Wave ===\n")

(define wave-cols  60)
(define wave-rows  21)
(define wave-mid   (/ (- wave-rows 1) 2))

;; Precompute which column each row's '*' goes in for each x
;; We'll iterate row by row
(let loop-row ((row 0))
  (when (< row wave-rows)
    (let ((line
            (let loop-col ((col 0) (acc ""))
              (if (>= col wave-cols)
                acc
                (let* ((x (* (/ col (- wave-cols 1.0)) (* 4.0 pi)))
                       (y (sin x))
                       ;; Map y from [-1,1] to [0, wave-rows-1] (inverted)
                       (target-row (round (* (- 1.0 y) 0.5 (- wave-rows 1)))))
                  (cond
                    ((and (= row (round target-row)))
                      (loop-col (+ col 1) (string/append acc "*")))
                    ((and (= row wave-mid) (= col 0))
                      (loop-col (+ col 1) (string/append acc "+")))
                    ((= row wave-mid)
                      (loop-col (+ col 1) (string/append acc "-")))
                    ((= col 0) (loop-col (+ col 1) (string/append acc "|")))
                    (else (loop-col (+ col 1) (string/append acc " ")))))))))
      (println line))
    (loop-row (+ row 1))))

;; ============================================================
;; 4. Circle (distance formula)
;; ============================================================
(println "\n=== 4. Circle ===\n")

(define circle-w   40)
(define circle-h   21)
(define circle-cx  (/ (- circle-w 1) 2.0))
(define circle-cy  (/ (- circle-h 1) 2.0))
(define circle-r   9.5)

(let loop-y ((y 0))
  (when (< y circle-h)
    (let loop-x ((x 0) (acc ""))
      (if (>= x circle-w)
        (begin
          (println acc)
          (loop-y (+ y 1)))
        (let* ((dx (- x circle-cx))
               (dy (* (- y circle-cy) 2.0))
               ;; stretch for char aspect ratio
               (dist (sqrt (+ (* dx dx) (* dy dy))))
               (diff (abs (- dist circle-r))))
          (if (< diff 1.2)
            (loop-x (+ x 1) (string/append acc "#"))
            (loop-x (+ x 1) (string/append acc " "))))))))

;; ============================================================
;; 5. Bar Chart
;; ============================================================
(println "\n=== 5. Bar Chart ===\n")

(define chart-data
  (list (list "Rust" 85)
    (list "Python" 72)
    (list "JavaScript" 68)
    (list "Go" 54)
    (list "Sema" 95)
    (list "Haskell" 42)
    (list "C" 61)))

(define max-bar-width 40)

;; Find max value
(define chart-max
  (foldl (fn (mx item) (if (> (nth item 1) mx) (nth item 1) mx))
    0
    chart-data))

;; Find max label length
(define max-label-len
  (foldl
    (fn (mx item)
      (if (> (string/length (nth item 0)) mx)
        (string/length (nth item 0))
        mx))
    0
    chart-data))

(for-each
  (fn (item)
    (let* ((label         (nth item 0))
           (value         (nth item 1))
           (bar-len       (round (* (/ value (+ chart-max 0.0)) max-bar-width)))
           (bar           (string/repeat "█" bar-len))
           (padded-label  (string/pad-right label (+ max-label-len 1))))
      (println (format "  ~a|~a ~a" padded-label bar value))))
  chart-data)

;; ============================================================
;; 6. Histogram (random distribution)
;; ============================================================
(println "\n=== 6. Histogram (500 random numbers, 0-9) ===\n")

(define num-samples 500)
(define num-buckets 10)

;; Generate random numbers and count buckets
(define buckets
  (let loop ((i 0) (counts (map (fn (_) 0) (range num-buckets))))
    (if (>= i num-samples)
      counts
      (let* ((val (math/random-int 0 (- num-buckets 1)))
             (new-counts
               (map
                 (fn (j)
                   (if (= j val)
                     (+ (nth counts j) 1)
                     (nth counts j)))
                 (range num-buckets))))
        (loop (+ i 1) new-counts)))))

;; Find max bucket for scaling
(define hist-max (foldl (fn (mx v) (if (> v mx) v mx)) 0 buckets))

;; Print vertical histogram (top to bottom)
(define hist-height 15)

(let loop-row ((row hist-height))
  (when (> row 0)
    (let ((threshold (* (/ row (+ hist-height 0.0)) hist-max)))
      (display "  ")
      (for-each
        (fn (i)
          (let ((count (nth buckets i)))
            (if (>= count threshold)
              (display " ██")
              (display "   "))))
        (range num-buckets))
      (println ""))
    (loop-row (- row 1))))

;; X-axis
(display "  ")
(for-each
  (fn (i) (display (format " ~a " (string/pad-left (str i) 2))))
  (range num-buckets))
(println "")

;; Counts
(display "  ")
(for-each
  (fn (i) (display (format "~a " (string/pad-left (str (nth buckets i)) 3))))
  (range num-buckets))
(println "")

;; ============================================================
;; 7. Box Drawing
;; ============================================================
(println "\n=== 7. Box Drawing ===\n")

(define (draw-box lines)
  (let* ((max-len
           (foldl (fn (mx l) (if (> (string/length l) mx) (string/length l) mx))
             0
             lines))
         (width (+ max-len 2))
         (top (string/append "┌" (string/repeat "─" width) "┐"))
         (bot (string/append "└" (string/repeat "─" width) "┘")))
    (println (format "  ~a" top))
    (for-each
      (fn (line)
        (println (format "  │ ~a │" (string/pad-right line max-len))))
      lines)
    (println (format "  ~a" bot))))

(draw-box
  (list
    "╔═══════════════════════╗"
    "║   ASCII Art in Sema   ║"
    "╚═══════════════════════╝"))

(println "")

(draw-box
  (list "Sema — Lisp with LLM primitives"
    "Written in Rust"
    "github.com/HelgeSverre/sema"))

;; ============================================================
;; Timing
;; ============================================================
(println (format "\n✨ All sections complete in ~ams" (- (time-ms) t-start)))
