;; l-system.sema — L-system string rewriting and ASCII rendering
;; Demonstrates: recursion, maps, string processing, functional iteration

(println "=== L-System String Rewriting ===\n")

;; Apply production rules to a single character
(define (apply-char rules ch)
  (let ((replacement (get rules (string->keyword (char->string ch)))))
    (if (nil? replacement) (char->string ch) replacement)))

;; Rewrite an entire string using rules
(define (apply-rules str rules)
  (string/join (map (fn (ch) (apply-char rules ch)) (string/chars str)) ""))

;; Iterate the L-system N times, collecting each generation
(define (iterate-lsystem axiom rules n)
  (let loop ((current axiom) (i 0) (history (list axiom)))
    (if (= i n)
      history
      (let ((next (apply-rules current rules)))
        (loop next (+ i 1) (append history (list next)))))))

;; Print iterations with lengths
(define (show-lsystem name axiom rules n)
  (println (format "--- ~a ---" name))
  (let ((generations (iterate-lsystem axiom rules n)))
    (for-each
      (fn (i)
        (let ((gen (nth generations i)))
          (if (<= (string-length gen) 60)
            (println (format "  ~a: ~a" i gen))
            (println
              (format "  ~a: [~a chars] ~a..."
                i
                (string-length gen)
                (substring gen 0 55))))))
      (range (+ n 1)))
    (println "")))

;; 1. Algae: A→AB, B→A
(show-lsystem "Algae (A→AB, B→A)"
  "A"
  {:A "AB" :B "A"}
  7)

;; 2. Binary tree: 1→11, 0→1[0]0
(show-lsystem "Binary Tree (1→11, 0→1[0]0)"
  "0"
  {:1 "11" :0 "1[0]0"}
  5)

;; 3. Sierpinski triangle: A→B-A-B, B→A+B+A
(show-lsystem "Sierpinski (A→B-A-B, B→A+B+A)"
  "A"
  {:A "B-A-B" :B "A+B+A"}
  6)

;; 4. Dragon curve: X→X+YF+, Y→-FX-Y
(show-lsystem "Dragon Curve (X→X+YF+, Y→-FX-Y)"
  "FX"
  {:X "X+YF+" :Y "-FX-Y"}
  8)

;; === Simple ASCII Rendering for Sierpinski ===
(println "=== Sierpinski ASCII Rendering ===\n")

;; Simplified: A and B = forward, + = turn left 60°, - = turn right 60°
;; We render a flat projection: F moves in current direction, just track x position
;; For a quick visual, render the string as-is with highlighting

(define sierpinski-gen (last (iterate-lsystem "A" {:A "B-A-B" :B "A+B+A"} 4)))

;; Replace A/B with draw chars for visual clarity
(define rendered
  (string/replace (string/replace sierpinski-gen "A" "▲") "B" "▲"))

;; Wrap into lines of 64 chars for display
(define (wrap-string s width)
  (let loop ((remaining s) (lines '()))
    (if (<= (string-length remaining) width)
      (reverse (cons remaining lines))
      (loop (substring remaining width)
        (cons (substring remaining 0 width) lines)))))

(for-each
  println
  (wrap-string rendered 64))

;; Show growth statistics
(println "\n=== Growth Statistics ===\n")

(define (show-growth name axiom rules n)
  (let ((gens (iterate-lsystem axiom rules n)))
    (println (format "~a:" name))
    (for-each
      (fn (i)
        (let ((len (string-length (nth gens i))))
          (println
            (format "  Gen ~a: ~a chars ~a"
              (string/pad-left (str i) 2)
              (string/pad-left (str len) 8)
              (string/repeat "█" (min 40 (int (/ len 10))))))))
      (range (+ n 1)))
    (println "")))

(show-growth "Algae" "A" {:A "AB" :B "A"} 10)
(show-growth "Sierpinski" "A" {:A "B-A-B" :B "A+B+A"} 8)

(println "Done!")
