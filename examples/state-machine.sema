;; state-machine.sema â€” Finite state machines using maps

(println "=== Finite State Machines ===\n")

;; --- Traffic Light FSM ---
(println "--- Traffic Light ---\n")

(define traffic-fsm
  (hash-map
    "red" (hash-map "next" "green" "duration" 5)
    "green" (hash-map "next" "yellow" "duration" 4)
    "yellow" (hash-map "next" "red" "duration" 1)))

(define traffic-labels
  (hash-map "red" "ðŸ”´ RED" "green" "ðŸŸ¢ GREEN" "yellow" "ðŸŸ¡ YELLOW"))

(defun traffic-step (state)
  (get-in traffic-fsm [state "next"]))

(defun run-traffic (state steps)
  (when (> steps 0)
    (let ((label     (get traffic-labels state))
          (duration  (get-in traffic-fsm [state "duration"])))
      (println f"  ${label}  (duration: ${duration}s)")
      (run-traffic (traffic-step state) (- steps 1)))))

(println "Traffic light running for 9 transitions:")
(run-traffic "red" 9)

;; --- Vending Machine FSM ---
(println "\n--- Vending Machine ---\n")

(define vending-fsm
  (hash-map
    "idle"
      (hash-map
        "coin" "selecting"
        "on-enter" "Waiting for coins...")
    "selecting"
      (hash-map
        "select" "dispensing"
        "cancel" "idle"
        "on-enter" "Choose your item!")
    "dispensing"
      (hash-map
        "done" "idle"
        "on-enter" "Dispensing your item...")))

(defun vending-transition (state event)
  (if-let (next (get-in vending-fsm [state event]))
    (let ((enter-msg (get-in vending-fsm [next "on-enter"])))
      (println f"  ${state} --[${event}]--> ${next}: ${enter-msg}")
      next)
    (begin
      (println f"  âš  No transition for '${event}' in state '${state}'")
      state)))

(defun run-vending (state events)
  (if (null? events)
    (println f"  Final state: ${state}")
    (let ((next (vending-transition state (car events))))
      (run-vending next (cdr events)))))

(println "Scenario 1: Buy an item")
(let ((enter-msg (get-in vending-fsm ["idle" "on-enter"])))
  (println f"  [start] idle: ${enter-msg}"))
(run-vending "idle" '("coin" "select" "done"))

(println "\nScenario 2: Cancel after inserting coin")
(println "  [start] idle")
(run-vending "idle" '("coin" "cancel"))

(println "\nScenario 3: Invalid event")
(println "  [start] idle")
(run-vending "idle" '("select"))

;; --- Generic FSM runner ---
(println "\n--- Generic FSM: Door ---\n")

(define door-fsm
  (hash-map
    "locked" (hash-map "unlock" "closed")
    "closed"
      (hash-map
        "open" "open"
        "lock" "locked")
    "open" (hash-map "close" "closed")))

(defun fsm-run (fsm state events)
  (if (null? events)
    state
    (let* ((event  (car events))
           (next   (get-in fsm [state event])))
      (if-let (next next)
        (begin
          (println f"  ${state} --[${event}]--> ${next}")
          (fsm-run fsm next (cdr events)))
        (begin
          (println f"  âœ— Invalid: ${state} --[${event}]--> ???")
          state)))))

(define door-events '("unlock" "open" "close" "lock" "unlock" "open"))
(println f"Events: ${door-events}")
(define final (fsm-run door-fsm "locked" door-events))
(println f"Final state: ${final}")

(println "\n=== Done ===")
