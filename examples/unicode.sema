;; unicode.sema â€” Unicode-aware string operations
;; Demonstrates: byte-length, codepoints, normalization, case folding

;; --- Byte length vs character length ---
(println "=== Byte Length vs Character Length ===")
(define samples (list "hello" "hÃ©llo" "æ—¥æœ¬èª" "ğŸ‰ğŸŠ" "Î©â‰ˆÃ§"))
(for-each
  (fn (s)
    (println
      (format "  ~a  chars=~a  bytes=~a"
        (string/pad-right (string/append "\"" s "\"") 12)
        (string/length s)
        (string/byte-length s))))
  samples)

;; --- Codepoints roundtrip ---
(println "\n=== Codepoints ===")
(define text  "CafÃ© â˜•")
(define cps   (string/codepoints text))
(println (format "  String:     ~a" text))
(println (format "  Codepoints: ~a" cps))
(println (format "  Roundtrip:  ~a" (string/from-codepoints cps)))

;; Build a string from known codepoints
(define hello-greek (string/from-codepoints (list 915 949 953 945))) ;; Î“ÎµÎ¹Î±
(println (format "  Greek hello: ~a" hello-greek))

;; --- Unicode normalization ---
(println "\n=== Normalization ===")

;; NFC: combine e + combining acute â†’ Ã©
(define decomposed  (string/append "e" "\u0301"))
(define composed    (string/normalize decomposed :nfc))
(println
  (format "  Decomposed: ~a  (length=~a)" decomposed (string/length decomposed)))
(println
  (format "  NFC:        ~a  (length=~a)" composed (string/length composed)))

;; NFD: decompose Ã© â†’ e + combining acute
(define nfd (string/normalize "Ã©" :nfd))
(println (format "  NFD of Ã©:   length=~a (decomposed)" (string/length nfd)))

;; NFKC: compatibility decomposition + composition
(define ligature "\uFB01") ;; ï¬ ligature
(define compat (string/normalize ligature :nfkc))
(println (format "  NFKC of ï¬:  ~a (ligature â†’ letters)" compat))

;; --- Case folding and case-insensitive comparison ---
(println "\n=== Case Folding ===")
(define words (list "HELLO" "World" "StraÃŸe" "Î©ÎœÎ•Î“Î‘"))
(for-each
  (fn (w)
    (println
      (format "  ~a â†’ ~a"
        (string/pad-right w 10)
        (string/foldcase w))))
  words)

(println "\n=== Case-Insensitive Comparison ===")
(define pairs
  (list (list "Hello" "hello")
    (list "CAFÃ‰" "cafÃ©")
    (list "hello" "world")))
(for-each
  (fn (pair)
    (let ((a (first pair)) (b (nth pair 1)))
      (println
        (format "  (string-ci=? ~s ~s) => ~a"
          a
          b
          (string-ci=? a b)))))
  pairs)

(println "\nDone!")
