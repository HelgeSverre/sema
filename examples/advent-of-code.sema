;; advent-of-code.sema — Bite-sized AoC-style puzzles solved in Sema
;; Demonstrates: lists, maps, strings, folds, higher-order functions

;; ============================
;; Puzzle 1: Calorie Counting
;; ============================
(println "=== Puzzle 1: Calorie Counting ===\n")

(define elf-calories
  '((1000 2000 3000) (4000)
    (5000 6000)
    (7000 8000 9000)
    (10000)))

(define totals         (map (fn (elf) (foldl + 0 elf)) elf-calories))
(define sorted-totals  (sort totals (fn (a b) (- b a))))
(define max-elf        (first sorted-totals))
(define top3-sum       (foldl + 0 (take 3 sorted-totals)))

(println (format "Elf totals: ~a" totals))
(println (format "Max single elf: ~a" max-elf))
(println (format "Top 3 combined: ~a" top3-sum))

;; ============================
;; Puzzle 2: Rock Paper Scissors
;; ============================
(println "\n=== Puzzle 2: Rock Paper Scissors ===\n")

(define rounds '(("A" "Y") ("B" "X") ("C" "Z") ("A" "X") ("B" "Z") ("C" "Y")))

(define shape-score {:X 1 :Y 2 :Z 3})
;; X=Rock, Y=Paper, Z=Scissors vs A=Rock, B=Paper, C=Scissors
(define outcome-map
  {
   ;; draws
   :AX 3
   :BY 3
   :CZ 3
   ;; wins
   :AY 6
   :BZ 6
   :CX 6
   ;; losses
   :AZ 0
   :BX 0
   :CY 0})

(define (score-round round)
  (let ((opp (first round))
        (you (nth round 1)))
    (let ((key    (string->keyword (string-append opp you)))
          (shape  (get shape-score (string->keyword you))))
      (+ shape (get outcome-map key)))))

(define round-scores  (map score-round rounds))
(define total-score   (foldl + 0 round-scores))

(for-each
  (fn (i)
    (let ((r (nth rounds i)) (s (nth round-scores i)))
      (println (format "  ~a vs ~a → ~a pts" (first r) (nth r 1) s))))
  (range (length rounds)))
(println (format "Total score: ~a" total-score))

;; ============================
;; Puzzle 3: Pangram Checker
;; ============================
(println "\n=== Puzzle 3: Pangram Checker ===\n")

(define (pangram? text)
  (let ((lower     (string/lower text))
        (alphabet  "abcdefghijklmnopqrstuvwxyz"))
    (every (fn (ch) (string/contains? lower (char->string ch)))
      (string/chars alphabet))))

(define test-strings
  (list "The quick brown fox jumps over the lazy dog"
    "Hello World"
    "Pack my box with five dozen liquor jugs"
    "abcdefghijklmnopqrstuvwxyz"
    "Almost but missing the letter z"))

(for-each
  (fn (s)
    (println
      (format "  ~a → ~a"
        (if (> (string-length s) 40) (string-append (substring s 0 37) "...") s)
        (if (pangram? s) "✓ pangram" "✗ not a pangram"))))
  test-strings)

;; ============================
;; Puzzle 4: Number Spelling
;; ============================
(println "\n=== Puzzle 4: Number Word Sum ===\n")

(define number-words
  {:one 1
   :two 2
   :three 3
   :four 4
   :five 5
   :six 6
   :seven 7
   :eight 8
   :nine 9
   :ten 10})

(define words-input
  (list "three"
    "cats"
    "ate"
    "five"
    "fish"
    "and"
    "two"
    "pies"
    "plus"
    "one"
    "cake"
    "and"
    "ten"
    "grapes"))

(define (word->number w)
  (get number-words (string->keyword w)))

(define found-numbers
  (filter (fn (v) (not (nil? v)))
    (map word->number words-input)))

(println (format "Input:   ~a" (string/join words-input " ")))
(println (format "Found:   ~a" found-numbers))
(println (format "Sum:     ~a" (foldl + 0 found-numbers)))

(println "\nDone!")
