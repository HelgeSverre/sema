;; commands.sema — Slash commands for pi-sema coding agent REPL
;;
;; Parses and dispatches /commands typed at the prompt.
;; Each handler receives the current state map and returns
;; an updated state (or 'quit to exit).

(load "util.sema")
(load "display.sema")
(load "session.sema")
(load "compact.sema")

;; ============================================================
;; Section 1: Command Parsing
;; ============================================================

(define (slash-command? input)
  "Return #t if input starts with /."
  (string/starts-with? (string/trim input) "/"))

(define (parse-command input)
  "Parse \"/command arg1 arg2\" into {:name \"command\" :args \"arg1 arg2\"}."
  (let* ((trimmed (string/trim input))
         (without-slash (substring trimmed 1 (string-length trimmed)))
         (parts (string/split without-slash " "))
         (name (car parts))
         (rest (cdr parts))
         (args (string/trim (string/join rest " "))))
    {:name name :args args}))

;; ============================================================
;; Section 2: Command Dispatch
;; ============================================================

(define (dispatch-command cmd state)
  "Dispatch a parsed command to its handler. Returns updated state or 'quit."
  (let ((name (get cmd :name ""))
        (args (get cmd :args "")))
    (cond
      ((equal? name "help")    (cmd-help state))
      ((equal? name "clear")   (cmd-clear state))
      ((equal? name "model")   (cmd-model args state))
      ((equal? name "compact") (cmd-compact state))
      ((equal? name "session") (cmd-session args state))
      ((equal? name "usage")   (cmd-usage state))
      ((equal? name "status")  (cmd-status state))
      ((equal? name "plan")    (cmd-plan args state))
      ((equal? name "approve") (cmd-approve state))
      ((equal? name "next")    (cmd-next state))
      ((equal? name "consensus") (cmd-consensus args state))
      ((equal? name "quit")    'quit)
      ((equal? name "exit")    'quit)
      (else
        (show-error (format "Unknown command: /~a. Type /help for available commands." name))
        state))))

;; ============================================================
;; Section 3: /help
;; ============================================================

(define (cmd-help state)
  (println-error "")
  (println-error (term/style "  Commands:" :bold))
  (println-error (format "    ~a  Show this help"
    (term/cyan (format "~a" "/help            "))))
  (println-error (format "    ~a  Clear conversation history"
    (term/cyan (format "~a" "/clear           "))))
  (println-error (format "    ~a  Show or switch model"
    (term/cyan (format "~a" "/model [name]    "))))
  (println-error (format "    ~a  Compact conversation context"
    (term/cyan (format "~a" "/compact         "))))
  (println-error "")
  (println-error (term/style "  Plan Mode:" :bold))
  (println-error (format "    ~a  Investigate and create a plan"
    (term/cyan (format "~a" "/plan <goal>     "))))
  (println-error (format "    ~a  Show current plan"
    (term/cyan (format "~a" "/plan show       "))))
  (println-error (format "    ~a  Discard plan, return to normal"
    (term/cyan (format "~a" "/plan clear      "))))
  (println-error (format "    ~a  Approve plan, start execution"
    (term/cyan (format "~a" "/approve         "))))
  (println-error (format "    ~a  Execute next batch of steps"
    (term/cyan (format "~a" "/next            "))))
  (println-error "")
  (println-error (term/style "  Sessions:" :bold))
  (println-error (format "    ~a  List saved sessions"
    (term/cyan (format "~a" "/session list    "))))
  (println-error (format "    ~a  Start new session"
    (term/cyan (format "~a" "/session new     "))))
  (println-error (format "    ~a  Resume a session"
    (term/cyan (format "~a" "/session resume ID"))))
  (println-error (format "    ~a  Show token usage"
    (term/cyan (format "~a" "/usage           "))))
  (println-error (format "    ~a  Show current status"
    (term/cyan (format "~a" "/status          "))))
  (println-error "")
  (println-error (term/style "  Multi-Model:" :bold))
  (println-error (format "    ~a  Ask multiple LLMs and synthesize"
    (term/cyan (format "~a" "/consensus <question>"))))
  (println-error (format "    ~a  Exit pi-sema"
    (term/cyan (format "~a" "/quit            "))))
  (println-error "")
  state)

;; ============================================================
;; Section 4: /clear
;; ============================================================

(define (cmd-clear state)
  (let ((new-session (session/new (get state :cwd ".") (get state :model ""))))
    (show-info "Conversation cleared.")
    (assoc (assoc state :messages '()) :session new-session)))

;; ============================================================
;; Section 5: /model [name]
;; ============================================================

(define (cmd-model args state)
  (if (equal? args "")
    (begin
      (show-info (format "Current model: ~a" (get state :model "")))
      state)
    (begin
      (show-info (format "Model switched to: ~a" args))
      (assoc state :model args))))

;; ============================================================
;; Section 6: /compact
;; ============================================================

(define (cmd-compact state)
  (let* ((messages (get state :messages '()))
         (before-count (length messages))
         (compacted (compact-messages messages))
         (after-count (length compacted)))
    (show-info (format "Compacted: ~a messages → ~a messages" before-count after-count))
    (assoc state :messages compacted)))

;; ============================================================
;; Section 7: /session
;; ============================================================

(define (cmd-session args state)
  (let* ((parts (string/split (string/trim args) " "))
         (sub (if (null? parts) "" (car parts)))
         (sub-args (if (or (null? parts) (null? (cdr parts)))
                     ""
                     (string/trim (string/join (cdr parts) " ")))))
    (cond
      ((equal? sub "list")   (cmd-session-list state))
      ((equal? sub "new")    (cmd-session-new state))
      ((equal? sub "resume") (cmd-session-resume sub-args state))
      (else
        (show-error "Usage: /session list | /session new | /session resume <id>")
        state))))

(define (cmd-session-list state)
  (let ((sessions (session/list)))
    (if (null? sessions)
      (show-info "No saved sessions.")
      (begin
        (println-error "")
        (println-error (term/style "  Saved Sessions:" :bold))
        (for-each
          (lambda (s)
            (println-error (format "    ~a  ~a  ~a"
              (term/cyan (truncate-str (get s :id "") 12))
              (term/dim (get s :timestamp ""))
              (term/dim (truncate-str (get s :preview "") 50)))))
          sessions)
        (println-error ""))))
  state)

(define (cmd-session-new state)
  (let ((new-session (session/new (get state :cwd ".") (get state :model ""))))
    (show-info "New session started.")
    (assoc (assoc state :messages '()) :session new-session)))

(define (cmd-session-resume id state)
  (if (equal? id "")
    (begin
      (show-error "Usage: /session resume <id>")
      state)
    (try
      (let ((session (session/resume id)))
        (show-info (format "Resumed session ~a" id))
        (assoc (assoc state :messages (get session :messages '())) :session session))
      (catch e
        (show-error (format "~a" e))
        state))))

;; ============================================================
;; Section 8: /usage
;; ============================================================

(define (cmd-usage state)
  (let ((usage (llm/session-usage))
        (messages (get state :messages '()))
        (est-tokens (estimate-tokens messages)))
    (show-usage usage)
    (show-info (format "Estimated tokens in conversation: ~a" est-tokens)))
  state)

;; ============================================================
;; Section 9: /status
;; ============================================================

(define (cmd-status state)
  (let* ((messages (get state :messages '()))
         (session (get state :session {}))
         (est-tokens (estimate-tokens messages)))
    (println-error "")
    (println-error (term/style "  Status:" :bold))
    (println-error (term/dim (format "  Model:          ~a" (get state :model ""))))
    (println-error (term/dim (format "  Mode:           ~a" (get state :mode :normal))))
    (when (not (= (get state :plan "") ""))
      (println-error (term/dim (format "  Plan:           ~a" (truncate-str (get state :plan "") 50)))))
    (println-error (term/dim (format "  Session ID:     ~a" (get session :id ""))))
    (println-error (term/dim (format "  Messages:       ~a" (length messages))))
    (println-error (term/dim (format "  Est. tokens:    ~a" est-tokens)))
    (println-error (term/dim (format "  Working dir:    ~a" (get state :cwd ""))))
    (println-error ""))
  state)

;; ============================================================
;; Section 10: /plan [goal]
;; ============================================================

(define (cmd-plan args state)
  (cond
    ;; /plan show — display current plan
    ((equal? args "show")
     (let ((plan (get state :plan "")))
       (if (= plan "")
         (show-info "No active plan.")
         (begin
           (println-error "")
           (println-error (term/style "  Active Plan:" :bold))
           (println-error "")
           (println plan)
           (println-error ""))))
     state)

    ;; /plan clear — discard plan and return to normal mode
    ((equal? args "clear")
     (show-info "Plan cleared. Returning to normal mode.")
     (assoc (assoc state :mode :normal) :plan ""))

    ;; /plan <goal> — enter planning mode and generate a plan
    ((not (= args ""))
     (show-info (format "Entering planning mode: ~a" args))
     (show-info "Investigating codebase with read-only tools...")
     (println-error "")
     (try
       (let* ((result (run-plan-turn state args))
              (plan-text (get result :plan "")))
         (show-response plan-text)
         (show-info "Plan generated. Type /approve to execute, /plan clear to discard.")
         ;; Save plan to session
         (try
           (session/append (get state :session)
             {:type "plan"
              :goal args
              :content plan-text
              :timestamp (timestamp)})
           (catch e #f))
         (assoc (assoc state :mode :plan) :plan plan-text))
       (catch e
         (show-error (format "Planning failed: ~a" (get e :message (str e))))
         state)))

    ;; /plan with no args — show usage
    (else
      (show-info "Usage: /plan <goal> | /plan show | /plan clear")
      state)))

;; ============================================================
;; Section 11: /approve
;; ============================================================

(define (cmd-approve state)
  (let ((mode (get state :mode :normal))
        (plan (get state :plan "")))
    (cond
      ((= plan "")
       (show-error "No plan to approve. Use /plan <goal> first.")
       state)
      ((equal? mode :execute)
       (show-info "Already in execution mode. Use /next to continue.")
       state)
      (else
       (show-info "Plan approved. Entering execution mode.")
       (show-info "Starting execution — the agent will do 2-3 steps then pause.")
       (show-info "Type /next to continue, /plan show to review, /plan clear to abort.")
       (println-error "")
       (try
         (let* ((exec-state (assoc state :mode :execute))
                (result (run-execute-turn exec-state))
                (response (get result :response ""))
                (messages (get result :messages '())))
           (show-response response)
           ;; Save to session
           (try
             (begin
               (session/save-message (get state :session) "user" "[plan execution: initial batch]")
               (session/save-message (get state :session) "assistant" response))
             (catch e #f))
           (show-info "Batch complete. Type /next to continue, /plan clear to stop.")
           (assoc (assoc (assoc state :mode :execute) :messages messages) :plan plan))
         (catch e
           (show-error (format "Execution error: ~a" (get e :message (str e))))
           state))))))

           ;; ============================================================
           ;; Section 12: /next
           ;; ============================================================

           (define (cmd-next state)
             (let ((mode (get state :mode :normal))
                   (plan (get state :plan "")))
               (cond
                 ((not (equal? mode :execute))
                  (show-error "Not in execution mode. Use /plan <goal> then /approve first.")
                  state)
                 ((= plan "")
                  (show-error "No active plan. Use /plan <goal> to create one.")
                  state)
                 (else
                  (show-info "Continuing execution...")
                  (println-error "")
                  (try
                    (let* ((result (run-execute-turn state))
                           (response (get result :response ""))
                           (messages (get result :messages '())))
                      (show-response response)
                      ;; Save to session
                      (try
                        (begin
                          (session/save-message (get state :session) "user" "[plan execution: next batch]")
                          (session/save-message (get state :session) "assistant" response))
                        (catch e #f))
                      ;; Auto-compact if needed
                      (let ((compacted (auto-compact
                                         (get state :session)
                                         messages
                                         (get state :model)
                                         80000)))
                        (show-info "Batch complete. Type /next to continue, /plan clear when done.")
                        (assoc (assoc state :messages compacted) :plan plan)))
                    (catch e
                      (show-error (format "Execution error: ~a" (get e :message (str e))))
                      state))))))

           ;; ============================================================
           ;; Section 13: /consensus <question>
           ;; ============================================================

           ;; Provider configs — model names for each provider
           (define consensus-providers
             (list
               {:provider :anthropic :model "claude-sonnet-4-20250514"     :label "Claude Sonnet"}
               {:provider :openai    :model "gpt-4.1"                     :label "GPT-4.1"}
               {:provider :gemini    :model "gemini-2.5-flash"             :label "Gemini 2.5 Flash"}
               {:provider :groq      :model "llama-3.3-70b-versatile"     :label "Llama 3.3 70B (Groq)"}
               {:provider :xai       :model "grok-3-mini-fast"            :label "Grok 3 Mini"}
               {:provider :mistral   :model "mistral-small-latest"        :label "Mistral Small"}))

           (define (consensus-ask-provider cfg question conversation-context)
             "Ask a single provider. Returns {:label ... :response ... :error bool}."
             (let ((label (:label cfg))
                   (provider-kw (:provider cfg))
                   (model (:model cfg)))
               (println-error (term/dim (format "    ⟳ ~a (~a)..." label model)))
               (let ((start (time-ms)))
                 (try
                   (begin
                     (llm/set-default provider-kw)
                     (let* ((system-msg
                              (string-append
                                "You are an expert software engineer. Give a clear, thorough answer. "
                                "Be specific and practical. Include code examples when relevant."
                                (if (= conversation-context "")
                                  ""
                                  (string-append
                                    "\n\nHere is the conversation context so far:\n\n"
                                    conversation-context))))
                            (response (llm/complete question
                              {:model model :max-tokens 1500 :system system-msg}))
                            (elapsed (- (time-ms) start)))
                       (println-error (format "    ~a ~a ~a"
                         (term/green "✔")
                         (term/style label :bold)
                         (term/dim (format "(~as)" (/ elapsed 1000)))))
                       {:label label :response response :error #f}))
                   (catch e
                     (println-error (format "    ~a ~a ~a"
                       (term/red "✘")
                       label
                       (term/dim (format "~a" (get e :message (str e))))))
                     {:label label :response "" :error #t})))))

           (define (consensus-synthesize question responses default-provider)
             "Synthesize multiple model responses into a unified answer."
             (llm/set-default default-provider)
             (let ((synthesis-prompt
                     (string-append
                       "You received responses from multiple AI models to the same question.\n\n"
                       "## Question\n\n" question "\n\n"
                       "## Responses\n\n"
                       (string/join
                         (map (fn (r) (format "### ~a\n\n~a\n" (:label r) (:response r)))
                           responses)
                         "\n")
                       "\n## Your Task\n\n"
                       "Synthesize the best answer by combining the strongest insights from each response. "
                       "Where the models agree, state the consensus confidently. "
                       "Where they disagree, explain the trade-offs. "
                       "If one model has a clearly better insight, highlight it. "
                       "Be practical and specific. Include code examples if any model provided good ones.\n\n"
                       "Do NOT list the models or attribute points to specific models — "
                       "just present the unified best answer as if it were your own.")))
               (llm/complete synthesis-prompt {:max-tokens 3000 :temperature 0.3})))

           (define (cmd-consensus args state)
             (when (= args "")
               (show-error "Usage: /consensus <question>")
               (return state))

             (let ((available (llm/list-providers)))
               ;; Filter to configured providers
               (let ((active (filter
                               (fn (cfg) (any (fn (p) (= p (:provider cfg))) available))
                               consensus-providers)))
                 (when (< (length active) 2)
                   (show-error (format "Need at least 2 providers, found ~a. Set more API keys."
                     (length active)))
                   (return state))

                 (println-error "")
                 (println-error (format "  ~a" (term/style "Consensus Query" :bold)))
                 (println-error (term/dim (format "  \"~a\"" (truncate-str args 80))))
                 (println-error (term/dim (format "  Asking ~a providers..." (length active))))
                 (println-error "")

                 ;; Build conversation context from recent messages
                 (let* ((messages (get state :messages '()))
                        (recent (if (> (length messages) 6)
                                  (list-tail messages (- (length messages) 6))
                                  messages))
                        (context-str (if (null? recent)
                                       ""
                                       (string/join
                                         (map (fn (m)
                                           (format "[~a] ~a"
                                             (get m :role "?")
                                             (truncate-str (get m :content "") 200)))
                                           recent)
                                         "\n")))
                        ;; Remember current default to restore after
                        (original-provider (car available))
                        ;; Ask all providers
                        (results (map (fn (cfg) (consensus-ask-provider cfg args context-str)) active))
                        (successful (filter (fn (r) (not (:error r))) results)))

                   (when (< (length successful) 2)
                     (println-error "")
                     (show-error "Too many providers failed. Need at least 2 successful responses.")
                     (llm/set-default original-provider)
                     (return state))

                   ;; Synthesize
                   (println-error "")
                   (println-error (term/dim (format "    ⟳ Synthesizing ~a responses..." (length successful))))

                   (try
                     (let ((synthesis (consensus-synthesize args successful original-provider)))
                       (println-error (format "    ~a ~a"
                         (term/green "✔")
                         (term/style "Synthesis complete" :bold)))

                       ;; Restore default provider
                       (llm/set-default original-provider)

                       ;; Display the result
                       (show-response synthesis)

                       (println-error (term/dim (format "  Models consulted: ~a"
                         (string/join (map (fn (r) (:label r)) successful) ", "))))
                       (println-error "")

                       ;; Add to conversation history so the agent has context
                       (let ((new-messages (append
                               (get state :messages '())
                               (list {:role "user" :content (format "[consensus] ~a" args)}
                                     {:role "assistant" :content synthesis}))))
                         ;; Save to session
                         (try
                           (begin
                             (session/save-message (get state :session) "user" (format "[consensus] ~a" args))
                             (session/save-message (get state :session) "assistant" synthesis))
                           (catch e #f))
                         (assoc state :messages new-messages)))
                     (catch e
                       (llm/set-default original-provider)
                       (show-error (format "Synthesis failed: ~a" (get e :message (str e))))
                       state))))))
