;;; context.sema â€” AGENTS.md discovery and skill loading
;;;
;;; Discovers context files (AGENTS.md, .pi-sema/agents.md, CLAUDE.md)
;;; by walking up the directory tree, and discovers skill files from
;;; .pi-sema/skills/ directories.

(load "util.sema")

;; ============================================================
;; Context file discovery
;; ============================================================

;; Names to look for at each directory level
(define context-file-names (list "AGENTS.md" ".pi-sema/agents.md" "CLAUDE.md"))

;; Try to read a file, returning its content or #f on error
(define (safe-read-file path)
  (try
    (file/read path)
    (catch e #f)))

;; Collect context files from a single directory
(define (collect-context-in-dir dir)
  (foldl
    (lambda (acc name)
      (let ((full-path (path/join dir name)))
        (if (file/exists? full-path)
          (let ((content (safe-read-file full-path)))
            (if content
              (cons {:path full-path :content content} acc)
              acc))
          acc)))
    '()
    context-file-names))

;; Walk from cwd up to filesystem root, collecting context files.
;; Returns list ordered root-most first (closest-to-cwd last).
(define (discover-context-files cwd)
  (let loop ((dir cwd) (acc '()))
    (let* ((found    (collect-context-in-dir dir))
           (new-acc  (append found acc))
           (parent   (path/dirname dir)))
      (if (equal? parent dir)
        (reverse new-acc)
        (loop parent new-acc)))))

;; ============================================================
;; Context loading
;; ============================================================

;; Concatenate all discovered context files into a single string
;; with section headers. Returns "" if no files found.
(define (load-context-files cwd)
  (let ((files (discover-context-files cwd)))
    (if (null? files)
      ""
      (string/join
        (map
          (lambda (f)
            (string-append "## Context from "
              (get f :path)
              "\n"
              (get f :content)))
          files)
        "\n\n"))))

;; ============================================================
;; Skill discovery
;; ============================================================

;; Extract the first non-empty line after any # heading as description
(define (extract-skill-description content)
  (let ((lines (string/split content "\n")))
    (let loop ((remaining lines) (past-heading #f))
      (if (null? remaining)
        ""
        (let ((line (string/trim (car remaining))))
          (cond
            ((= line "") (loop (cdr remaining) past-heading))
            ((string/starts-with? line "#") (loop (cdr remaining) #t))
            (past-heading line)
            (else line)))))))

;; Discover skill files in .pi-sema/skills/ under cwd.
;; Each .md file becomes a skill with name, description, and path.
(define (discover-skills cwd)
  (let ((skills-dir (path/join cwd ".pi-sema" "skills")))
    (if (file/exists? skills-dir)
      (let ((entries (file/list skills-dir)))
        (foldl
          (lambda (acc filename)
            (if (string/ends-with? filename ".md")
              (let* ((skill-path (path/join skills-dir filename))
                     (name
                       (substring filename
                         0
                         (- (string-length filename) 3)))
                     (content (safe-read-file skill-path))
                     (description
                       (if content
                         (extract-skill-description content)
                         "")))
                (cons
                  {:name name
                   :description description
                   :path skill-path}
                  acc))
              acc))
          '()
          entries))
      '())))

;; ============================================================
;; Skill formatting
;; ============================================================

;; Render a skills list as XML for inclusion in system prompts.
;; Returns "" if the skills list is empty.
(define (format-skills-xml skills)
  (if (null? skills)
    ""
    (let ((skill-entries
            (map
              (lambda (s)
                (format
                  "  <skill>\n    <name>~a</name>\n    <description>~a</description>\n    <location>~a</location>\n  </skill>"
                  (get s :name)
                  (get s :description)
                  (get s :path)))
              skills)))
      (string-append "<available_skills>\n"
        (string/join skill-entries "\n")
        "\n</available_skills>"))))
